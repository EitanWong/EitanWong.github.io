[{"content":"An adverb is a word that modifies (describes) a verb (“he sings loudly”), an adjective (“very tall”), another adverb (“ended too quickly”), or even a whole sentence (“Fortunately, I had brought an umbrella.”). Adverbs often end in -ly, but some (such as fast) look exactly the same as their adjective counterparts.\nTom Longboat did not run badly.\nTom is very tall.\nThe race finished too quickly.\nFortunately, Lucy recorded Tom’s win.\nIt’s easy to identify the adverbs in these sentences.\nAdverb examples Adverbs are easy to recognize because they usually end in –ly, but not always. Some of the most common adverb examples include:\nreally, very well, badly today, yesterday, everyday, etc. sometimes, often, rarely, etc. early, late, soon, etc. here, there, everywhere, etc*.* Adverbs and verbs Adverbs often modify verbs. This means that they describe the way an action is happening.\nHuan sings loudly in the shower.\nMy cat waits impatiently for his food.\nI will seriously consider your suggestion.\nThe adverb in each of the sentences above answers the question In what manner? How does Huan sing? Loudly. How does my cat wait? Impatiently. How will I consider your suggestion? Seriously. Adverbs can answer other types of questions about how an action was performed. They can also tell you when (“we arrived early”), where (“turn here”), or with what frequency (“I go there often”).\nHowever, there is one type of verb that doesn’t mix well with adverbs. Linking verbs, such as feel, smell, sound, seem, and appear, typically precede adjectives, not adverbs. A very common example of the type of mixup that happens with linking verbs is the following:\nPaz feels badly about what happened. Because feel is a verb, it seems to call for an adverb rather than an adjective. But feel isn’t just any verb; it’s a linking verb, which means that it links the subject of a sentence to the modifier that follows it. Since a subject is, by definition, a noun (or a pronoun), it is modified by an adjective. An adverb would describe how you perform the action of feeling—an adjective describes what you feel. “Paz feels badly” means that Paz is bad at feeling things. If Paz is trying to read Braille through thick leather gloves, then it might make sense for you to say “Paz feels badly.” But if you’re trying to say that Paz is experiencing negative emotions, “Paz feels bad” is the phrase you want.\nAdverbs and adjectives Adverbs can also modify adjectives. An adverb modifying an adjective generally adds a degree of intensity or some other kind of qualification to the adjective.\nThe lake is quite beautiful.\nThis book is more interesting than the last one.\n“Is my singing too loud?” asked Huan.\nMy cat is incredibly happy to be having his dinner.\nWe will be slightly late to the meeting.\nThis shirt is a very unflattering shade of puce.\nAdverbs and other adverbs You can use an adverb to describe another adverb. In the following sentence, the adverb almost is modifying the adverb always (and they’re both modifying the adjective right):\nThe weather report is almost always right. In fact, if you wanted to, you could use several adverbs to modify another adverb.\nHuan sings rather enormously too loudly. However, that often produces weak and clunky sentences like the one above, so be careful not to overdo it.\nAdverbs and sentences Some adverbs can modify entire sentences—unsurprisingly, these are called sentence adverbs. Common ones include generally, fortunately, interestingly, and accordingly. Sentence adverbs don’t describe one particular thing in the sentence—instead, they describe a general feeling about all of the information in the sentence.\nFortunately, we got there in time.\nInterestingly, no one at the auction seemed interested in bidding on the antique spoon collection.\nAt one time, the use of the word hopefully as a sentence adverb (e.g., “Hopefully, I’ll get this job”) was condemned. People continued to use it, though, and many style guides and dictionaries now accept it. That said, there are still plenty of readers out there who hate it, so it’s a good idea to avoid using it in formal writing.\nDegrees of comparison Like adjectives, many adverbs can show degrees of comparison, although it’s slightly less common to use them this way. With certain flat adverbs (adverbs that look exactly the same as their adjective counterparts), the comparative and superlative forms look the same as the adjective comparative and superlative forms. It’s usually better to use stronger, more precise adverbs (or stronger, more precise adjectives and verbs) than to rely on comparative and superlative adverbs.\nAn absolute or positive adverb describes something in its own right:\nHe smiled warmly.\nThey asked me to deliver a hastily written note.\nTo make the comparative form of an adverb that ends in -ly, add the word more:\nHe smiled more warmly than the others.\nThe more hastily written note contained the clue.\nTo make the superlative form of an adverb that ends in -ly, add the word most:\nHe smiled most warmly of them all.\nThe most hastily written note on the desk was overlooked.\nPlacement of adverbs In general, adverbs should be placed as close as possible to the words they are intended to modify. Putting the adverb in the wrong spot can produce an awkward sentence at best and completely change the meaning at worst. Consider the difference in meaning between the following two sentences:\nI almost dropped all the papers I was holding.\nI dropped almost all the papers I was holding.\nThe first sentence is correct if it’s meant to communicate that you very nearly dropped the papers but managed to hold on to them—the adverb almost comes right before the verb dropped, so it’s most naturally understood as modifying dropped. In the second sentence, almost has moved to modify the adjective all, communicating that you did drop most of the papers.\nBe especially careful about the word only, which can be an adverb, an adjective, or a conjunction and is one of the most often misplaced modifiers. Consider the difference between these two sentences:\nPhillip only fed the cat.\nPhillip fed only the cat.\nThe first sentence means that all Phillip did was feed the cat. He didn’t pet the cat or pick it up or anything else. The second sentence means that Phillip fed the cat, but he didn’t feed the dog, the bird, or anyone else who might have been around.\nWhen an adverb is modifying a verb phrase, the most natural place for it is usually the middle of the phrase.\nWe are quickly approaching the deadline.\nHuan has always loved singing.\nI will happily assist you.\nWhen to avoid adverbs Ernest Hemingway is often held up as an example of a great writer who detested adverbs and advised other writers to avoid them. In reality, it’s impossible and unnecessary to avoid adverbs altogether. Sometimes we need them, and all writers (even Hemingway) use them occasionally.\nThe trick is to avoid superfluous adverbs. When your verb or adjective doesn’t seem powerful or precise enough, instead of reaching for an adverb to add more color, try reaching for a stronger verb or adjective instead. For example, the following two sentences are both grammatically correct and mean the same thing, but you’ll probably agree that the second, in which the verb wrested does all the work that the adverbs forcefully and away are doing in the first, packs more of a punch.\nThe board forcefully took control away from the founder.\nThe board wrested control from the founder.\nIf you find yourself piling on the adverbs, many times you cancome up with a better word, and your writing will be stronger for it.\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson12_adverb_in_english/","summary":"An adverb is a word that modifies (describes) a verb (“he sings loudly”), an adjective (“very tall”), another adverb (“ended too quickly”), or even a whole sentence (“Fortunately, I had brought an umbrella.”). Adverbs often end in -ly, but some (such as fast) look exactly the same as their adjective counterparts. Tom Longboat did not run badly. Tom is very tall. The race finished too quickly. Fortunately, Lucy recorded Tom’s win. It’s","title":"Lesson12 Adverb in English"},{"content":"What Is an Adjective? Adjectives are words that describe the qualities or states of being of nouns: enormous, doglike, silly, yellow, fun, fast. They can also describe the quantity of nouns: many, few, millions, eleven.\nAdjectives modify nouns As you may already know, adjectives are words that modify (describe) nouns. Adjectives do not modify verbs or adverbs or other adjectives.\nExamples Margot wore a beautiful hat to the pie-eating contest.\nFurry dogs may overheat in the summertime.\nMy cake should have sixteen candles.\nThe scariest villain of all time is Darth Vader.\nIn the sentences above, the adjectives are easy to spot because they come immediately before the nouns they modify.\nBut adjectives can modify nouns even without appearing right before them in a sentence. Acting as what’s called a subjective complement with the help of a linking verb, a predicate adjective modifies the subject of a sentence. A linking verb is a verb like to be, to feel, to seem, or to taste that, rather than describing an action, helps to describe a state of being or a sensory experience.\nExamples That cow sure is happy.\nIt smells gross in the locker room.\nDriving is faster than walking.\nUses of adjectives Adjectives tell the reader what kind of something you’re talking about, or how much or how many of something you’re talking about.\nExamples Please use three white flowers in the arrangement.\nThree and white are modifying flowers.\nOften, when adjectives are used together, you should separate them with a comma or conjunction. See “Coordinate adjectives” below for more detail.\nExamples I’m looking for a small, good-tempered dog to keep as a pet.\nMy new dog is small and good-tempered.\nDegrees of adjectives Adjectives come in three forms, known as degrees: absolute, comparative, and superlative.\nAbsolute adjectives describe something in its own right.\nExamples A cool guy\nA messy desk\nA rigid guideline\nAn awful situation\nA mischievous cat\nGarrulous squirrels\nComparative adjectives unsurprisingly, make a comparison between two or more things. For most one-syllable adjectives, the comparative is formed by adding the suffix -er (or just -r if the adjective already ends with an e). For two-syllable adjectives, some use -er to form the comparative while others use the word more. In general, two-syllable adjectives ending in –er, –le, –ow, –ure, or –y can be made comparative by adding -er (in the case of -y words, replace y with –ier). For adjectives of three or more syllables, add the word more.\nExamples A cooler guy\nA messier desk\nA rigider/more rigid guideline\nA more awful situation\nA more mischievous cat\nMore garrulous squirrels\nSuperlative adjectives indicate that something has the highest degree of the quality in question. One-syllable adjectives become superlatives by adding the suffix -est (or just -st for adjectives that already end in e). As with the comparative, some two-syllable adjectives use -est to form the superlative while others use the word most. In general, two-syllable adjectives ending in -y replace -y with -iest. Adjectives of three or more syllables add the word most. When you use an article with a superlative adjective, it will almost always be the definite article (the) rather than a or an. Using a superlative inherently indicates that you are talking about a specific item or items.\nExamples The coolest guy\nThe messiest desk\nThe rigidest/most rigid guideline\nThe most awful situation\nThe most mischievous cat\nThe most garrulous squirrels\nCoordinate adjectives Coordinate adjectives should be separated by a comma or the word and. Adjectives are said to be coordinate if they modify the same noun in a sentence to the same degree.\nExamples This is going to be a long, cold winter.\nIsobel’s dedicated and tireless efforts made all the difference.\nSometimes, when two adjectives appear next to each other and modify the same noun, the one closer to the noun is so closely related to the noun that they form a single semantic unit together, and that unit is what is modified by the first adjective. In this case, the adjectives are not coordinate and should not be separated by a comma.\nExamples My cat, Goober, loves sleeping on this tattered woolen sweater.\nNo one could open the old silver locket.\nIn some cases, it’s pretty hard to tell whether two adjectives are coordinate or not. But there are a couple of ways you can test them. Try inserting the word and between the adjectives to see if the phrase still seems natural. In the first sentence above, “this tattered and woolen sweater” doesn’t sound right, because you really aren’t talking about a sweater that is both tattered and woolen in the same way. It’s a woolen sweater inherently, and it has become tattered. Woolen sweater forms a unit of meaning that is modified by tattered.\nAnother way to test for coordinate adjectives is to try switching the order of the adjectives and seeing if the phrase still works. In the second sentence, you wouldn’t say “No one could open the silver old locket.” You can’t reverse the order of the adjectives because silver locket is a unit that is modified by old.\nAdjectives vs. adverbs Many of us learned in school that adjectives modify nouns and that adverbs modify verbs. But as we’ve seen, adjectives don’t need to be right next to nouns in order to modify them; they can do so from after a linking verb in a sentence, as predicate adjectives. This leads to a common type of mistake: using an adverb when what you want is a predicate adjective. Here’s an example you’ve probably heard before:\nExamples I feel badly about what happened. Because feel is a verb, it may seem to call for an adverb rather than an adjective. But feel isn’t just any verb; it’s a linking verb. An adverb would describe how you perform the action of feeling—an adjective describes what you feel. “I feel badly” would mean that you are bad at feeling things. If you’re trying to read Braille through thick leather gloves, then it might make sense for you to say “I feel badly.” But if you’re trying to say that you are experiencing a negative emotion, “I feel bad” is the phrase you want.\nIt’s easier to see this distinction with a different linking verb. Consider the difference between these two sentences:\nExamples Max smells badly.\nMax smells bad.\n“Max smells badly” means that Max, the poor thing, has a weak sense of smell. “Max smells bad” means that Max stinks—poor us.\nWhen nouns are adjectives and adjectives are nouns One more thing you should know about adjectives is that, sometimes, a word that is normally used as a noun can function as an adjective, depending on its placement.\nExamples Never try to pet someone’s guide dog without asking permission first. Guide is a noun, but in this sentence, it is being put to use as an adjective to modify dog.\nIt works the other way too: Sometimes words that are normally adjectives shift into use as nouns. Many times this happens with adjectives used to denote a group of people, with the addition of the:\nExamples The French are known for valuing their leisure time.\nRobin Hood stole from the rich to give to the poor.\nIn the above examples, the word people has been elided and the adjectives French, rich, and poor are functioning as nouns. This kind of shift happens with other kinds of adjective-noun pairs too, however, especially when they are commonly used together:\nExamples Our English class took our final this morning.\nCamille tends to focus on intangibles like communication style and a sense of camaraderie when deciding whether to accept a job offer.\nIn these sentences, the nouns exam and qualities have been elided.\nAdjective usage advice We’ll end with a few words about adjectives and style.\nIt’s one thing to know how to use an adjective; it’s another to know when using one is a good idea.\nGood writing is precise and concise.\nSometimes you need an adjective to convey exactly what you mean.\nIt’s hard to describe a red sports car without the word red.\nBut often, choosing the right noun eliminates the need to tack on an adjective.\nIs it a big house, or is it a mansion?\nA large crowd or a throng?\nA mixed-breed dog or a mutt?\nA dark night or just . . . night?\nAlways aim to make every word count in your writing.\nIf you need an adjective, use it.\nBut if it’s not pulling its weight, delete it.\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson11_adjective_in_english/","summary":"What Is an Adjective? Adjectives are words that describe the qualities or states of being of nouns: enormous, doglike, silly, yellow, fun, fast. They can also describe the quantity of nouns: many, few, millions, eleven. Adjectives modify nouns As you may already know, adjectives are words that modify (describe) nouns. Adjectives do not modify verbs or adverbs or other adjectives. Examples Margot wore a beautiful hat to the pie-eating contest. Furry dogs may overheat in the summertime. My cake should have sixteen candles. The scariest villain of all time is Darth Vader. In the sentences above, the adjectives are easy to spot because they come immediately before the nouns they modify. But adjectives can modify nouns even without appearing right before them in a sentence. Acting as what’s called a subjective complement with the help","title":"Lesson11: Adjective in English"},{"content":"Demonstrative pronouns: pronouns used to identify people or things\nused to replace nouns already mentioned or refer to something people know\nthis(these)\nthat(those)\nExample: This is his book.\nThose apples were his.\nThese teaches are from China.\nIndefinite pronouns Refers to an uncertain person or thing\none the other some any something nothing Example: No one knows where he is.\nSome of the boys want to go to Shanghai, but the others want to go to Xi'an.\nEach of the students has got a book.\nI know nothing about this person.\nI have something to tell you.\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson10_demonstrative_and_indefinite_pronouns/","summary":"Demonstrative pronouns: pronouns used to identify people or things used to replace nouns already mentioned or refer to something people know this(these) that(those) Example: This is his book. Those apples were his. These teaches are from China. Indefinite pronouns Refers to an uncertain person or thing one the other some any something nothing Example: No one knows where he is. Some of the boys want to go to Shanghai, but the others want to go to Xi'an. Each of the students has got a book. I know nothing about this person. I have something to tell you.","title":"Lesson10: Demonstrative and indefinite pronouns"},{"content":"What Is a Noun? Definition, Types, and Examples Nouns are everywhere in our writing. But what are all the types of nouns you come across, and how do you use them?\nA noun is a word that names something, such as a person, place, thing, or idea. In a sentence, nouns can play the role of subject, direct object, indirect object, subject complement, object complement, appositive, or modifier.\nSome noun examples include:\ncat bicycle Taylor Swift Kuala Lumpur Types of nouns Nouns form a large proportion of English vocabulary, and they come in a wide variety of types.\nNouns can name a person: Albert Einstein\nthe president\nmy mother\na girl\nNouns can name a place: Mount Vesuvius\nDisneyland\nmy bedroom\nNouns can name things: Things might include intangible things, such as concepts, activities, or processes. Some might even be hypothetical or imaginary things.\nshoe\nfaucet\nfreedom\nThe Elder Wand\nbasketball\nProper nouns vs. common nouns One important distinction to be made is whether a noun is a proper noun or a common noun. A proper noun is a specific name of a person, place, or thing and is always capitalized.\nDoes Tina have much homework to do this evening?\nTina is the name of a specific person.\nI would like to visit Old Faithful.\nOld Faithful is the specific name of a geological phenomenon.\nThe opposite of a proper noun is a common noun, sometimes known as a generic noun. A common noun is the generic name of an item in a class or group and is not capitalized unless appearing at the beginning of a sentence or in a title.\nThe girl crossed the river.\nGirl is a common noun; we do not learn the identity of the girl by reading this sentence, though we know the action she takes. River is also a common noun in this sentence.\nTypes of common nouns Common or generic nouns can be broken down into three subtypes: concrete nouns, abstract nouns, and collective nouns. A concrete noun is something that is perceived by the senses; something that is physical or real.\nI heard the doorbell.\nMy keyboard is sticky.\nDoorbell and keyboard name real things that can be sensed.\nConversely, an abstract noun is something that cannot be perceived by the senses.\nWe can’t imagine the courage it took to do that.\nCourage is an abstract noun. Courage can’t be seen, heard, or sensed in any other way, but we know it exists.\nA collective noun denotes a group or collection of people or things.\nThat pack of lies is disgraceful.\nPack as used here is a collective noun. Collective nouns take a singular verb, as they refer to the collection of people or things they identify as one entity—in this case, the singular verb is.\nA pride of lions roamed the savanna.\nPride is also a collective noun.\nNouns and number All nouns are either singular or plural in number. A singular noun refers to one person, place, thing, or idea and requires a singular verb, while a plural noun refers to more than one person, place, thing, or idea and requires a plural verb.\nForming plural nouns Many English plural nouns can be formed by adding -s or -es to the singular form, although there are also many exceptions.\ncat→cats\nThese two cats are both black.\nNote the plural verb are.\ntax→taxes\nhouse→houses\nCountable nouns vs. uncountable nouns Concrete and abstract common nouns can be further classified as either countable or uncountable. Countable nouns are nouns that can be counted, even if the resulting number would be extraordinarily high (like the number of humans in the world). Countable nouns can be singular or plural and can be used with numbers and modifiers like a/an, the, some, any, a few, and many.\nHere is a cat.\nHere are a few cats.\nHere are eight cats.\nUncountable nouns, or mass nouns, are nouns that are impossible to count, whether because they name intangible concepts (e.g., information, animal husbandry, wealth), collections of things that are considered as wholes (e.g., jewelry, equipment, the working class), or homogeneous physical substances (e.g., milk, sand, air). Although most of these nouns are singular in form, because they refer to things that can’t be isolated and counted on their own, they are never used with the singular indefinite article a or an. Singular concrete uncountable nouns can often be expressed in countable units by adding a countable noun like piece (with of). On their own, uncountable nouns can be modified by the definite article, the, or indefinite adjectives like some.\nThey’d love to rent some property around here.\nThey’d love to rent a piece of property around here.\nStudents don’t seem to have much homework these days.\nCould you help me move the furniture into the other room?\nNouns and the possessive case The possessive case shows the relationship of a noun to other words in a sentence. That relationship can be ownership, possession, occupancy, a personal relationship, or another kind of association. The possessive of a singular noun is formed by adding an apostrophe and the letter s.\nThe cat’s toy was missing.\nThe cat possesses the toy, and we denote this by use of -’s at the end of cat.\nCasey’s sister is a geologist.\nHere, the possessive case indicates the relationship between Casey and their sister.\nThe novel’s release made quite a splash.\nIn the above example, the possessive case is denoting that novel is in the role of object in relationship to release; someone released the novel.\nThe possessive of a plural noun that ends in –s or –es is formed by adding just an apostrophe.\nMy nieces’ prom outfits were exquisite.\nThe possessive of an irregular plural noun is formed by adding –’s.\nThe children’s drawings were hung on the walls.\nWhen a singular noun ends in the letter s or z, the general rule of adding –’s often applies.\nI have been invited to my boss’s house for dinner.\nMs. Sanchez’s coat is still hanging on the back of her chair.\nThis is a matter of a style, however, and some style guides call for leaving off the s after the apostrophe.\nBrussels’ cathedrals attract hundreds of thousands of visitors every year.\nWhichever style an organization or writer chooses should be used consistently.\nFunctions of nouns\nNouns take on different roles based on their relationships to the rest of the words in a sentence.\nNouns as subjects Every sentence must have a subject, and that subject will always be a noun or pronoun. The subject of a sentence is the person, place, or thing that is doing or being or experiencing whatever is described by the verb of the sentence.\nMaria played the piece beautifully.\nThe noun Maria is the subject of this sentence; it tells us who is performing the action described by the sentence’s verb (played).\nNouns as objects Nouns can also be objects of a transitive verb in a sentence. An object can be either a direct object (a noun that receives the action described by the verb) or an indirect object (a noun that receives direct object).\nCleo passed the salt.\nCleo passed Otto the salt.\nIn both of the above sentences, the noun salt is the direct object of the verb passed; the salt is what Cleo passed. In the second sentence, there is also an indirect object: the noun Otto. Otto is the person to whom Cleo passed the salt; Otto is the recipient of the salt. A good way to identify an indirect object in a sentence is to ask yourself to whom/what or for whom/what something is being done.\nNouns as subject and object complements Another role nouns sometimes perform in a sentence is that of a subject complement. A subject complement normally follows a linking verb such as be, become, or seem and gives more information about the subject of the sentence.\nMary is a teacher.\nIn this sentence, the noun teacher is being used as a subject complement. A teacher is what Mary is.\nA related function of nouns is to act as an object complement, which provides more information about the direct object of a sentence with a transitive verb.\nI now pronounce you husbands.\nHusbands is a noun used as an object complement in this sentence. Verbs that denote making, naming, or creating are often followed by nouns behaving as object complements.\nNouns as appositives A noun used as an appositive immediately follows another noun in order to further define or identify it. You can also say that the second noun is in apposition to the first noun.\nMy brother, Michael, is six years old.\nMichael is an appositive here, further identifying the noun phrase my brother. Appositives can be restrictive or nonrestrictive; in the above example, we can see from the fact that it is set off between commas that Michael is nonrestrictive—that is, it could be left out of the sentence without leaving out essential information about who is six years old. In other words, we can surmise that Michael is the writer’s only brother; telling us his name is extra information about him. Here is a version of the same sentence where the appositive is used restrictively, without being set off by commas:\nMy brother Michael is six years old.\nIn this case, the appositive Michael is providing information that is essential for narrowing down which brother the writer is telling us about. We can infer that they have multiple brothers, and understand that it is the one named Michael who is six years old.\nNouns as modifiers Sometimes, nouns can be used to modify other nouns, functioning like adjectives. When they do this, they are often called attributive nouns. .\nHe is a speed demon.\nSpeed is normally a noun, but here it is acting as an adjective to modify demon.\nNoun FAQs What are nouns? Nouns refer to a person, place, thing, or idea. They serve as the subjects, direct objects, and indirect objects in a sentence, along with other roles.\nWhat are some examples of nouns? Nouns can be living things (Keanu Reeves or cat), places (beach or Detroit), things (ruler or PlayStation 5), or ideas (nihilism or the theory of evolution).\nWhat are the different types of nouns? Common nouns refer to general things (like parks), and proper nouns refer to a specific thing (like Yellowstone National Park). Nouns can also be plural or singular, depending on how many there are, countable or uncountable, and possessive or not possessive.\nHow do you identify a noun in a sentence? Nouns often have articles (the, a, or an) before them in a sentence, but not always. Sometimes you’ll see adjectives like red or some before nouns. Aside from the first word in a sentence, if a word is capitalized, then it’s most likely a proper noun, such as a person’s name.\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson9_noun_in_english/","summary":"What Is a Noun? Definition, Types, and Examples Nouns are everywhere in our writing. But what are all the types of nouns you come across, and how do you use them? A noun is a word that names something, such as a person, place, thing, or idea. In a sentence, nouns can play the role of subject, direct object, indirect object, subject complement, object complement, appositive, or modifier. Some noun examples include: cat bicycle Taylor Swift Kuala Lumpur Types of nouns Nouns form a large proportion of English vocabulary, and they come in a wide variety of types. Nouns can name a person: Albert Einstein the president my mother a girl Nouns can name a place: Mount Vesuvius Disneyland my bedroom Nouns can name things: Things might include intangible things, such as concepts, activities, or processes. Some might even be","title":"Lesson9: Noun in English"},{"content":"English question words: An easy guide to asking good questions Life is full of questions. Who, what, where, when, why, and how - these simple words hold the key to unlocking information and communicating with people in English. We ask questions in a variety of situations, such as when looking for directions, wanting to know more about an event, or trying to find out what happened to a friend.\nAsking questions is a skill that all of us need to learn. In our native languages, asking questions may seem easy and intuitive. However, in a foreign language, it may seem way more complicated.\nSo, how do you ask questions in English? The answer is: with the help of interrogative words (also known as question words).\nTo help you learn how to ask grammatically correct, relevant questions for every situation in English, we’ve covered everything you need to know about English question words in this article.\nWhat are interrogative pronouns/words? !Woman looking at shirt in clothing shop asking English question words such as What size are you\nAn interrogative pronoun is a pronoun used to ask a question in English. It replaces the noun in a question and is usually the first word in a sentence ending with a question mark.\nIn English, these interrogative pronouns are also called wh-words because most start with “wh.” The most common interrogative pronouns are:\nWho? What? When? Where? Which? How? How to ask questions in English Now that you know what interrogative words are (aka, question words), you may be asking yourself how to form grammatically correct questions in English.\nIn English, forming questions follows a pretty simple formula:\nquestion word - auxiliary verb - subject- verb - complement\nTo illustrate this, here’s a great example of this formula in use: “Who did you see yesterday at the party?”\nThis formula sometimes implements the additional noun or adjective between the question word and the auxiliary verb. We’ll go over this in detail when discussing each interrogative pronoun separately.\nWhat’s more, not every question you formulate will require you to use the entire formula. So, think of it as a guide rather than a strict mathematical question!\nThe second formula you can use to form questions in English is without an auxiliary verb:\nquestion word - main verb - subject- complement\nFor example, in the question “Who ate the cake at the party?” there’s no auxiliary verb.\nFor now, take a look at the example sentences in the table below.\nEnglish Pronunciation IPA Example sentence Who hoo /ˈhuː/ Who are you? What wot /ˈhwʌt/ What is this? When wen /hwen/ When did this happen? Where wear /hwer/ Where are you? Why hwigh /ˈwaɪ/ Why are you upset? Which wich /hwɪtʃ/ Which dress do you prefer? How hou /ˈhaʊ/ How are you? Who? “Who” is a word used to ask for information about a person and their identity. This question verb doesn’t have a plural form, so if you’re asking about multiple people, it’ll just be followed by a plural verb instead of a singular one.\nThe main use cases for this question word include asking about a person’s identity and the performer of an action. The main variation of this question word is “whose,” which is used when asking about the possession of a certain object.\nTake a look at these examples:\nEnglish Pronunciation IPA Who are you going with? hoo air yoo goin\u0026rsquo; wit /ˈhuː ər ju ˌgoʊɪŋ wɪθ/ Who won the game? hoo won thuh game /ˈhuː wɑːn ðə ˈɡeɪm/ Who gave you this dress? hoo gav yoo this dres /ˈhuː ˈɡeɪv ju ðɪs ˈdres/ Who was with you at the party? hoo wuhz wit yoo at thuh party /ˈhuː wəz wɪθ ju ət ðə ˈpɑːrti/ Who is the person you were talking to? hoo iz thuh purson yoo wuhr tawkin\u0026rsquo; tuh /ˈhuː ɪz ðə ˈpɝːsn̩ ju wər ˈtɔ:kɪŋ tuː/ Whose car is this? hooz kahr iz this /ˈhuːz ˈkɑ:r z ðɪs/ Whose pencil are you using? hooz pen-sul air yoo yoo-zin /ˈhuːz ˈpensl̩ ər ju ˈjuːzɪŋ/ What? “What” is probably the first question word you learn in English. In your first English class, the teacher asks, “What’s your name” to get everyone’s names.\nIt is a question word used to ask about the identity of a thing or the nature of an action. This interrogative word can also be used with additional nouns to ask more detailed questions about someone or something.\nAnother use case of “what” is asking about the description of a person, object, or place. In this case, “what” questions need to include the phrase “look like.” It follows the formula:\nwhat - auxiliary verb - subject- look like?\nIt can also be used in combination with “like” to ask about someone’s character or the nature of a place. The formula, in this case, is:\nwhat- verb \u0026ldquo;to be\u0026rdquo; - subject-like?\nTo illustrate this, take a look at the examples in the table below.\nEnglish Pronunciation IPA What is your name? Wuhts iz yoo-ur neym? /wɒt ɪz jər ˈneɪm/ What are you doing? Wuhts uh-ree yoo dooin? /wɒt ər ju ˈduːɪŋ/ What ice cream flavor do you like the most? Wuhts ays kreem flehv-ur duh yoo lahy-k thuh mo-st? /wɒt ˈaɪs kri:m ˈfleɪvər du: ju laɪk ðə moʊst/ What is your favorite TV show? Wuhts iz yoo-ur fehv-ur-it T-V shoh? /wɒt ɪz jər ˈfeɪvərət ˈtiːˈviː ˈʃoʊ/ What time do you go to work? Wuhts tahym duh yoo goh tuh wurk? /wɒt ˈtaɪm du: ju ˈɡoʊ tə ˈwɝːk/ What day is today? Wuhts day iz toh-dey? /wɒt ˈdeɪ z təˈdeɪ/ What does your sister look like? Wuhts doh-z yoo-ur sis-tur luk lahy-k? /wɒt dəz jər sɪstər ˈlʊk ˈlaɪk/ What does your car look like? Wuhts doh-z yoo-ur kahr luk lahy-k? /wɒt dəz jər ˈkɑ:r ˈlʊk ˈlaɪk/ What is your city like? Wuhts iz yoo-ur sit-ee lahy-k? /wɒt ɪz jər ˈsɪti ˈlaɪk/ What is your father like? Wuhts iz yoo-ur fah-thur lahy-k? /wɒt ɪz jər ˈfɑːðr̩ ˈlaɪk/ When? “When” is a pretty simple interrogative pronoun with just one use case: to ask about the time of an event. In other words, it’s used to ask about a point in time when something happens.\nEnglish Sentence Pronunciation IPA Representation When are you coming to visit me? Wen er yoo kuhm-ing tuh vuh-zit mi /hwen ər ju ˈkʌmɪŋ tə ˈvɪzət miː/ When are you coming home? Wen er yoo kuhm-ing hohm /hwen ər ju ˈkʌmɪŋ hoʊm, həʊm/ When do the holidays start? Wen duh holidays stahrt /hwen du: ðə ˈhɑːlədeɪz ˈstɑːrt/ When is your yoga class? Wen iz yur yo-guh klahs /hwen ɪz jər ˈjoʊɡə ˈklæs/ When do you want to go to the cinema? Wen duh yoo wahnt tuh guh tuh thuh sin-uh-muh /hwen du: ju ˈwɒnt tə ˈɡoʊ tə ðə ˈsɪnəmə/ When will you visit me? Wen wil yoo vuh-zit mi /hwen ˌwi:l ju ˈvɪzət miː/ Where? Just like “when,” “where” is a pretty straightforward question word to use. The main and only use case for this interrogative pronoun is asking about the location of a place, the place of an action or event, or a destination.\nEssentially, it’s used to ask about the point in space where something is located. Not much detail to go into here!\nEnglish Sentence Pronunciation IPA Representation Where are you going on your weekend trip? weh-r ahr yoo go-in\u0026rsquo; on yoor weekend trip /hwer̩ər ju ˌgoʊɪŋ ˈɑːn jər ˈwiːˌkend ˈtrɪp/ Where is the bus station? weh-r iz thuh bus stuh-shun /ˈhwer ɪz ðə ˈbəs ˈsteɪʃn̩/ Where is the Bad Bunny concert? weh-r iz thuh bad bun-nee kon-sert /ˈhwer ɪz ðə ˌbæd ˈbʌni ˈkɑːnsərt/ Where is this train going? weh-r iz this train go-in' /ˈhwer ɪz ðɪs ˈtreɪn ˈɡoʊɪŋ/ Where would you like to go on vacation? weh-r would yoo like to go on vuh-key-shun /ˈhwer wʊd ju laɪk tə ˈɡoʊ ˈɑːn veˈkeɪʃn̩/ Where is Wally? weh-r iz waw-lee /ˈhwer ɪz ˈwɒli/ Why? “Why” is most commonly used to ask about the cause of something or the reason behind it. The answer to a question starting with “why” is usually introduced with the word “because.”\nBut “why” is a pretty versatile word, and it has a few more use cases, such as:\nAsking for an explanation: Why did you do this? Expressing annoyance with something: Why should we pay taxes? Making suggestions: Why don’t we hurry up? Showing agreement: - Do you want to go to the cinema? - Why not__? Let’s go! English Sentence Pronunciation IPA Representation Why did you do this? hwahy did yoo doo this? /ˈwaɪ ˈdɪd ju du: ðɪs/ Why did the baby throw away its food? hwahy did thuh bay-bee throw away its food? /ˈwaɪ ˈdɪd ðə ˌbeɪbi ˈθroʊ əˈweɪ ɪts ˈfuːd/ Why should we pay taxes every year? hwahy should weh pay taxes ev-ree yair? /ˈwaɪ ʃəd wi ˈpeɪ ˈtæksəz ˈevri ˈjɪr̩/ Why are you upset? hwahy are yoo up-set? /ˈwaɪ ər ju ˌʌpset/ Why don’t we leave now? hwahy dont weh leave now? /ˈwaɪ doʊnt wi ˈli:v ˈnaʊ/ Why isn’t the train leaving? hwahy is-nt thuh train leaving? /ˈwaɪ ˈɪzənt ðə ˈtreɪn ˈliːvɪŋ/ Why are they looking at us? hwahy are they luh-king at us? /ˈwaɪ ər ˈðeɪ ˈlʊkɪŋ ət əz/ Which? When it comes to “which,” it’s a quite particular interrogative word. We use “which” to ask for more information about something when there are limited options to choose from.\nFor example, in the question “Which dress do you prefer?”, we’re asking the recipient of the question about their specific preferences between a given number of options.\n“Which” can also be used with “of” when there are other determiners (the, those, your) or pronouns used in the questions. The question “Which of the following features do you use the most?” is an excellent example of how to use this.\nEnglish Sentence Pronunciation IPA Representation Which ice cream flavor do you prefer? wich ays krim flay-vuhr doo yoo prefuhr? chawk-lit or van-uh-luh? /hwɪtʃ ˈaɪs kri:m ˈfleɪvər du: ju prəˈfɝː ˌtʃɔːklət ɔːr vəˈnɪlə/ Which feature is your favorite? wich fea-cher iz yoor fey-vrit? /hwɪtʃ ˈfiːtʃər z jər ˈfeɪvərət/ Which pencil is yours? wich pen-sul iz yore? /hwɪtʃ ˈpensl̩ z ˈjʊrz/ Which of those shirts do you like best? wich uv doth serts doo yoo lyk best? /hwɪtʃ əv ðoʊz ˈʃɝːts du: ju laɪk ˈbest/ Which of your brothers is married? wich uv yore broh-ders iz mer-ried? /hwɪtʃ əv jər ˈbrʌðr̩z ɪz ˈmerid/ Which dress is prettier? The blue one or the yellow one? wich dres iz pret-ee-er? the bloo wun or the yel-oh wun? /hwɪtʃ ˈdres ɪz ˈprɪtiər? ðə ˈblu: wʌn ɔːr ðə ˈjeloʊ wʌn/ How? We use “how” in questions to ask about the way something is done. As an adverb, “how” means “in what way” or “to what extent.”\nHere are the main use cases for “how” in questions:\nAsking about the way to do something: How do you bake a chocolate cake? Asking about the state of something or a particular experience: How was the movie? Asking about a specific measurement: How old is your brother? Making suggestions: How about a movie night? English Sentence Pronunciation IPA Representation How are you? How air yoo? /ˌhaʊ ər ju/ How was the trip? How wuhz thuh trip? /ˌhaʊ wəz ðə ˈtrɪp/ How do you make lasagna? How doo yoo make luh-sahg-nuh? /ˌhaʊ du: ju ˈmeɪk laˈsɑːnjə/ How often do you go to the cinema? How often doo yoo go to thuh sin-uh-muh? /ˌhaʊ ˈɔːfn̩ du: ju ˈɡoʊ tə ðə ˈsɪnəmə/ How far do you live? How far doo yoo live? /ˌhaʊ ˈfɑːr du: ju ˈlaɪv/ How about dinner at the new Italian restaurant? How uh-bout dinner at thuh new ih-tuh-lee-un rest-uh-rant? /ˌhaʊ əˌbaʊt ˈdɪnə ət ðə ˈnju: əˈtæljən ˈrestəˌrɑːnt/ ","permalink":"https://EitanWong.github.io/en/posts/english/lesson8_interrogative_words_in_english/","summary":"English question words: An easy guide to asking good questions Life is full of questions. Who, what, where, when, why, and how - these simple words hold the key to unlocking information and communicating with people in English. We ask questions in a variety of situations, such as when looking for directions, wanting to know more about an event, or trying to find out what happened to a friend. Asking questions is a skill that all of us need to learn. In our native languages, asking questions may seem easy and intuitive. However, in a foreign language, it may seem way more complicated. So, how do you ask questions in English? The answer is: with the help of interrogative words (also known as question words). To help you learn how to ask grammatically correct, relevant questions for every situation in","title":"Lesson8: Interrogative words in English"},{"content":"In English, when the predicate is not a verb, the verb \u0026rsquo;to be\u0026rsquo;, commonly called the substantive verb,is used to connect the predicate with its subject.\nThis verb has no equivalent in Maori, but the relation of subject to predicate is indicated by the use of certain particles and by the relative position of the different words in the sentence.\nSome substantive verbs Example: come read go watch play and so on When using substantive verbs, you need to pay attention to the verb tense\npresent tense\nHe comes from Shenyang.\npresent continuous tense\nShe is reading story books.\nsimple past tense\nThey went to America yesterday.\npresent perfect tense\nWe have watched the game for three times.\nfuture tense\nMy mother will fly back to china next month.\nThe negative form of the substantive verb When we use the negative form of a substantive verb, we usually use an auxiliary verb\ndon't doesn't didn't\nExample present tense I don't go to school by bus.\nthird person singular She doesn't watch TV everyday.\nsimple past tense They didn't swim last night.\nHow to use auxiliary verbs to ask questions The auxiliary verb should be placed at the beginning of the sentence,\nIf the tense of the sentence changes, the verb should be in its base form.\nExample Declarative: He often plays golf.\nQuestion: Does he often play golf?\nAnswer: Yes, he does. / No, he doesn't.\nDeclarative: They go to school by bus.\nQuestion: Do they go to school by bus?\nAnswer: Yes, they do. / No, they don't.\nDeclarative: Sam had breakfast yesterday.\nQuestion: Did Sam have breakfast yesterday?\nAnswer Yes, he did. / No, he didn't.\nThe summary Substantive verb meanings change in tense and number.\nExample He came to Shanghai yesterday.\nWe are writing homework.\nThey have read this book three times.\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson7_substantive_verb/","summary":"In English, when the predicate is not a verb, the verb \u0026rsquo;to be\u0026rsquo;, commonly called the substantive verb,is used to connect the predicate with its subject. This verb has no equivalent in Maori, but the relation of subject to predicate is indicated by the use of certain particles and by the relative position of the different words in the sentence. Some substantive verbs Example: come read go watch play and so on When using substantive verbs, you need to pay attention to the verb tense present tense He comes from Shenyang. present continuous tense She is reading story books. simple past tense They went to America yesterday. present perfect tense We have watched the game for three times. future tense My mother will fly back to china next month. The negative form of the substantive verb When we use the","title":"Lesson7: Substantive verb"},{"content":"Reflexive pronouns are pronouns that reflect back to the subject, but how do they work, and what are some examples? Below, we explain what reflexive pronouns are and how to use them correctly.\nWhat are reflexive pronouns? Reflexive pronouns are words ending in -self or -selves that are used when the subject and the object of a sentence are the same (e.g., I believe in myself).\nThey can act as either objects or indirect objects.\nThe nine English reflexive pronouns are myself, yourself, himself, herself, oneself, itself, ourselves, yourselves, and themselves.\nGrammatical terms might seem complicated and a bit arbitrary when you first hear them, but they really aren’t, once you get to know them.\nThe term reflexive is a good example.\nThrough Latin, reflexive is related to reflect;\nthis is useful to remember because a reflexive pronoun reflects upon a sentence’s subject.\nReflexive pronouns are direct or indirect objects A reflexive pronoun can be a direct object in a sentence when the subject and the direct object are one and the same.\nExample\nJack decided to reward Mary with a dinner out.\nJack decided to reward himself with a dinner out.\nIn the first sentence, Mary is the object of reward.\nJack, the subject, is the object of reward in the second sentence, so we use the pronoun himself.\nReflexive pronouns can also play the indirect object role in a sentence.\nExample\nHe knitted himself a new sweater.\nCynthia pours herself a cup of tea every morning.\nIt is worth noting that referring twice to the same noun as subject and object (rather than using a reflexive pronoun for the object) sounds just a bit creepy.\n“Jack decided to cook Jack a special supper,” for example, sounds unnerving to a primary English speaker.\nReflexive pronouns as intensive pronouns Intensive pronouns are reflexive pronouns that are used to emphasize the subject or antecedent in a sentence, often in the sense of “and not someone else.” You can tell when a word ending in -self or -selves is being used as an intensive pronoun because the sentence it is part of will not change in meaning significantly if you remove it.\nExample Jack made his supper himself. (No one else did it for him.)\nI closed the store on Saturday myself. (I didn’t have an employee to do it.)\nWe ourselves were forced to pilot the boat to safety. (Perhaps the captain was indisposed.)\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson6_the_reflexive_pronouns/","summary":"Reflexive pronouns are pronouns that reflect back to the subject, but how do they work, and what are some examples? Below, we explain what reflexive pronouns are and how to use them correctly. What are reflexive pronouns? Reflexive pronouns are words ending in -self or -selves that are used when the subject and the object of a sentence are the same (e.g., I believe in myself). They can act as either objects or indirect objects. The nine English reflexive pronouns are myself, yourself, himself, herself, oneself, itself, ourselves, yourselves, and themselves. Grammatical terms might seem complicated and a bit arbitrary when you first hear them, but they really aren’t, once you get to know them. The term reflexive is a good example. Through Latin, reflexive is related to reflect; this is useful to remember","title":"Lesson6: The Reflexive Pronouns"},{"content":"As their names imply, both possessive adjectives and possessive pronouns show ownership.\nThe independent possessive pronouns are mine, ours, yours, his, hers, its, and theirs.\nThe possessive adjectives, also called possessive determiners, are my, our, your, his, her, its, and their.\nWe break down each type and offer examples of their usage below.\nIndependent possessive pronouns Possessive pronouns are a type of possessive noun.\nAlso called absolute possessive pronouns, possessive pronouns simplify constructions that show possession of a noun by replacing it—in other words, independent possessive pronouns must stand alone and be used without a noun. To understand how possessive pronouns can make things simpler and clearer, first take a look at this example of a sentence that does not use a possessive pronoun:\nRaúl’s peace lilies were healthier than my peace lilies.\nIt sounds repetitive and feels a little unnecessary to state “peace lilies” twice in this sentence.\nRewriting with a possessive pronoun simplifies things:\nRaúl’s peace lilies were healthier than mine.\nPossessive pronoun examples My phone is dead. Pass me *yours*.\nDid you know that Labrador is *mine*?\nThe house on the corner is *theirs*.\nAs you can see, it is common to see independent possessive pronouns at the ends of clauses or phrases.\nPossessive adjectives Possessive adjectives also clarify who or what owns something.\nUnlike possessive pronouns—which replace nouns—possessive adjectives go before nouns to modify them.\nLike independent possessive pronouns, possessive adjectives can help streamline sentences.\nTo see what we mean, take a look at a sentence that does not have any possessive adjectives—and sounds a little clunky as a result:\nJane takes pride in Jane’s outfits.\nIt sounds odd to use Jane’s name twice in this sentence. A possessive adjective modifying the noun outfits solves the problem:\nJane takes pride in her outfits.\nThus, possessive adjectives are quite handy and are used frequently in the English language.\nPossessive adjective examples *My* plane is delayed.\n*Your* dinner is ready.\nCould you bring *his* tea out to him?\nRemember not to judge a book by *its* cover.\nI would have knocked on *their* door, but I heard *their* baby crying.\nA common mistake: its vs. it’s A common mistake is putting an apostrophe in the possessive adjective its.\nIt is easy to confuse its with the contraction of it is, it’s, which does have an apostrophe.\nRemember, though, possessive adjectives never use apostrophes.\n❌Incorrect: The boat lost it’s mast in the storm.\n✅Correct: The boat lost its mast in the storm.\n❌Incorrect: Don’t judge a book by it’s cover.\n✅Correct: Don’t judge a book by its cover.\n","permalink":"https://EitanWong.github.io/en/posts/english/lesson5_possessive_pronouns_and_possessive_adjectives/","summary":"As their names imply, both possessive adjectives and possessive pronouns show ownership. The independent possessive pronouns are mine, ours, yours, his, hers, its, and theirs. The possessive adjectives, also called possessive determiners, are my, our, your, his, her, its, and their. We break down each type and offer examples of their usage below. Independent possessive pronouns Possessive pronouns are a type of possessive noun. Also called absolute possessive pronouns, possessive pronouns simplify constructions that show possession of a noun by replacing it—in other words, independent possessive pronouns must stand alone and be used without a noun. To understand how possessive pronouns can make things simpler and clearer, first take a look at this example of a sentence that does not use a possessive pronoun: Raúl’s peace lilies were healthier than my","title":"Lesson5: Possessive Pronouns and Possessive Adjectives"},{"content":"We use pronouns every day. in fact, even if you don\u0026rsquo;t know what pronouns are, you use them and in this sentence alone, we\u0026rsquo;ve now used pronouns four times.\nPronouns are words (or phrases) you substitute for nouns when your reader or listener already knows which noun you\u0026rsquo;re referring to.\nFor example, you might say, \u0026ldquo;i have a dog.She\u0026rsquo;s brown and white.\u0026rdquo; There\u0026rsquo;s no need to clarify that you\u0026rsquo;re describing your dog in the second sentence because you already mentioned her in the first.\nBy using the pronoun she, you can avoid the annoying repetition of the dog.\nPronouns do a whole lot more than helping us avoid repetitiveness. They provide context, make your sentences\u0026rsquo; meanings clearer, and shape how we perceive people and things.\nRead on to learn about the different ways we use pronouns and how to use them to construct sentences.\nWhat is a pronoun? In English grammar, pronouns are a type of generic noun that can represent any other noun. Their job is to make communication faster and more efficient because you don\u0026rsquo;t have to repeat the same word over and over again. Some pronoun examples include:\ni me us you themselves who that The Nominative case The nominative case refers to the pronoun as the subject of the sentence\nHere are some nominative pronouns\ni he she it you we they Examples I am a teacher. He is a teacher. You are teachers. The Accusative case The accusative case refers to the pronoun as the object of the sentence\nHere are some accusative pronouns\nme him her it you us them Examples He likes me. We like her. I like them. ","permalink":"https://EitanWong.github.io/en/posts/english/lesson4_nominative_and_accusative_forms_of_pronouns/","summary":"We use pronouns every day. in fact, even if you don\u0026rsquo;t know what pronouns are, you use them and in this sentence alone, we\u0026rsquo;ve now used pronouns four times. Pronouns are words (or phrases) you substitute for nouns when your reader or listener already knows which noun you\u0026rsquo;re referring to. For example, you might say, \u0026ldquo;i have a dog.She\u0026rsquo;s brown and white.\u0026rdquo; There\u0026rsquo;s no need to clarify that you\u0026rsquo;re describing your dog in the second sentence because you already mentioned her in the first. By using the pronoun she, you can avoid the annoying repetition of the dog. Pronouns do a whole lot more than helping us avoid repetitiveness. They provide context, make your sentences\u0026rsquo; meanings clearer, and shape how we perceive people and things. Read on to learn about the different ways we use pronouns and how to use","title":"Lesson4: Nominative and accusative forms of pronouns"},{"content":"The negative form of the verb \u0026rsquo;to be\u0026rsquo; is \u0026ldquo;is not\u0026rdquo; \u0026ldquo;are not\u0026rdquo;.\nTo form a sentence, it needs to add \u0026ldquo;not\u0026rdquo; after the verb.\nFor example: I am not a teacher.\nThe nagative form of the verb \u0026ldquo;to be\u0026rdquo; verb \u0026ldquo;to be\u0026rdquo; The negative form am am not is isn\u0026rsquo;s are aren\u0026rsquo;t was wasn\u0026rsquo;t were weren\u0026rsquo;t Example Simple Present tense form The man isn't back.\nI am not back.\nThey aren't back.\nSimple Past tense form He wasn't back.\nThey weren't back.\nThe Question and Answer of Sentence Example 1\nQ: Is he a teacher?\nA: Yes, he is. / No, he isn't.\nExample 2\nQ: Are you a teacher?\nA: Yes, i am. / No, i am not.\nExample 3\nQ: Were they teachers?\nA: Yes, they were. / No, they weren't.\nMore Examples Question: Is he a doctor?\nAnswer: No, he isn't.\nQuestion: Were they in the classroom yesterday?\nAnswer: Yes, they were. \\ No, they weren't.\nThe negative form of the verb \u0026rsquo;to be\u0026rsquo; in the sentence\nThey weren't in the classroom yesterday. ","permalink":"https://EitanWong.github.io/en/posts/english/lesson3_the_negative_form_of_the_verb_to_be/","summary":"The negative form of the verb \u0026rsquo;to be\u0026rsquo; is \u0026ldquo;is not\u0026rdquo; \u0026ldquo;are not\u0026rdquo;. To form a sentence, it needs to add \u0026ldquo;not\u0026rdquo; after the verb. For example: I am not a teacher. The nagative form of the verb \u0026ldquo;to be\u0026rdquo; verb \u0026ldquo;to be\u0026rdquo; The negative form am am not is isn\u0026rsquo;s are aren\u0026rsquo;t was wasn\u0026rsquo;t were weren\u0026rsquo;t Example Simple Present tense form The man isn't back. I am not back. They aren't back. Simple Past tense form He wasn't back. They weren't back. The Question and Answer of Sentence Example 1 Q: Is he a teacher? A: Yes, he is. / No, he isn't. Example 2 Q: Are you a teacher? A: Yes, i am. / No, i am not. Example 3 Q: Were they teachers? A: Yes, they were. / No, they weren't. More Examples Question: Is he a","title":"Lesson3: The negative form of the verb 'to be'"},{"content":"The verb \u0026rsquo;to be\u0026rsquo; indicates a state of being or existence.\n\u0026lsquo;To be\u0026rsquo; is an irregular verb.\nThere are eight forms of the verb to be: 1. Present: am、is、are Example:\nI am a student.\nShe is a teacher.\nThey are the audience.\nThey are teachers.\n2. Simple past: was、were Example\nHe was back.\nThey were back.\nHe was a teacher before\n3. Infinitive: be infinitive is a verbal consisting of the word to plus a verb (in its simplest \u0026ldquo;stem\u0026rdquo; form) and functioning as a noun, adjective, or adverb. The term verbal indicates that an infinitive, like the other two kinds of verbals, is based on a verb and therefore expresses action or state of being.\nExample\nWe need to win.\n4. Present participle: being Example\nI'm always being criticized.\nYou're being stupid.\n5. Past participle: been Example\nHe has been a teacher for 3 years.\nUsage of the verb be Followed by nouns, adjectives, adverbs of location or phrases as complements.\nThe man is a teacher. Mary's new dresses are colorful. My mother was in the kitchen. ","permalink":"https://EitanWong.github.io/en/posts/english/lesson2_the_verb_to_be/","summary":"The verb \u0026rsquo;to be\u0026rsquo; indicates a state of being or existence. \u0026lsquo;To be\u0026rsquo; is an irregular verb. There are eight forms of the verb to be: 1. Present: am、is、are Example: I am a student. She is a teacher. They are the audience. They are teachers. 2. Simple past: was、were Example He was back. They were back. He was a teacher before 3. Infinitive: be infinitive is a verbal consisting of the word to plus a verb (in its simplest \u0026ldquo;stem\u0026rdquo; form) and functioning as a noun, adjective, or adverb. The term verbal indicates that an infinitive, like the other two kinds of verbals, is based on a verb and therefore expresses action or state of being. Example We need to win. 4. Present participle: being","title":"Lesson2: The Verb 'To Be'"},{"content":"English is an international language, and being proficient in it allows individuals to communicate effectively with English speakers worldwide.\nIn English, there are five basic sentence patterns.\nPatterns 1: Subject + Verb Example:\nSentence: The universe remains.\nNote:\n\u0026lsquo;The universe\u0026rsquo; is the subject of the action of this sentence, certainly, it\u0026rsquo;s the subject of this sentence \u0026lsquo;Remains\u0026rsquo; is the action of this sentence, so it\u0026rsquo;s the verb of this sentence Patterns 2: Subject + Linking Verb + Predicative Example:\nSentence: The food is delicious.\nNote:\nWhat is a sentence subject? sentence subject is the subject of the action in the sentence. In English, use a Linking verb to link the subject and Predicative, so is is a Linking Verb. Predicative is relating to or occurring within the predicate of a sentence. Predicate is the part of a sentence that gives information about the subject. In this sentence case, food is the subject of this sentence, and is is a Linking Verb, delicious is a Predicative of this sentence. Patterns 3: Subject + Verb + Object Example:\nSentence: He took his bag and left.\nNote:\nIn this sentence case, He is the subject of this sentence. took and left is the action of this sentence, so they are Verbs. his bag is the object of this sentence, so it\u0026rsquo;s Object. Patterns 4: Subject + Verb + Indirect object + Direct object Example:\nSentence: Her father bought her a dictionary.\nNote:\nHer father is the subject of this sentence. Bought is the verb of this sentence. her is people, so it\u0026rsquo;s the Indirect object of this sentence. dictionary is a thing, so it\u0026rsquo;s the Direct object of this sentence. Patterns 5: Subject + Verb + Object + Complement Example:\nSentence: We made him our monitor\nNote:\nWe is the subject of this sentence. Made is the verb of this sentence. him is the object of this sentence. Our monitor is a Complement of the object of this sentence, so it\u0026rsquo;s the Complement of this sentence. ","permalink":"https://EitanWong.github.io/en/posts/english/lesson1_the_basic_sentence_patterns/","summary":"English is an international language, and being proficient in it allows individuals to communicate effectively with English speakers worldwide. In English, there are five basic sentence patterns. Patterns 1: Subject + Verb Example: Sentence: The universe remains. Note: \u0026lsquo;The universe\u0026rsquo; is the subject of the action of this sentence, certainly, it\u0026rsquo;s the subject of this sentence \u0026lsquo;Remains\u0026rsquo; is the action of this sentence, so it\u0026rsquo;s the verb of this sentence Patterns 2: Subject + Linking Verb + Predicative Example: Sentence: The food is delicious. Note: What is a sentence subject? sentence subject is the subject of the action in the sentence. In English, use a Linking verb to link the subject and Predicative, so is is a Linking Verb. Predicative is relating to or occurring within the predicate of a sentence. Predicate is the part of a sentence that gives","title":"Lesson1: The basic sentence patterns"},{"content":" 1.算法的复杂度 算法在编写成可执行程序后,运行需要耗费时间和空间资源 因此衡量一个算法的好坏,一般是从时间和空间两个维度来衡量的 即算法的时间复杂度和空间复杂度\n时间复杂度主要衡量一个算法的快慢,而空间复杂度主要衡量一个算法运行所需的额外空间\n在计算机发展的早期,计算机的存储容量很小,所以对空间的复杂度是很在乎,但是经过计算机行业的迅速发展,\n计算机的存储容量已过达到了很高的程度,所以我们如今已经不再特别需要关注一个算法的空间复杂度了\n2 大 O 的渐进表示法 大 O 符号（Big O notation）是用于描述函数渐进行为的数学符号 推导大 O 阶的方法\n1.用常数 1 取代运行时间中的所以加法常数\n2.在修改后的运行次数函数中，只保留最高阶的项\n3.如果最高阶的项存在且不是 1，则除去与这个项目相乘的常数，得到的结果就是大 O 阶\n3.时间复杂度概念 时间复杂度的定义: 在计算机科学当中,算法的时间复杂度,是一个函数,\n它是定量描述了该算法的运行时间.一个算法执行所耗费的时间\n从理论上来说,是不能算出来的,只有你把你的程序放在机器上跑起来,才能知道, 但是我们并不需要这么做\n所以我们就有了时间复杂度的分析方式:\n一个算法所花费的时间与其中语句执行的次数成正比,算法中的基本操作的次数,为算法的时间复杂度\n即找到某条语句与问题规模 N 之间的数学表达式，就是算出了该算法的复杂度\n所以计算算法的时间复杂度,就是计算算法中的基本操作的执行次数\n3.1 时间复杂度分析案例 例题 1: 求得 Func1 的事件复杂度，F(n)=N*N+2*N+10\n随着 N 的增大，常数 10 对 F(n)的影响较小\n所以这道题的时间复杂度为 O(N^2)\n例题 2: F(n)=2N+10\n随着 N 的增大，常数 10 对 F(n)的影响较小\n当 N 无限大的时候 N 和 2N 是同一个级别\n最高阶为 2，则除去与这个项目相乘的常数 2\n所以时间复杂度为 O(N)\n例题 3: 这道题 M 和 N 都是 O(n)级别的\n一般情况下，时间复杂度计算时未知数用的都是 N，但是也可以是其他字符\n如果没有给定条件，那么这道题的复杂度是 O(M+N)\n如果给定条件 M 远大于 N，则为 O(M)\n如果 N 远大于 M，则为 O(N)\n如果差不多大，可以为 O(M) 也可以为 O(N)\n例题 4: 可以看出 ++count 执行了 100 次，也就是常数次\n所以时间复杂度为 O(n)\n例题 5: 冒泡排序的时间复杂度的分析，根据其思想，每次内部循环完成，都会把排好的数字放到最后\n所以循环完毕后，可以看出，冒泡排序执行的数是一个等差数列求和即((N-1)+1)=*(N-1)/2=N*(N-1)/2\n所以时间复杂度为 O(N^2)\n例题 6: 二分查找，每次都会从当前数组的一半开始找，相当于每次都除以 2\n最好的情况是 O(1)\n最坏的情况也就是找不到或者最边上，也就是 2^x=N,即求 N 的对数\n对于一个算法，我们基本上看他的最坏情况\n所以二分查找的时间复杂度为 O(log2n)\n例题 7: 斐波那契数列递归写法,是一个运行效率特别慢的写法\n以 Fib(8) 为例 第一层节点个数为 2^0,第二层为 2^1,第三次 2^2 以此类推直到 2^(n-1),项数为 n，还有一侧节点是不满的，不满的节点数记录为 x\n所以求斐波那契数列的操作数，F(n)=2^n-1+x\n所以时间复杂度为 O(2^n)\n4.算法的空间复杂度 空间复杂度是一个数学表达式,是对一个算法在运行过程中临时占用的存储空间大小的度量\n空间复杂度不是程序占用了多少字节的空间,因为这个没大意义,所以空间复杂度算得是变量的个数\n空间复杂度计算规则基本跟时间复杂度类似,也使用大 O 渐进表示法\n函数运行所需的栈空间(存储参数,局部变量,寄存器信息)在编译期间已经确定好了,\n因此空间复杂度主要通过函数在运行时显示申请的额外空间来确定\n4.1 算法的时间复杂度分析案例 例题 1: 根据冒泡排序的思想, 总共有两个变量在循环当中\n循环内部变量 j 每次循环完后会释放,然后再次创建\n所以,总共就 2 个变量,空间复杂度为 O(1)\n例题 2: 由于是计算斐波那契数列前 N 项的数组\n所以每次,都会在数组后面增加一个元素,占用一个空间\n所以空间复杂度就是 O(N)\n例题 3: 递归过程中,每个栈帧的创建都会消耗一定的空间\n所以计算阶乘的空间复杂度,就是计算递归深度\n所以空间复杂度为 O(N)\n例题 4: 在计算斐波那契数列递归的空间复杂度,的时候\n要注意,空间是可以重复利用,不累计的,时间是一去不复返,累计的\n所以空间复杂度,不是 O(2^n), 因为每次递归完最深处后,内存空间会被回收\n所以,其空间复杂度就是递归的深度 O(N)\n","permalink":"https://EitanWong.github.io/en/posts/coding/%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","summary":"1.算法的复杂度 算法在编写成可执行程序后,运行需要耗费时间和空间资源 因此衡量一个算法的好坏,一般是从时间和空间两个维度来衡量的 即算法的时间复杂度和空间复杂度 时间复杂度主要衡量一个算法的快慢,而空间复杂度主要衡量一个算法运行所需的额外空间 在计算机发展的早期,计算机的存储容量很小,所","title":"算法的复杂度分析"},{"content":"我们之前编写的基于Lambert、Phong、BlinnPhong光照模型的Shader\n存在一个问题🙋\n那就是: ** 不能接受阴影**\n左图: 自己编写的Shader\n右图: 官方内建的Shader\n所以为了解决这个问题，我们要在自己的着色器当中实现ShadowCaster\n关于不同渲染路径下的Shadow Unity支持多种类型的渲染路径，在5.0版本之前，主要有3中渲染路径\n分别为正向渲染，延迟渲染以及顶点照明渲染\n在5.0之后，Unity抛弃了顶点照明渲染路径，并用新的延迟渲染路径来替代了旧的延迟渲染路径\nUnity中的正向渲染 Unity中的正向渲染有3中处理光照的方式\n分别为逐顶点处理，逐像素处理以及球谐函数处理\n而决定哪一个光源按照使用那种处理模式取决于光源的类型和渲染模式\n光源的类型指的是该光源是平行光或者其他类型的光\n渲染模式则指的是该光源是否被指定为重要光源\n在正向渲染中一共包含两种Pass，Base Pass和Additional Pass\nBase Pass只会被执行一次，用于计算光照纹理，环境光，自发光，阴影等效果\n而Additional Pass则能够被执行多次，并且默认情况下不支持阴影，但是能够通过使用宏指令来开启阴影\nAdditional Pass会根据影响物体的其他逐像素光源数目被多次调用\nUnity中的顶点照明渲染 顶点照明渲染是对硬件配置要求最少，运算性能最高，\n同时效果也是最差的一种渲染路径。它可以被视为正向渲染的一个子集，\n因为它只能通过逐顶点的方式去计算光照，这也就意味着我们无法使用一些逐像素光照变量。\n顶点照明渲染在5.0以后的版本中作为一种被遗留的渲染路径存在，将来也有被移除的可能。\nUnity中的延迟渲染 Unity中的新旧延迟渲染系统的差别非常小，只是是用来不同的技术来权衡不同的需求。 \u0026ndash; 其中包含两个Pass，第一个Pass用于渲染G缓冲，在这个Pass中会把物体的漫反射颜色，高光反射颜色，平滑度，法线，自发光和深度等信息渲染到屏幕空间的G缓冲中，对于每个物体来说这个Pass只会被执行一次。\n第二个Pass用于计算真正的光照模型，这个Pass会使用上一个Pass中渲染的数据来计算最终光照的颜色，再存储到帧缓冲中。 这里要注意的是,如果被接受物体的Shader是Legacy的Diffuse那么在Forward中，是只能接受到Directional Light的阴影的,如果要让其支持其他类型光源的阴影，需要修改渲染路径为延迟渲染\n还需要注意是渲染路径为顶点照明Legacy Vertex Lit的情况下，片元着色器是无法正常工作的\n在新的Pass通道中渲染Shadow 通过Unity的官方文档,可以知道 在新的Pass通道中使用内置渲染管线中的预定义通道标记Tags，为LightMode 增加ShadowCaster\n使对象深度渲染到阴影贴图或深度纹理中.\nPass{ Tags{\u0026#34;LightMode\u0026#34;=\u0026#34;ShadowCaster\u0026#34;} } 使用FallBack渲染Shadow 可以通过FallBack，当Unity物体需要投射阴影但是没有相关的Pass，就会回落到FallbBack当中\nFallback \u0026#34;Diffuse\u0026#34; 手动实现ShadowCaster 以上方式实现的Shadow存在一个问题，那就是着色器本身的对象，不能接受阴影\n如下图所示，左侧的着色器之间并没有投射阴影\nUnity的文档当中对一块内容并没有很清晰的描述\n通过翻阅AutoLight.cginc可以看到，其中对于阴影投射部分做了很多的宏定义\n以旧版本4.x为例，光照以及阴影的宏定义如下\n// ----------------------------- // Light/Shadow helpers (4.x version) // ----------------------------- // This version computes light coordinates in the vertex shader and passes them to the fragment shader. // ---- Spot light shadows #if defined (SHADOWS_DEPTH) \u0026amp;\u0026amp; defined (SPOT) #define SHADOW_COORDS(idx1) unityShadowCoord4 _ShadowCoord : TEXCOORD##idx1; #define TRANSFER_SHADOW(a) a._ShadowCoord = mul (unity_WorldToShadow[0], mul(unity_ObjectToWorld,v.vertex)); #define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord) #endif // ---- Point light shadows #if defined (SHADOWS_CUBE) #define SHADOW_COORDS(idx1) unityShadowCoord3 _ShadowCoord : TEXCOORD##idx1; #define TRANSFER_SHADOW(a) a._ShadowCoord.xyz = mul(unity_ObjectToWorld, v.vertex).xyz - _LightPositionRange.xyz; #define SHADOW_ATTENUATION(a) UnitySampleShadowmap(a._ShadowCoord) #define READ_SHADOW_COORDS(a) unityShadowCoord4(a._ShadowCoord.xyz, 1.0) #endif // ---- Shadows off #if !defined (SHADOWS_SCREEN) \u0026amp;\u0026amp; !defined (SHADOWS_DEPTH) \u0026amp;\u0026amp; !defined (SHADOWS_CUBE) #define SHADOW_COORDS(idx1) #define TRANSFER_SHADOW(a) #define SHADOW_ATTENUATION(a) 1.0 #define READ_SHADOW_COORDS(a) 0 #else #ifndef READ_SHADOW_COORDS #define READ_SHADOW_COORDS(a) a._ShadowCoord #endif #endif #ifdef POINT # define DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 _LightCoord : TEXCOORD##idx; # define COMPUTE_LIGHT_COORDS(a) a._LightCoord = mul(unity_WorldToLight, mul(unity_ObjectToWorld, v.vertex)).xyz; # define LIGHT_ATTENUATION(a) (tex2D(_LightTexture0, dot(a._LightCoord,a._LightCoord).rr).r * SHADOW_ATTENUATION(a)) #endif #ifdef SPOT # define DECLARE_LIGHT_COORDS(idx) unityShadowCoord4 _LightCoord : TEXCOORD##idx; # define COMPUTE_LIGHT_COORDS(a) a._LightCoord = mul(unity_WorldToLight, mul(unity_ObjectToWorld, v.vertex)); # define LIGHT_ATTENUATION(a) ( (a._LightCoord.z \u0026gt; 0) * UnitySpotCookie(a._LightCoord) * UnitySpotAttenuate(a._LightCoord.xyz) * SHADOW_ATTENUATION(a) ) #endif #ifdef DIRECTIONAL # define DECLARE_LIGHT_COORDS(idx) # define COMPUTE_LIGHT_COORDS(a) # define LIGHT_ATTENUATION(a) SHADOW_ATTENUATION(a) #endif #ifdef POINT_COOKIE # define DECLARE_LIGHT_COORDS(idx) unityShadowCoord3 _LightCoord : TEXCOORD##idx; # define COMPUTE_LIGHT_COORDS(a) a._LightCoord = mul(unity_WorldToLight, mul(unity_ObjectToWorld, v.vertex)).xyz; # define LIGHT_ATTENUATION(a) (tex2D(_LightTextureB0, dot(a._LightCoord,a._LightCoord).rr).r * texCUBE(_LightTexture0, a._LightCoord).w * SHADOW_ATTENUATION(a)) #endif #ifdef DIRECTIONAL_COOKIE # define DECLARE_LIGHT_COORDS(idx) unityShadowCoord2 _LightCoord : TEXCOORD##idx; # define COMPUTE_LIGHT_COORDS(a) a._LightCoord = mul(unity_WorldToLight, mul(unity_ObjectToWorld, v.vertex)).xy; # define LIGHT_ATTENUATION(a) (tex2D(_LightTexture0, a._LightCoord).w * SHADOW_ATTENUATION(a)) #endif #define UNITY_LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) UNITY_SHADOW_COORDS(idx2) #define LIGHTING_COORDS(idx1, idx2) DECLARE_LIGHT_COORDS(idx1) SHADOW_COORDS(idx2) #define UNITY_TRANSFER_LIGHTING(a, coord) COMPUTE_LIGHT_COORDS(a) UNITY_TRANSFER_SHADOW(a, coord) #define TRANSFER_VERTEX_TO_FRAGMENT(a) COMPUTE_LIGHT_COORDS(a) TRANSFER_SHADOW(a) #endif UNITY_LIGHTING_COORDS\t为宏定义的阴影纹理\nTRANSFER_VERTEX_TO_FRAGMENT\t将阴影的纹理从顶点传到片元程序\nLIGHT_ATTENUATION\t光衰减，其中包含了阴影衰减部分，与最终返回的颜色rgb值相乘可以得到正确的阴影投射部分的颜色\n完整代码⬇️\nShader \u0026#34;ShaderLearning/ShadowCaster/VertexShadowBlinnPhongShader\u0026#34; { Properties { _MainColor (\u0026#34;MainColor\u0026#34;, Color) = (1,1,1,1) _SpecularColor (\u0026#34;SpecularColor\u0026#34;, Color) = (0.5,0.5,0.5,1) _Shineness(\u0026#34;Shineness\u0026#34;,Range(1,32))=8 } SubShader { Pass { Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34; } CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; #include \u0026#34;AutoLight.cginc\u0026#34; struct v2f { float4 pos : SV_POSITION; float3 normal : TEXCOORD0; float4 vertex: POSITION1; LIGHTING_COORDS(1,2) }; fixed4 _MainColor; fixed4 _SpecularColor; float _Shineness; v2f vert (appdata_base v) { v2f o; o.pos=UnityObjectToClipPos(v.vertex); o.normal=v.normal; o.vertex=v.vertex; TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } fixed4 frag (v2f i) : COLOR { //环境光颜色 fixed4 col=UNITY_LIGHTMODEL_AMBIENT; //模型坐标系下的法线转位世界坐标系下 float3 N=UnityObjectToWorldNormal(i.normal); //获取世界坐标系下的光照方向 float3 L=normalize(WorldSpaceLightDir(i.vertex)); //计算漫反射 float diffuse=saturate(dot(L,N)); //计算摄像机观察视角向量 float3 V=normalize(WorldSpaceViewDir(i.vertex)); //计算镜面高光,使用半角向量 float specular=pow(saturate(dot(N,normalize(L+V))),_Shineness); //叠加上漫反射与镜面高光的颜色乘上光照颜色 col+= _LightColor0*((_MainColor*diffuse)+(_SpecularColor*specular)); //计算世界坐标系下的顶点位置 float3 wpos=mul(unity_ObjectToWorld,i.vertex).xyz; //计算4个点光源颜色 col.rgb+=Shade4PointLights(unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0, unity_LightColor[0].rgb,unity_LightColor[1].rgb, unity_LightColor[2].rgb,unity_LightColor[3].rgb, unity_4LightAtten0,wpos,N); float atten = LIGHT_ATTENUATION(i); col.rgb*=atten; return col; } ENDCG } } Fallback \u0026#34;Diffuse\u0026#34; } 通过使用AutoLight.cginc当中的宏，实现了阴影的投射\n但是对于点光源的阴影，并没有得到正确的结果\n实现Forward Add 通道中点光源阴影的支持 在标准的Forward前向渲染当中，unity中分为两种不同的光照模式通道\nForwardBase\n主要应用于环境光，平行光，它使用标准照明函数计算一个，并通过将它们近似为球谐函数来计算额外的定向光\nForwardAdd\n主要应用附加的像素灯，以及聚光灯，每个灯一个通道\n注意ForwardBase和ForwardAdd之前采用Blend混合片段输出的颜色\n混合方程为：\nfinalValue = sourceFactor * sourceValue operation destinationFactor * destinationValue 在这个等式中：\nfinalValue是 GPU 写入目标缓冲区的值。 sourceFactor在 Blend 命令中定义。 sourceValue是片段着色器输出的值。 operation是混合操作。 destinationFactor在 Blend 命令中定义。 destinationValue是目标缓冲区中已有的值。 所以在ForwardAdd Pass当中片段输出的一句放在了目标缓冲区中，在ForwardAdd Pass中使用Blend命令混合两者的结果\n用法 示例语法 功能 Blend \u0026lt;state\u0026gt; Blend Off 禁用默认渲染目标的混合。这是默认值。 Blend \u0026lt;render target\u0026gt; \u0026lt;state\u0026gt; Blend 1 Off 如上所述，但对于给定的渲染目标。(1) Blend \u0026lt;source factor\u0026gt; \u0026lt;destination factor\u0026gt; Blend One Zero 为默认渲染目标启用混合。设置 RGBA 值的混合因子。 Blend \u0026lt;render target\u0026gt; \u0026lt;source factor\u0026gt; \u0026lt;destination factor\u0026gt; Blend 1 One Zero 如上所述，但对于给定的渲染目标。(1) Blend \u0026lt;source factor RGB\u0026gt; \u0026lt;destination factor RGB\u0026gt;, \u0026lt;source factor alpha\u0026gt; \u0026lt;destination factor alpha\u0026gt; Blend One Zero, Zero One 启用混合默认渲染目标。为 RGB 和 alpha 值设置单独的混合因子。(2) Blend \u0026lt;render target\u0026gt; \u0026lt;source factor RGB\u0026gt; \u0026lt;destination factor RGB\u0026gt;, \u0026lt;source factor alpha\u0026gt; \u0026lt;destination factor alpha\u0026gt; Blend 1 One Zero, Zero One 如上所述，但对于给定的渲染目标。(1) (2) 有效参数值 范围 价值 功能 渲染目标 整数，范围为 0 到 7 渲染目标索引。 状态 Off 禁用混合。 因素 One 此输入的值为一。使用它来使用源颜色或目标颜色的值。 Zero 此输入的值为零。使用它来删除源或目标值。 SrcColor GPU 将此输入的值乘以源颜色值。 SrcAlpha GPU 将此输入的值乘以源 alpha 值。 SrcAlphaSaturate source alphaGPU 将此输入的值乘以和的最小值(1 - destination alpha) DstColor GPU 将此输入的值乘以帧缓冲区源颜色值。 DstAlpha GPU 将此输入的值乘以帧缓冲区源 alpha 值。 OneMinusSrcColor GPU 将此输入的值乘以（1 - 源颜色）。 OneMinusSrcAlpha GPU 将此输入的值乘以（1 - 源 alpha）。 OneMinusDstColor GPU 将此输入的值乘以（1 - 目标颜色）。 OneMinusDstAlpha GPU 将此输入的值乘以（1 - 目标 alpha）。 着色器变体和关键字 在Unity中可以编写着色器代码片段来共享通用代码，但在启用或禁用给定关键字时具有不同功能。\nUnity 编译这些着色器代码片段时，它将为已启用和已禁用关键字的不同组合创建单独的着色器程序。\n这些各个着色器程序被称为着色器变体。\n简而言之就是可以启用或者关闭给定的关键字，来使用各种着色器变体当中的功能，从而实现着色器的效果\n预编译指令multi_compile 的工作方式 指令示例：\n# pragma multi_compile FANCY_STUFF_OFF FANCY_STUFF_ON 此指令示例生成两个着色器变体：一个定义了 FANCY_STUFF_OFF，另一个定义了 FANCY_STUFF_ON。在运行时，Unity 根据材质或全局着色器关键字来激活其中一个变体。如果这两个关键字均未启用，则 Unity 使用第一个关键字（在此示例中为 FANCY_STUFF_OFF）。\n内置 multi_compile 快捷方式 有几个“快捷方式”符号用于编译多个着色器变体。这些变体主要处理 Unity 中的不同光源、阴影和光照贴图类型。请参阅有关渲染管线的文档以了解详细信息。\nmulti_compile_fwdbase 编译 PassType.ForwardBase 所需的所有变体。这些变体处理不同的光照贴图类型以及启用或禁用的方向光主要阴影。 multi_compile_fwdadd 编译 PassType.ForwardAdd 的变体。这将编译变体来处理方向光、聚光灯或点光源类型，以及它们带有剪影纹理的变体。 multi_compile_fwdadd_fullshadows - 与 multi_compile_fwdadd 相同，但还能够让光源具有实时阴影。 multi_compile_fog 扩展为多个变体以处理不同的雾效类型 (off/linear/exp/exp2)。 所以想要实现能够接受点光源的阴影投射，就需要在ForwardAdd通道中 添加预编译指令multi_compile_fwdadd_fullshadows\n完整的光照以及阴影投影支持的代码如下：\nShader \u0026#34;ShaderLearning/ShadowCaster/VertexShadowBlinnPhongShader\u0026#34; { Properties { _MainColor (\u0026#34;MainColor\u0026#34;, Color) = (1,1,1,1) _SpecularColor (\u0026#34;SpecularColor\u0026#34;, Color) = (0.5,0.5,0.5,1) _Shineness(\u0026#34;Shineness\u0026#34;,Range(1,32))=8 } SubShader { Pass { Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34; } CGPROGRAM #pragma multi_compile_fwdbase #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; #include \u0026#34;AutoLight.cginc\u0026#34; struct v2f { float4 pos : SV_POSITION; float3 normal : TEXCOORD0; float4 vertex: POSITION1; LIGHTING_COORDS(1,2) }; fixed4 _MainColor; fixed4 _SpecularColor; float _Shineness; v2f vert (appdata_base v) { v2f o; o.pos=UnityObjectToClipPos(v.vertex); o.normal=v.normal; o.vertex=v.vertex; TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } fixed4 frag (v2f i) : COLOR { //环境光颜色 fixed4 col=UNITY_LIGHTMODEL_AMBIENT; //模型坐标系下的法线转位世界坐标系下 float3 N=UnityObjectToWorldNormal(i.normal); //获取世界坐标系下的光照方向 float3 L=normalize(WorldSpaceLightDir(i.vertex)); //计算漫反射 float diffuse=saturate(dot(L,N)); //计算摄像机观察视角向量 float3 V=normalize(WorldSpaceViewDir(i.vertex)); //计算镜面高光,使用半角向量 float specular=pow(saturate(dot(N,normalize(L+V))),_Shineness); //叠加上漫反射与镜面高光的颜色乘上光照颜色 col+= _LightColor0*((_MainColor*diffuse)+(_SpecularColor*specular)); //计算世界坐标系下的顶点位置 float3 wpos=mul(unity_ObjectToWorld,i.vertex).xyz; //计算4个点光源颜色 col.rgb+=Shade4PointLights(unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0, unity_LightColor[0].rgb,unity_LightColor[1].rgb, unity_LightColor[2].rgb,unity_LightColor[3].rgb, unity_4LightAtten0,wpos,N); float atten = LIGHT_ATTENUATION(i); col.rgb*=atten; return col; } ENDCG } Pass { Blend One One//使用Blend混合 帧缓冲里的结果 默认方法为Add Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardAdd\u0026#34; }// ForwarAdd 附加支持逐像素光以及聚光灯 CGPROGRAM //使用 #pragma multi_compile_fwdadd_fullshadows #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; #include \u0026#34;AutoLight.cginc\u0026#34; struct v2f { float4 pos : SV_POSITION; float3 normal : TEXCOORD0; float4 vertex: POSITION1; LIGHTING_COORDS(1,2) }; fixed4 _MainColor; fixed4 _SpecularColor; float _Shineness; v2f vert (appdata_base v) { v2f o; o.pos=UnityObjectToClipPos(v.vertex); o.normal=v.normal; o.vertex=v.vertex; TRANSFER_VERTEX_TO_FRAGMENT(o) return o; } fixed4 frag (v2f i) : COLOR { //环境光颜色 //模型坐标系下的法线转位世界坐标系下 float3 N=UnityObjectToWorldNormal(i.normal); //获取世界坐标系下的光照方向 float3 L=normalize(WorldSpaceLightDir(i.vertex)); //计算漫反射 float diffuse=saturate(dot(L,N)); //计算摄像机观察视角向量 float3 V=normalize(WorldSpaceViewDir(i.vertex)); //计算镜面高光,使用半角向量 float specular=pow(saturate(dot(N,normalize(L+V))),_Shineness); //叠加上漫反射与镜面高光的颜色乘上光照颜色 fixed4 col = _LightColor0*((_MainColor*diffuse)+(_SpecularColor*specular)); // //计算世界坐标系下的顶点位置 float3 wpos=mul(unity_ObjectToWorld,i.vertex).xyz; //计算4个点光源颜色 col.rgb+=Shade4PointLights(unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0, unity_LightColor[0].rgb,unity_LightColor[1].rgb, unity_LightColor[2].rgb,unity_LightColor[3].rgb, unity_4LightAtten0,wpos,N); float atten = LIGHT_ATTENUATION(i); col.rgb*=atten; return col; } ENDCG } } Fallback \u0026#34;Diffuse\u0026#34; } ","permalink":"https://EitanWong.github.io/en/posts/shader/shadowcaster-%E6%B8%B2%E6%9F%93%E9%98%B4%E5%BD%B1/","summary":"我们之前编写的基于Lambert、Phong、BlinnPhong光照模型的Shader 存在一个问题🙋 那就是: ** 不能接受阴影** 左图: 自己编写的Shader 右图: 官方内建的Shader 所以为了解决这个问题，我们要在自己的着色器当中实现ShadowCaster 关于不同渲染路径下的S","title":"ShadowCaster-渲染阴影"},{"content":" 之前在编写Phong与BlinnPhong的时候，我将光照计算的部分放在顶点程序vert当中\n顶点程序是针对顶点的，比如一个模型有8个顶点，就会计算8次\n而片段程序当中是针对像素的，有n个像素就会计算n次\n所以在之前编写的着色器当中，由于在顶点当中进行,最后光照的效果，出现了斑块，效果不够平滑\n在以前由于图像处理器性能不强，所以很多的计算放在顶点程序当中进行\n但是随着现代图像处理器的发展，GPU以及帮我们优化好了这一部分的问题\n所以现在很多光照的计算部分可以放在片元程序当中进行了\n下面就是改写为片元程序实现的光照效果\n基于片元程序的Phong冯氏光照模型 在计算Phong的光照过程中需要利用到模型的法线normal以及模型坐标系下的顶点vertex\n所以就需要在v2f中传递模型坐标系下的vertex与normal\n在v2f使用的参数符合类型且不占用语义即可，即TEXCOORD0与POSITION1\n为了区分变换过后的vertex，所以在传递变换过后的顶点坐标时采用的语义为SV_POSITION\n关于SV_POSITION SV_POSITION：SV_前缀的变量代表system value，\n在DX10以后的语义绑定中被使用代表特殊的意义，和POSITION用法并无不同。\n唯一区别是 SV_POSTION一旦被作为vertex shader的输出语义，\n那么这个最终的顶点位置就被固定了(不能tensellate，不能再被后续改变它的空间位置？)，\n已经成为了转换裁剪世界的坐标，是可以直接用来进入光栅化处理的坐标，\n如果作为fragment shader的输入语义那么和POSITION是一样的，\n代表着每个像素点在屏幕上的位置（这个说法其实并不准确，\n事实是fragment 在 view space空间中的位置，但直观的感受是如括号之前所述一般）\n其次：在DX10版本之前没有引入SV_的预定义语义，POSITION被用作vertex shader的输入，输出，\nfragment shader的输入参数。但DX10之后就推荐使用SV_POSITION作为vertex shader的输出和fragment shader的输入了，\n注意vertex shader的输入还是使用POSITION！切记。\n但是DX10以后的代码依旧兼容POSITION作为全程表达，估计编译器会自动判断并替换\n总结：\n两个的用法大致相同，都是存储坐标信息，但是一个是转换前的，一个是转换后的。\nPOSITION：用来存储，模型在本地坐标下，模型空间中（objcet space）的顶点坐标，转换为剪裁空间坐标前的坐标，unity告诉我们的模型顶点坐标，没经过转换的。可用作定点着色器（vertex shader）的输入、输出；片元着色器（frag）的输入。\nSV_POSITION：用来存储，模型在剪裁空间，投影空间中的位置信息，即把模型空间的定点坐标，转化为剪裁空间的坐标，可用作定点着色器（vertex shader）的输出；片元着色器（frag）的输入。\nShader \u0026#34;ShaderLearning/FragmentDiffuseShader/FrgmentPhongShader\u0026#34; { Properties { \\_MainColor (\u0026#34;MainColor\u0026#34;, Color) = (1,1,1,1) \\_SpecularColor (\u0026#34;SpecularColor\u0026#34;, Color) = (0.5,0.5,0.5,1) \\_Shineness(\u0026#34;Shineness\u0026#34;,Range(1,32))=8 } SubShader { Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34; } ​ Pass { CGPROGRAM #pragma multi\\_compile\\_fwdbase #pragma vertex vert #pragma fragment frag ​ #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 pos : SV\\_POSITION; float3 normal : TEXCOORD0; float4 vertex: POSITION1; }; ​ fixed4 \\_MainColor; fixed4 \\_SpecularColor; float \\_Shineness; ​ v2f vert (appdata\\_base v) { v2f o; o.pos=UnityObjectToClipPos(v.vertex); o.normal=v.normal; o.vertex=v.vertex; ​ return o; } ​ fixed4 frag (v2f i) : COLOR { //环境光颜色 fixed4 col=UNITY\\_LIGHTMODEL\\_AMBIENT; //模型坐标系下的法线转位世界坐标系下 float3 N=UnityObjectToWorldNormal(i.normal); //获取世界坐标系下的光照方向 float3 L=normalize(WorldSpaceLightDir(i.vertex)); //计算漫反射 float diffuse=saturate(dot(L,N)); //计算摄像机观察视角向量 float3 V=normalize(WorldSpaceViewDir(i.vertex)); //计算入射光反射向量,L取反就是入射光向量 float3 R=reflect(-L,N); //计算镜面高光 float specular=pow(saturate(dot(V,R)),\\_Shineness); //叠加上漫反射与镜面高光的颜色乘上光照颜色 col+= \\_LightColor0\\*((\\_MainColor\\*diffuse)+(\\_SpecularColor\\*specular)); //计算世界坐标系下的顶点位置 float3 wpos=mul(unity\\_ObjectToWorld,i.vertex).xyz; //计算4个点光源颜色 col.rgb+=Shade4PointLights(unity\\_4LightPosX0, unity\\_4LightPosY0, unity\\_4LightPosZ0, unity\\_LightColor\\[0\\].rgb,unity\\_LightColor\\[1\\].rgb, unity\\_LightColor\\[2\\].rgb,unity\\_LightColor\\[3\\].rgb, unity\\_4LightAtten0,wpos,N); ​ return col; } ENDCG } } } ​\n效果图⬇️\n基于片元程序的BlinnPhong布林冯光照模型 更改为BlinnPhong只需要将计算镜面高光部分改为使用半角向量进行计算即可\n//计算镜面高光,使用半角向量\nfloat specular=pow(saturate(dot(N,normalize(L+V))),_Shineness);\n完整代码 Shader \u0026#34;ShaderLearning/FragmentDiffuseShader/FrgmentBlinnPhongShader\u0026#34; { Properties { \\_MainColor (\u0026#34;MainColor\u0026#34;, Color) = (1,1,1,1) \\_SpecularColor (\u0026#34;SpecularColor\u0026#34;, Color) = (0.5,0.5,0.5,1) \\_Shineness(\u0026#34;Shineness\u0026#34;,Range(1,32))=8 } SubShader { Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34; } ​ Pass { CGPROGRAM #pragma multi\\_compile\\_fwdbase #pragma vertex vert #pragma fragment frag ​ #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 pos : SV\\_POSITION; float3 normal : TEXCOORD0; float4 vertex: POSITION1; }; ​ fixed4 \\_MainColor; fixed4 \\_SpecularColor; float \\_Shineness; ​ v2f vert (appdata\\_base v) { v2f o; o.pos=UnityObjectToClipPos(v.vertex); o.normal=v.normal; o.vertex=v.vertex; ​ return o; } ​ fixed4 frag (v2f i) : COLOR { //环境光颜色 fixed4 col=UNITY\\_LIGHTMODEL\\_AMBIENT; //模型坐标系下的法线转位世界坐标系下 float3 N=UnityObjectToWorldNormal(i.normal); //获取世界坐标系下的光照方向 float3 L=normalize(WorldSpaceLightDir(i.vertex)); //计算漫反射 float diffuse=saturate(dot(L,N)); //计算摄像机观察视角向量 float3 V=normalize(WorldSpaceViewDir(i.vertex)); //计算镜面高光,使用半角向量 float specular=pow(saturate(dot(N,normalize(L+V))),\\_Shineness); //叠加上漫反射与镜面高光的颜色乘上光照颜色 col+= \\_LightColor0\\*((\\_MainColor\\*diffuse)+(\\_SpecularColor\\*specular)); //计算世界坐标系下的顶点位置 float3 wpos=mul(unity\\_ObjectToWorld,i.vertex).xyz; //计算4个点光源颜色 col.rgb+=Shade4PointLights(unity\\_4LightPosX0, unity\\_4LightPosY0, unity\\_4LightPosZ0, unity\\_LightColor\\[0\\].rgb,unity\\_LightColor\\[1\\].rgb, unity\\_LightColor\\[2\\].rgb,unity\\_LightColor\\[3\\].rgb, unity\\_4LightAtten0,wpos,N); ​ return col; } ENDCG } } } 效果图(Phong与BlinnPhong对比)\n左侧Phong，右侧BlinnPhong\n","permalink":"https://EitanWong.github.io/en/posts/shader/fragmentshader-%E7%89%87%E5%85%83%E7%BA%A7%E5%85%89%E7%85%A7/","summary":"之前在编写Phong与BlinnPhong的时候，我将光照计算的部分放在顶点程序vert当中 顶点程序是针对顶点的，比如一个模型有8个顶点，就会计算8次 而片段程序当中是针对像素的，有n个像素就会计算n次 所以在之前编写的着色器当中，由于在顶点当中进行,最后光照的效果，出现了斑块，效果","title":"FragmentShader-片元级光照"},{"content":"Phong冯氏光照模型 在现实生活当中，光照是一个复杂的过程，在计算机当中模拟这样的光照是非常复杂的\n我们可以用一种简化的模型来对现实世界进行近似的光照模拟\nPhong冯氏光照就是其中的一种比较简单的光照模型，\n它是一个关于模型表面上点的局部照明的经验模型(empirical model)\n由 发明\n一个标准的Phong模型由以下三个部分组成\nAmbient(环境光) Diffuse(漫反射) Specular(高光/镜面反射) Ambient(环境光) 在生活当中，即使是黑暗的环境当中，也存在一些光照，例如星光、月光等，环境光就是模拟这些光照效果，物体一般来说不可能是绝对的黑暗，所以在Phong模型当中，我们通常用一个ambient系数乘上一个颜色，来模拟环境光\nfloat ambientStrength=0.1;//环境光的强度系数\nvec3 ambient = ambientStrength * lightColor;//环境光\nDiffuse(漫反射) 在我们生活当中光线照射到物体表面，物体越靠近光源的面其亮度系数也就越高\n漫反射能表现物体的方向性,这也是Phong当中效果最显著的部分\n为了计算光源的方向与亮度的关系，我们就要引入法线,通过入射光与法线直线的角度关系，得到光照的强度\n下面是具体的计算代码\n//计算出法向量和光线方向的单位向量\nvec3 norm = normalize(Normal); vec3 lightDir = normalize(lightPos - FragPos);\n//判断漫反射强度系数\nfloat diff = max(dot(norm, lightDir), 0.0);\n//计算漫反射光照\nvec3 diffuse = diff * lightColor;\n首先要对计算的法向量和入射光向量，进行归一化，\n将两个向量进行点积操作，并且限制在0~1之间得到光照的亮度系数\n最后亮度系数乘上颜色即可\nSpecular(高光/镜面反射) 在现实生活中，一些光滑的物体除了基本的漫反射，还有高光的部分\n​\n光滑物体表面的高光，会随着人眼的视线发生改变,它依赖与人的观察方向\n​\n所以，我们就需要引入反射光向量与摄像机视角向量\n$ \\vec{R} $代表光线的反射光线。 人的视线与反射光线的夹角θ越小，观察到的镜面反射的效果越明显\nfloat specularStrength = 0.5; //镜面反射强度\nvec3 viewDir = normalize(viewPos - FragPos); //视线方向\nvec3 reflectDir = reflect(-lightDir, norm); //反射光线\nfloat spec = pow(max(dot(viewDir, reflectDir), 0.0), 32); vec3 specular = specularStrength * spec * lightColor; //镜面反射光线\n使用reflect函数得到反射光向量，reflect函数的推导过程可以参考的另外一篇 float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);中的32代表高光的反射度(Shininess)。反射度越高，反射光的能力越强，高光点越小，如下图所示。\nBlinn Phong(布林冯光照模型) Phong的主要问题在于视线方向和反射方向之间的夹角必须小于90度，才能使镜面光项非零\nV和R之间的角度大于90度。 Phong 没有正确模拟这样的情况。\n在面向相机的点可能有微面，但 Phong 无法正确建模。\n问题在于观察方向和反射方向之间的点积可能为负，这在通过方程的其余部分时不会导致合理的结果。\n关于Phong模型中反射和视角大于90度的问题，可以通过改变计算方式来解决\n​\n这个修改后的模型称为Blinn-Phong高光模型或者仅仅是Blinn高光模型\n它在物理上并不比Phong模型更正确。但它确实比Phong模型更加全面\nBlinn 模型使用一组不同的向量进行计算，这些向量在所有有效情况下都小于 90 度\nBlinn 模型需要计算半角向量。 半角矢量是视图方向和光位置之间的中间方向\n计算半角向量 Blinn模型当中，使用入射光$\\vec{L}$与摄像机视角$\\vec{V}$，相加得到半角向量$\\vec{H}$\n即$ \\vec{H} = \\vec{L}+\\vec{V} $\n再用求得的半角向量$\\vec{H}$与法向量$\\vec{N}$进行点积运算，求得亮度系数\n记得都要归一化哦！并且要限制在0～1之间\n下面是在Unity当中实现的BlinnPhong\nShader \u0026ldquo;ShaderLearning/ShaderLearning\u0026rdquo;\n{\nProperties\n{\n_Shininess(\u0026ldquo;Shininess\u0026rdquo;,Range(1,64))=1\n}\nSubShader\n{\n​\nTags {\u0026ldquo;LightMode\u0026rdquo;=\u0026ldquo;ForwardBase\u0026rdquo;}\nPass\n{\nCGPROGRAM\n#pragma vertex vert\n#pragma fragment frag\n​\n#include \u0026ldquo;UnityCG.cginc\u0026rdquo;\n#include \u0026ldquo;Lighting.cginc\u0026rdquo;\n​\nstruct v2f\n{\nfloat4 vertex : SV_POSITION;\nfixed4 color : COLOR;\n};\n​\n​\nfloat _Shininess;\n​\nv2f vert (appdata_full v)\n{\nv2f o;\no.vertex=UnityObjectToClipPos(v.vertex);\n//计算世界坐标系下的光向量\nfloat3 L=normalize(WorldSpaceLightDir(v.vertex));\n//物体坐标系法线转为世界坐标系法线\nfloat3 N=UnityObjectToWorldNormal(v.normal);\n//计算世界空间下归一化的的摄像机观察方向\nfloat3 V=normalize(_WorldSpaceCameraPos-mul(unity_ObjectToWorld,v.vertex));\n//计算漫反射\nfloat diffuse=saturate(dot(L,N));\n//计算镜面高光，使用半角向量\nfloat specular=pow(saturate(dot(N,normalize(L+V))),_Shininess);\n//光源颜色分别和漫反射和镜面高光的强度系数相乘，最终赋给颜色\no.color=_LightColor0*(diffuse+specular);\nreturn o;\n}\n​\nfixed4 frag (v2f i) : COLOR\n{\n//片远着色器，最终的颜色加上固定的环境光颜色\nreturn i.color+UNITY_LIGHTMODEL_AMBIENT;\n}\nENDCG\n}\n}\n}\n​\nPhong与Blinn Phong的效果对比 左边Phong冯氏光照模型效果\n右边BlinnPhong 布林冯光照模型效果\n","permalink":"https://EitanWong.github.io/en/posts/shader/%E5%85%89%E7%85%A7%E6%A8%A1%E5%9E%8B-phong%E4%B8%8Eblinnphong/","summary":"Phong冯氏光照模型 在现实生活当中，光照是一个复杂的过程，在计算机当中模拟这样的光照是非常复杂的 我们可以用一种简化的模型来对现实世界进行近似的光照模拟 Phong冯氏光照就是其中的一种比较简单的光照模型， 它是一个关于模型表面上点的局部照明的经验模型(empirical model) 由 发明 一个","title":"光照模型-Phong与BlinnPhong"},{"content":"前言💬 在计算机图形学中，光照模型是非常重要的一部分。\n为了模拟现实中的光照效果，我们需要理解一些基本的光学原理。\n本文将介绍反射向量的概念以及如何在Unity引擎中使用Cg reflect函数实现反射效果\n一、什么是反射向量 在图形学中，反射向量是一个描述光线如何反射的重要概念。当光线照射到一个表面上，它会被反射到不同的方向。反射向量的计算是基于光线的入射角和法线向量的。通过计算反射向量，我们可以模拟出光线在表面上的反射效果，从而制作出逼真的光照效果。\n二、Cg reflect函数 Cg中的reflect函数可以帮助我们快速计算反射向量\n在Unity中改函数被定义在\n函数原型如下：\nfloat3 reflect(float3 incidentVector, float3 normalVector); 其中，incidentVector 是入射光线的方向，normalVector 是表面的法线向量。\n函数返回一个反射光线的方向向量。\n原理 CG当中reflect函数的实现\n// i为入射光线，n为法线 float3 reflect( float3 i, float3 n ) { return i - 2.0 \\* n \\* dot(n,i); } 推导过程 求反射向量OB\n$$ \\vec{OB}=\\vec{AB}-\\vec{AO} $$\n$$ \\vec{OB}=2\\vec{AP}-\\vec{AO}=2(\\vec{AO}+\\vec{OP})-\\vec{AO}=\\vec{AO}+2\\vec{OP} $$\n所以此时重点在于求向量OP\n那么如何求向量OP\n我们据下图举例模型进行推导\n根据点积的性质可知：\n$$ \\vec{OA}\\cdot\\cosθ=\\vec{OA^{\u0026rsquo;}}\n$$\n$$ \\vec{OA}\\cdot\\vec{n}=\\vec{OA}\\cdot\\vec{n}\\cdot\\cosθ\n$$\n所以就有\n$$ \\vec{OA^{\u0026rsquo;}}=\\vec{OA}\\cdot\\cosθ\\cdot\\vec{n}\n$$\n$$ \\vec{OA^{\u0026rsquo;}}=\\vec{OA}\\cdot\\frac{\\vec{OA}\\cdot\\vec{n}}{\\vec{OA}*\\vec{n}}\\cdot\\vec{n} $$\n$$ 设\\vec{n}=1,就有\\vec{OA^{\u0026rsquo;}}=(\\vec{OA}\\cdot\\vec{n})\\cdot\\vec{n} $$\n所以根据此推导的原理可知\n$$ \\vec{OP}=-(\\vec{AO}\\cdot\\vec{n})\\cdot\\vec{n} $$\n即：\n$$ \\vec{OB}=\\vec{AO}-2\\vec{n}\\cdot(\\vec{AO}\\cdot\\vec{n})\n$$\n所以Cg当中的reflect函数中的实现\ni - 2.0 * n * dot(n,i)\n就是这样推导来的\n更详细的推导过程可以看下图\n三、实现Specular高光 首先我们需要计算出反射光的向量，利用reflect函数\nfloat3 N=normalize(mul(unity_WorldToObject,v.normal));\nfloat3 L=normalize(_WorldSpaceLightPos0);\n// L也可以替换为WorldSpaceLightDir(v.vertex)\nfloat3 R= reflect(-L,N);//由于L是朝向光源方向的向量取反-L就示入射光的向量了\n计算出反射光向量后，用反射光向量和朝向摄像机视角向量进行点积，并且将值映射在0～1之间\nfloat3 V= normalize(WorldSpaceViewDir(v.vertex));\nfloat specularL= saturate(dot(V,R));\n为了实现指数级的衰减效果，可以使用pow函数,根据_Shininess调整衰减效果,_Shininess可以在Properties中定义暴露的参数\nspecularL=pow(specularL,_Shininess);\n最后将灯光颜色乘上Specular的亮度，附加到color上,即可\no.color+=_LightColor0*specularL;\n四、完整代码 Shader \u0026#34;ShaderLearning/Diffuse/SpecularDiffuse\u0026#34; { Properties { \\_Shininess(\u0026#34;Shininess\u0026#34;,Range(1,64))=1 } SubShader { Tags { \u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34; } Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 vertex: POSITION; fixed4 color: COLOR; }; float \\_Shininess; v2f vert (appdata\\_full v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); float3 N=normalize(mul(unity\\_WorldToObject,v.normal)); float3 L=normalize(\\_WorldSpaceLightPos0); float dotL=saturate(dot(N,L)); o.color=\\_LightColor0\\*dotL; // L也可以替换为WorldSpaceLightDir(v.vertex) float3 R= reflect(-L,N); float3 V= normalize(WorldSpaceViewDir(v.vertex)); float specularL= saturate(dot(V,R)); specularL=pow(specularL,\\_Shininess); o.color+=\\_LightColor0\\*specularL; return o; } fixed4 frag (v2f i) : COLOR { return i.color+UNITY\\_LIGHTMODEL\\_AMBIENT; } ENDCG } } } 效果如下图所示\n实现了一个简单的Specular的效果\n要注意的是，在使用reflect的函数的要注意，入射光和法线要在同一个坐标系空间\n","permalink":"https://EitanWong.github.io/en/posts/shader/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E5%8F%8D%E5%B0%84%E5%90%91%E9%87%8F%E4%B8%8Ecg-reflect%E5%87%BD%E6%95%B0-2/","summary":"前言💬 在计算机图形学中，光照模型是非常重要的一部分。 为了模拟现实中的光照效果，我们需要理解一些基本的光学原理。 本文将介绍反射向量的概念以及如何在Unity引擎中使用Cg reflect函数实现反射效果 一、什么是反射向量 在图形学中，反射向量是一个描述光线如何反射的重要概念。当光线照射","title":"图形学入门-反射向量与Cg reflect函数"},{"content":"前言💬 在场景当中可能不止只有Directional Light，还有可能存在点光源等，其他的光源 我们之前实现的Diffuse Shader，只是针对了Directional Light进行光照着色\n从上图可以看到，官方的Diffuse着色器针对不同的灯光，都有不同的响应 如果我们要去实现我们基于顶点和片元的光照程序的时候，需要去考虑场景中哪些灯光对物体有作用，哪些没有作用，关于这些内容，Unity为我们提供了一种前向渲染路径的解决方案，可以参考 前向渲染路径Forward Rendering Path 前向渲染根据影响对象的光源在一个或多个通道中渲染每个对象。光源本身也可以通过前向渲染进行不同的处理，具体取决于它们的设置和强度。\n如果着色器中有一个Pass就会渲染一次，如果有多个Pass就会渲染多次 因为有多个不同的灯光需要去影响这个物体，所以就会针对多个Pass渲染多次\n实现详细信息 在前向渲染中，影响每个对象的一些最亮的光源以完全逐像素光照模式渲染。然后，最多 4 个点光源采用每顶点计算方式。其他光源以球谐函数 (SH) 计算，这种计算方式会快得多，但仅得到近似值。光源是否为每像素光源根据以下原则而定：\nRender Mode 设置为 Not Important 的光源始终为每顶点或 SH 光源。 最亮的方向光始终为每像素光源。 Render Mode 设置为 Important 的光源始终为每像素光源。 If the above results in fewer lights than current Pixel Light Count , then more lights are rendered per-pixel, in order of decreasing brightness. Unity内置的光照🌞辅助函数 在Unity.cginc当中有很多光照的辅助函数，例如下方的ShadeSH9\n// normal should be normalized, w=1.0 // output in active color space half3 ShadeSH9 (half4 normal) { // Linear + constant polynomial terms half3 res = SHEvalLinearL0L1 (normal); // Quadratic polynomials res += SHEvalLinearL2 (normal); # ifdef UNITY_COLORSPACE_GAMMA res = LinearToGammaSpace (res); # endif return res; } 在我们要使用光照的时候，会遇到很多问题，比如哪些情况下用哪些光照函数 在不同渲染的Pass通道当中，会有不同的处理 例如ShadeVertexLightsFull的光照函数\n// Used in Vertex pass: Calculates diffuse lighting from lightCount lights. Specifying true to spotLight is more expensive // to calculate but lights are treated as spot lights otherwise they are treated as point lights. float3 ShadeVertexLightsFull (float4 vertex, float3 normal, int lightCount, bool spotLight) { float3 viewpos = UnityObjectToViewPos (vertex.xyz); float3 viewN = normalize (mul ((float3x3)UNITY_MATRIX_IT_MV, normal)); float3 lightColor = UNITY_LIGHTMODEL_AMBIENT.xyz; for (int i = 0; i \u0026lt; lightCount; i++) { float3 toLight = unity_LightPosition[i].xyz - viewpos.xyz * unity_LightPosition[i].w; float lengthSq = dot(toLight, toLight); // don\u0026#39;t produce NaNs if some vertex position overlaps with the light lengthSq = max(lengthSq, 0.000001); toLight *= rsqrt(lengthSq); float atten = 1.0 / (1.0 + lengthSq * unity_LightAtten[i].z); if (spotLight) { float rho = max (0, dot(toLight, unity_SpotDirection[i].xyz)); float spotAtt = (rho - unity_LightAtten[i].x) * unity_LightAtten[i].y; atten *= saturate(spotAtt); } float diff = max (0, dot (viewN, toLight)); lightColor += unity_LightColor[i].rgb * (diff * atten); } return lightColor; } 这个函数是处理顶点全部的顶点光照\n所以可以在顶点程序当中调用这个函数实现顶点光照 这个函数又会做一次包装\nfloat3 ShadeVertexLights (float4 vertex, float3 normal) { return ShadeVertexLightsFull (vertex, normal, 4, false); } 调用ShadeVertexLights的时候，会制定4个光源，并且禁用聚光灯\n要注意的是，这个函数只能使用在Vertex的Pass通道当中\n所以需要将Pass通道当中的\ntags{\u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34;} 修改为\ntags{\u0026#34;LightMode\u0026#34;=\u0026#34;Vertex\u0026#34;} 完善Diffuse着色器🖌️ 使用ShadeVertexLights函数，加上点光源的光照\nShader \u0026#34;ShaderLearning/diffuse2\u0026#34; { SubShader { Pass { tags{\u0026#34;LightMode\u0026#34;=\u0026#34;Vertex\u0026#34;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 vertex: POSITION; fixed4 color : COLOR; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata_base v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); float3 N=normalize(mul(v.normal,(float3x3)unity_WorldToObject)); float3 L=normalize(_WorldSpaceLightPos0); float ndotl=saturate(dot(N,L)); o.color=_LightColor0*ndotl; o.color.rgb=ShadeVertexLights(v.vertex,v.normal); return o; } fixed4 frag (v2f i) : COLOR { return i.color+UNITY_LIGHTMODEL_AMBIENT; } ENDCG } } } 要注意的是，ShadeVertexLights传入的顶点的法向量，直接是模型空间下的即可，因为在内部的ShadeVertexLightsFull函数当中已经进行了坐标系的变换\n但是启用这个模式过后。你会法线这个球体光照着色的效果和系统内置的效果，有很大的不同 我们可以尝试改变一下模式\nForward Base模式下的光照🌞 我们继续查看Unity.cginc，法线Shade4PointLights函数是在ForwardBase pass通道下的\n// Used in ForwardBase pass: Calculates diffuse lighting from 4 point lights, with data packed in a special way. float3 Shade4PointLights ( float4 lightPosX, float4 lightPosY, float4 lightPosZ, float3 lightColor0, float3 lightColor1, float3 lightColor2, float3 lightColor3, float4 lightAttenSq, float3 pos, float3 normal) { // to light vectors float4 toLightX = lightPosX - pos.x; float4 toLightY = lightPosY - pos.y; float4 toLightZ = lightPosZ - pos.z; // squared lengths float4 lengthSq = 0; lengthSq += toLightX * toLightX; lengthSq += toLightY * toLightY; lengthSq += toLightZ * toLightZ; // don\u0026#39;t produce NaNs if some vertex position overlaps with the light lengthSq = max(lengthSq, 0.000001); // NdotL float4 ndotl = 0; ndotl += toLightX * normal.x; ndotl += toLightY * normal.y; ndotl += toLightZ * normal.z; // correct NdotL float4 corr = rsqrt(lengthSq); ndotl = max (float4(0,0,0,0), ndotl * corr); // attenuation float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq); float4 diff = ndotl * atten; // final color float3 col = 0; col += lightColor0 * diff.x; col += lightColor1 * diff.y; col += lightColor2 * diff.z; col += lightColor3 * diff.w; return col; } 所以我们可以利用这个光照函数 lightPosX, lightPosY, lightPosZ是光源的位置 lightColor0, lightColor1, lightColor2, lightColor3是光的颜色 lightAttenSq是光的衰减系数 pos 和 normal,要传入世界空间下的坐标 这个函数要传入的函数很多，关于光源位置，光的颜色，还有光的衰减系数，可以从Unity内置的变量当中获取 在UnityShader Variables.cginc\nfloat4 unity_4LightPosX0; float4 unity_4LightPosY0; float4 unity_4LightPosZ0; half4 unity_4LightAtten0; half4 unity_LightColor[8]; 调用代码如下方所示\no.color.rgb=Shade4PointLights(unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0, unity_LightColor[0].rgb,unity_LightColor[1].rgb, unity_LightColor[2].rgb,unity_LightColor[3].rgb, unity_4LightAtten0,wpos,N); 这样写有一个问题，这会将我们之前_LightColor0*ndotl的颜色给覆盖掉，也就是说，没有吧Directional Light参与计算的光照给附加上去，所以就会呈现如下图所示的效果(最下面的物体)\n我们只需要将=号改成+=即可 完整代码如下：\nShader \u0026#34;ShaderLearning/diffuse3\u0026#34; { SubShader { Pass { tags{\u0026#34;LightMode\u0026#34;=\u0026#34;ForwardBase\u0026#34;} CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 vertex: POSITION; fixed4 color : COLOR; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata_base v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); float3 N=normalize(mul(v.normal,(float3x3)unity_WorldToObject)); float3 L=normalize(_WorldSpaceLightPos0); float ndotl=saturate(dot(N,L)); o.color=_LightColor0*ndotl; float3 wpos=mul(unity_ObjectToWorld,v.vertex).xyz; o.color.rgb+=Shade4PointLights(unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0, unity_LightColor[0].rgb,unity_LightColor[1].rgb, unity_LightColor[2].rgb,unity_LightColor[3].rgb, unity_4LightAtten0,wpos,N); return o; } fixed4 frag (v2f i) : COLOR { return i.color+UNITY_LIGHTMODEL_AMBIENT; } ENDCG } } } 最终效果如下图所示⬇️\n在Forward rendering path中关于不同数量的灯光\n影响每个对象的一些最亮的光源以完全逐像素光照模式渲染。然后，最多 4 个点光源采用每顶点计算方式。其他光源以球谐函数 (SH) 计算\nA 到 H 具有相同的颜色和强度，并且所有光源都具有自动渲染模式， 因此它们将严格按照此对象的以下顺序排序。 最亮的光源将以每像素光照模式渲染（A 到 D）， 然后最多 4 个光源以每顶点光照模式渲染（D 到 G）， 最后其余光源以 SH 进行渲染（G 到 H）\n如果要实现更复杂的光照，编写有关光和物体交互的Shader， Unity官方建议编写SurfaceShader来达到效果\n","permalink":"https://EitanWong.github.io/en/posts/shader/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E5%8F%8D%E5%B0%84%E5%90%91%E9%87%8F%E4%B8%8Ecg-reflect%E5%87%BD%E6%95%B0/","summary":"前言💬 在场景当中可能不止只有Directional Light，还有可能存在点光源等，其他的光源 我们之前实现的Diffuse Shader，只是针对了Directional Light进行光照着色 从上图可以看到，官方的Diffuse着色器针对不同的灯光，都有不同的响应 如果我们要去实现我","title":"图形学入门-Diffuse Shader接受多个光源的光照"},{"content":"Ambient+Diffuse Diffuse是漫反射，它实际上包含2个部分，一个是Ambient环境光照，另外一个才是Diffuse 为什么需要环境光照？ 在显示世界当中，光照射在环境上，环境又会反射到物体上，在计算机上，我们为了模拟物体的反光，所以我们就直接使用固定的环境光照\nDiffuse光照模型与向量计算 normalized N是定点的法向量，normalized L，是从定点指向光源方向的向量 求这两个向量的点积，就可以知道，这两个向量他们之间的夹角，从点积的结果上看 y=dot(N,L)\n1≥y\u0026gt;0\n90°≥θ\u0026gt;0°\ny=0\nθ=90°\n0\u0026gt;y≥-1\n180°≥θ\u0026gt;90°\n利用这个特性，我们就可以计算某一个顶点应该接收光照的强度\n上图顶点所在的模型物体在空间做了一个方位的旋转，此时法向量N在世界空间当中被旋转了，从顶点指向光源的向量保持不动，这个时候两个向量形成的夹角大于90度，所以点积的结果是负值。应当不接受光照 在实际使用当中负数乘上一个颜色值是没有意义的，所以负数取0即可\n案例 首先在顶点程序当中进行MVP变换 归一化顶点的法向量，通过UnityShaderLab内建的_WorldSpaceLightPos0\n内建光照相关的变量 光参数以不同的方式传递给着色器，具体取决于使用哪个 以及着色器中使用哪个 正向渲染（ForwardBase和ForwardAdd pass types）\nName\nType\nValue\n_LightColor0 *(在 UnityLightingCommon.cginc 中申明)*\nfixed4\n光照颜色\n_WorldSpaceLightPos0\nfloat4\n定向光：（世界空间方向，0）。其他灯光：（世界空间位置，1）。\nunity_WorldToLight (declared in AutoLight.cginc)\nfloat4x4\n世界到光源矩阵. 使用 sample cookie \u0026amp; attenuation textures.\nunity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0\nfloat4\n_（仅适用于ForwardBase pass）_前四个不重要点光源的世界空间位置。\nunity_4LightAtten0\nfloat4\n_（仅适用于ForwardBase pass）_前四个不重要点光源的衰减因子。\nunity_LightColor\nhalf4[4]\n_（仅适用于ForwardBase pass）_前四个非重要点光源的颜色。\nunity_WorldToShadow\nfloat4x4[4]\n世界到阴影矩阵。一种用于Spot Lights，最多四种用于方向光级联（ Directional light cascades）\n关于更多的Build-in shader可以访问 获取到顶点到光源的方向，并将其归一化\nv2f vert (appdata_base v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); float3 N=normalize(v.normal); float3 L=normalize(_WorldSpaceLightPos0); return o; } 将向量N与向量L进行点积计算,并使用saturate函数，使计算的点积映射到0～1之间 并将其值乘上光照颜色_LightColor0赋给COLOR\nfloat ndotl=saturate(dot(N,L)); o.color=_LightColor0*ndotl; ``` 在片元着色器当中添加环境光照 在最后返回i.color后面加上_UNITY_LIGHTMODEL_AMBIENT_\nfixed4 frag (v2f i) : COLOR { return i.color;//+UNITY_LIGHTMODEL_AMBIENT } 在Window-Rendering-Lighting当中可以设置Environment Lighting 将Source改为Color，修改AmbientColor 就会影响模型的固定环境光照颜色\n这样就好了吗？🤔️ 其实我们写的Diffuse Shader有一个非常致命的Bug,我们拿我们的Diffuse Shader和Unity的DiffuseShader进行对比，其实就能发现问题\n当我们将模型旋转一定角度时候，发现光照渲染的位置根本不正确 这是由于我们进行点积的法向量，和光照的方向的向量，不在同一个坐标系的原因导致的\nv.normal是在模型坐标系，而_WorldSpaceLightPos0是世界坐标系 模型自身虽然旋转，但是v.normal相对于自身是没有变化的，_WorldSpaceLightPos0光照的方向也没有改变 所以模型即使旋转了，两者经过点积之后，还是和原来点积的结果一样，就导致了，光照计算后的结果是一致的\n如何解决这个问🙋题❓ 💡要在统一的坐标空间里计算法向量与光向量的点积 有两种方式\n将v.normal变换到世界坐标系，再和光向量进行点积\nfloat3 N=normalize(v.normal); float3 L=normalize(_WorldSpaceLightPos0); N=mul(unity_ObjectToWorld,float4(N,0)).xyz; float ndotl=saturate(dot(N,L)); 将_WorldSpaceLightPos0变换到模型自身的坐标系，再和法向量进行点积\nfloat3 N=normalize(v.normal); float3 L=normalize(_WorldSpaceLightPos0); L=mul(unity_WorldToObject,float4(L,0)).xyz; float ndotl=saturate(dot(N,L)); 现在效果就一样了…………吗❓ 我们把模型进行非等比例的缩放，可以发现，我们的Diffuse着色器和Unity的Diffuse着色器还是不一样\n这是为什么呢❓ 💡原因是经过非等比例缩放之后，顶点法线与切线不再垂直\n上图中x轴缩短为原来的1/2，法线n与切线p3-p2,不再垂直 对于切线它始终由p3-p2来表示，所以p2怎么变，都不会影响到切线 $$ 法线(\\vec{n})与切线(\\vec{t}):(p3-p2) $$ $$ 我们设unity_ObjectToWorld为M，(\\vec{n})转世界空间矩阵为G $$ $$ 我们最终的目的是希望转换后的(\\vec{t^{\u0026rsquo;}})与(\\vec{n^{\u0026rsquo;}})依旧保持垂直关系 $$ $$ 所以就有：(M\\vec{t}\\cdot G\\vec{n}=0) $$ 即M矩阵乘上切线，也就是变换后的模型切线，包括了上述的不等比缩放的情况，这样形成的矩阵与转世界空间矩阵G与法线n相乘的矩阵是正交的\n🔔正交矩阵(Orthogonal matrix)是指矩阵的转置和其逆矩阵相等的矩阵，即A^T=A^(-1) 正交矩阵的性质有： 对于任意的两个向量x和y，都有x^Ty=0，即x和y是正交的\n$$ 用矩阵的写法表示(\\vec{t^{\u0026rsquo;}}\\cdot \\vec{n^{\u0026rsquo;}}=(MT)\\cdot (GN)=0) (向量转成列矩阵形式,用其大写字母表示) $$ $$ 因为(\\vec{t^{\u0026rsquo;}}\\cdot \\vec{n^{\u0026rsquo;}})用矩阵表示为(T^{T}N) $$ $$ 矩阵的性质 \\left(AB\\right)^{\\mathrm {T} }=B^{\\mathrm {T} }A^{\\mathrm {T} } $$ $$ 注意因子反转的次序。以此可推出方阵_A_是可逆矩阵，当且仅当A^{T}是可逆矩阵，在这种情况下有 (A^{−1})^{T} = (A^{T})^{−1}。 $$ $$ 所以(T^{T}N=(MT)\\cdot (GN)=(MT)^{T}(GN)=T^{T}M^{T}GN) $$ $$ 所以 (M^{T}G=I) $$ $$ 所以(G=(M^{T})^{-1}=(M^{-1})^{T}) (满足矩阵转置运算与逆运算可以交换顺序的性质) $$ 这里简单证明一下该性质 $$ 因为 ((MM^{-1})^{T}=(M^{-1})^{T}M^{T}=I) $$ $$ 所以 ((M^{-1})^{T}=(M^{T})^{-1}) $$ $$ 因为M=unity_ObjectToWorld，所以M^{-1}=unity_WorldToObject $$ 所以**G=**unity_WorldToObject的转置 可以用以下代码，进行转置后再和法向量相乘\ntranspose((float3x3)unity_WorldToObject) Unity为我们封装了一个统一的函数_UnityObjectToWorldNormal(in float3 norm),_方便我们把模型法线转到世界空间\ni.normal = UnityObjectToWorldNormal(v.normal); 它定义在UnityCG.ginc中，原码如下:\n// Transforms normal from object to world space inline float3 UnityObjectToWorldNormal( in float3 norm ) { #ifdef UNITY_ASSUME_UNIFORM_SCALING return UnityObjectToWorldDir(norm); #else // mul(IT_M, norm) =\u0026gt; mul(norm, I_M) =\u0026gt; {dot(norm, I_M.col0), dot(norm, I_M.col1), dot(norm, I_M.col2)} return normalize(mul(norm, (float3x3)unity_WorldToObject)); #endif } // Transforms direction from object to world space inline float3 UnityObjectToWorldDir( in float3 dir ) { return normalize(mul((float3x3)unity_ObjectToWorld, dir)); } 它的实现原理正如我们推导的结果一样，只是它更加巧妙的使用\nnormalize(mul(norm, (float3x3)unity_WorldToObject)); 代替了\nnormalize(mul(transpose((float3x3)unity_WorldToObject),normal)); 从而提升了运算效率(省掉了转置计算) 我们修改之前的代码\nfloat3 N=normalize(v.normal); float3 L=normalize(_WorldSpaceLightPos0); N=mul(unity_ObjectToWorld,float4(N,0)).xyz; float ndotl=saturate(dot(N,L)); //修改为以下代码即可 float3 N=normalize(mul(v.normal,(float3x3)unity_WorldToObject)); float3 L=normalize(_WorldSpaceLightPos0); float ndotl=saturate(dot(N,L)); 修改后效果如下图所示\n现在即使经过了不等比缩放，法线也能正确的进行坐标系的变换\n改用片元着色器计算光照 顶点程序计算光照执行效率高，片元程序计算光照较慢但更细腻平滑，由于现代GPU硬件性能的提升 片元程序执行效率得到了极大的优化，现代的硬件处理都不成问题，所以一般来说都可以直接卸载片元着色器上\nfixed4 frag (v2f i) : COLOR { float3 N=normalize(i.normal); float3 L=normalize(_WorldSpaceLightPos0); N=mul(float4(N,0),unity_WorldToObject).xyz; float ndotl=saturate(dot(N,L)); return _LightColor0*ndotl+UNITY_LIGHTMODEL_AMBIENT; } ENDCG 完整代码 Shader \u0026#34;ShaderLearning/diffuse\u0026#34; { SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 vertex: POSITION; float3 normal: TEXCOORD1; fixed4 color : COLOR; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata_base v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.normal=v.normal; return o; } fixed4 frag (v2f i) : COLOR { float3 N=normalize(mul(i.normal,(float3x3)unity_WorldToObject)); float3 L=normalize(_WorldSpaceLightPos0); float ndotl=saturate(dot(N,L)); return _LightColor0*ndotl+UNITY_LIGHTMODEL_AMBIENT; } ENDCG } } } 修改建议🙋 normalize(mul(i.normal,(float3x3)unity_WorldToObject))替换为UnityObjectToWorldNormal(i.normal) 因为UnityObjectToWorldNormal，Unity官方已经为我们封装好了，其中对于等比例缩放和非等比例缩放，都有不同的处理方法，整体方案更加完善 替换后的完整代码\nShader \u0026#34;ShaderLearning/diffuse\u0026#34; { SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; #include \u0026#34;Lighting.cginc\u0026#34; struct v2f { float4 vertex: POSITION; float3 normal: TEXCOORD1; fixed4 color : COLOR; }; sampler2D _MainTex; float4 _MainTex_ST; v2f vert (appdata_base v) { v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.normal=v.normal; return o; } fixed4 frag (v2f i) : COLOR { float3 N=UnityObjectToWorldNormal(i.normal); float3 L=normalize(_WorldSpaceLightPos0); float ndotl=saturate(dot(N,L)); return _LightColor0*ndotl+UNITY_LIGHTMODEL_AMBIENT; } ENDCG } } } ","permalink":"https://EitanWong.github.io/en/posts/shader/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8-%E5%AE%9E%E7%8E%B0%E6%BC%AB%E5%8F%8D%E5%B0%84%E7%9D%80%E8%89%B2%E5%99%A8diffuse-shader/","summary":"Ambient+Diffuse Diffuse是漫反射，它实际上包含2个部分，一个是Ambient环境光照，另外一个才是Diffuse 为什么需要环境光照？ 在显示世界当中，光照射在环境上，环境又会反射到物体上，在计算机上，我们为了模拟物体的反光，所以我们就直接使用固定的环境光照 Diffuse光照模型与向量计算 normalized","title":"图形学入门—实现漫反射着色器Diffuse Shader"},{"content":" 前言💬 这段时间github上的Auto-GPT太火了，看看这个恐怖的Star历史曲线\n原作者直接惊呼50000 Stars!?\n所以，我决定来安装部署以下，体验一下Auto-GPT\n什么是Auto-GPT Auto-GPT是一个实验性的开源应用程序，展示了GPT-4语言模型的功能。该计划由GPT-4驱动，将LLM“想法”链接在一起，以自主实现您设定的任何目标。作为GPT-4完全自主运行的第一批例子之一，Auto-GPT突破了人工智能的界限。\n安装⬇️ 要求 环境（二选一个） vscode + devcontainer: 它已经在.devcontainer文件夹中配置完成，可以直接使用。 Python 3.8 or later OpenAI API key 可选项目:\nMemory backend PINECONE API key (如果您想要Pinecone作为内存后端) Milvus (如果您想将Milvus作为内存后端) ElevenLabs Key (如果你想让人工智能说话) 确保您具备上述所有要求，如果没有，请安装/获取它们\n安装过程\n克隆仓库 git clone https://github.com/Torantulino/Auto-GPT.git 导航到下载存储库的目录 cd Auto-GPT 安装所需的依赖项 pip install -r requirements.txt 在主文件夹/Auto-GPT中找到名为.env.template的文件。通过删除模板扩展名，创建一个名为.env的副本。最简单的方法是在命令提示符/终端窗口中执行cp .env.template .env命令。在文本编辑器中打开.env文件。注意：以点开头的文件可能会被操作系统隐藏。\ncp .env.template .env 找到一行写着OPENAI_API_KEY=的代码。在“=”后面输入你的独特OpenAI API密钥（不带引号或空格）。输入你想要使用的其他API密钥或令牌。保存并关闭“.env”文件。通过完成这些步骤，你已经正确地配置了你的项目的API密钥\n使用Auto-GPT autogpt在终端中运行Python 模块 python -m autogpt 每次操作后，从选项中选择授权命令、退出程序或向 AI 提供反馈。 授权单个命令，输入y 授权一系列N个连续命令，输入y -N 退出程序，进入n 以GPT-3模式运行 python -m autogpt --gpt3only ","permalink":"https://EitanWong.github.io/en/posts/other/-auto-gptai%E7%9A%84%E8%87%AA%E6%88%91%E9%A9%B1%E5%8A%A8/","summary":"前言💬 这段时间github上的Auto-GPT太火了，看看这个恐怖的Star历史曲线 原作者直接惊呼50000 Stars!? 所以，我决定来安装部署以下，体验一下Auto-GPT 什么是Auto-GPT Auto-GPT是一个实验性的开源应用程序，展示了GPT-4语言模型的功能。该计划由GPT-4驱","title":"🤖 Auto-GPT：AI的自我驱动"},{"content":"前言💬 最近日常使用的软件逐渐增多，目前多数人常用的的层叠式窗口管理，似乎开始不适合我的日常使用 所以我决定折腾一下mac下的平铺式窗口管理软件yabai\n什么是yabai yabai 是一款适用于 macOS Big Sur 11.0.1+ 和 Monterey 12.0.0+ 的平铺式窗口管理器。 它使用二叉空间分割算法自动修改您的窗口布局，使您能够专注于窗口内容而不受干扰。 灵活且易于理解的命令行界面允许您控制和查询窗口、空间和显示器，实现与诸如↗ skhd等工具的强大集成，使您能够更高效地使用 macOS。轻松创建自定义快捷键来控制窗口、空间和显示器，几乎不需要时间，让您的双手离开鼠标和触控板，回到键盘上进行实际工作。\n平铺式与层叠式的区别 层叠式窗口管理（Stacking Window Manager）与平铺式窗口管理（Tiling Window Manager）是两种不同的计算机桌面环境中的窗口管理方式。它们的主要区别在于如何组织和显示打开的应用程序窗口。 层叠式窗口管理：\n概念：层叠式窗口管理器将打开的窗口以层叠或重叠的形式显示在桌面上，就像摆放在桌子上的纸张一样。这是许多传统桌面环境的默认窗口管理方式，如 Microsoft Windows 和 Apple macOS。 灵活性：用户可以自由移动、缩放和重叠窗口，根据自己的需求调整窗口的位置和大小。 窗口切换：用户可能需要频繁切换窗口或将窗口最小化以查看其他窗口。在多任务情况下，可能导致桌面混乱。 空间利用：层叠式窗口管理可能无法充分利用屏幕空间，特别是当用户打开大量窗口时。 平铺式窗口管理：\n概念：平铺式窗口管理器会将打开的窗口以非重叠的方式自动排列在桌面上。每个窗口都被分配一个固定的屏幕区域，这使得所有窗口都可以同时显示，无需重叠或最小化。一些流行的平铺式窗口管理器包括 i3、xmonad 和 dwm。 空间利用：平铺式窗口管理器通常更有效地利用屏幕空间，特别是在多任务和多显示器设置中。 键盘驱动：许多平铺式窗口管理器主要依赖键盘快捷键来操作，这对于喜欢使用键盘的高效用户来说可能更加方便。 学习曲线：平铺式窗口管理器通常具有较高的学习曲线，因为它们可能需要用户学习新的操作习惯和快捷键。同时，它们通常提供高度的可定制性，让用户能够根据自己的需求和喜好进行调整。 安装yabai 可以通过 Homebrew 的软件源 koekeishiya/formulae 安装 yabai 的经过代码签名的二进制版本\nbrew install koekeishiya/formulae/yabai 启动yabai服务\n弹出Accessibility权限申请的窗口\n开启yabai的Accessibility权限即可\n启动后你会发现没有任何不同，这是因为 yabai 需要我们有对应的 .yabairc 配置文件才会生效，默认是没有这个文件的，也就是 yabai 不会做任何处理。\n配置yabai 我们需要在 HOME 目录下生成 .yabairc 并增加可执行权限，然后通过 brew services restart yabai 重新启动 yabai 即可让配置文件生效。 yabai 配置比较简单，可以用 man yabai 和 对照着看，可以先拷贝成自己的 ~/.yabairc 感受一下。\n一键下载配置文件 如果你嫌麻烦可以直接下载示例配置文件\ncurl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/yabairc --output ~/.yabairc 手动安装配置文件 1.使用vim配置~/.yabairc\nvim ~/.yabairc 2,粘贴example配置文件\n3.重启yabai\nbrew services restart yabai 现在你就会发现，窗口已经是平铺式的了\nyabai的启动方式 yabai一直在后台运行，用户登陆的时候也会自动启动\nbrew services start koekeishiya/formulae/yabai 临时启动\nyabai 启用yabai更多功能 如果我们已经禁用了 Mac 的 SIP System Integrity Protection，则可以在启动前先输入以下命令，可以启用更多 yabai 的功能；但也会让系统变得相对不安全： 关于如何禁用SIP可以网上搜索相关文章，如果你和我一样使用OpenCore Legacy Patcher安装的macOS 可以看我写的(文章)[https://blog.erratas.cloud/index.php/2023/04/10/opencore-legacy-patcher%e5%85%b3%e9%97%adsip%e4%bf%9d%e6%8a%a4%f0%9f%94%92/\\]来关闭SIP保护\n# 安装脚本附加组件 sudo yabai --install-sa # 如果使用的是 macOS Big Sur 或 Monterey，请手动加载脚本附加组件。请按照以下说明在启动时自动化 sudo yabai --load-sa 由于yabai使用macOS Mach API将代码注入Dock.app;这需要提升 (root) 权限。因此可以配置用户以root身份执行yabai \u0026ndash;load-sa 而无需输入密码。为此需要添加一个_/etc/sudoers_加载的新配置条目 创建一个新文件进行编写 - visudo 默认使用 vim 编辑器\nsudo visudo -f /private/etc/sudoers.d/yabai 将下面的行输入到你正在编辑的文件中。 将 替换为 yabai 二进制文件的路径（输出结果：which yabai）。 将 替换为你的用户名（输出结果：whoami）。 将 替换为 yabai 二进制文件的 sha256 哈希值（输出结果：shasum -a 256 $(which yabai)）。 运行 brew upgrade 后必须手动更新此哈希值。\n\u0026lt;user\u0026gt; ALL=(root) NOPASSWD: sha256:\u0026lt;hash\u0026gt; \u0026lt;yabai\u0026gt; --load-sa 例如\neitan ALL=(root) NOPASSWD: sha256:740b9e6aab46f8c499f0fc651ae1861d4ebe48b6e6a50296bf4a9ad879bbad93 /usr/local/bin/yabai --load-sa 完成上述编辑后，在 yabairc 配置文件顶部添加加载脚本的命令\nyabai -m signal --add event=dock_did_restart action=\u0026#34;sudo yabai --load-sa\u0026#34; sudo yabai --load-sa 完成之后重启yabai\nbrew services restart yabai 安装并配置skhd 配置好了 yabai 后，我们已经实现了智能分屏，但是有时候算法提供的窗口位置不满足我们的需求，或是我们需要频繁在各个窗口之间切换/调整，那就需要用到 skhd 工具来定制一些快捷键配置。\n安装skhd brew install koekeishiya/formulae/skhd 下载skhd配置文件 同样的，和 yabai 一样，skhd 需要有 ~/.skhd 才生效，也可以看看 学习一下。 你可以使用以下命令一键下载配置文件\ncurl https://raw.githubusercontent.com/koekeishiya/yabai/master/examples/skhdrc --output ~/.skhdrc 启动skhd brew services start skhd 同样第一次启动 skhd 和 yabai 一样，macOS 会提示是否允许两者访问辅助功能。在系统偏好设置中添加权限后，再重启一次 skhd 即可正常工作\n重启skhd\nbrew services restart skhd 另外再分享两个 skhd 初配置时可能有用的东西：\n如果.skhdrc有部分配置存在无法运行，那么整个.skhdrc都不会生效 我们可以先手动停止 skhd（brew services stop skhd），然后在终端运行 skhd -V 或者 skhd --verbose，这会加载 .skhdrc 并输出对应 debug 信息。 如果有不正确或者无法运行的，skhd 便会输出并提示（如下图） skhd 配置时，有些键位我们不知道如何表示 可以在终端运行 skhd --observe 查看键盘上对应按键在 skhd 中对应的编码，例如下面用 0x24 表示回车 ## full screen / un-full screen(切换窗口全屏) 0x24 表示回车 ctrl + alt - 0x24 : yabai -m window --toggle zoom-fullscreen 安装jq jq 是一个轻量级且灵活的命令行 JSON 数据处理工具。它可以帮助你解析、过滤、查询和操作 JSON 数据。使用 jq，你可以在命令行中对 JSON 数据执行各种操作，例如提取特定字段、过滤数组元素或转换数据格式等 通过它我们可以方便地进行一些 yabai 的相关配置，例如当前我使用的「快速关闭当前窗口」\n## Close active application (快速关闭窗口) ctrl + alt - backspace : $(yabai -m window $(yabai -m query --windows --window jq -re \u0026#34;.id\u0026#34;) --close) 安装jq\nbrew install jq .yabairc 和 .skhdrc配置文件 .yabairc #!/usr/bin/env sh # 如果没有关闭 Mac 的 SIP，那么在 BigSur 及以上的系统中，更改配置文件后，需要手动加载过配置文件 # - https://github.com/koekeishiya/yabai/wiki/Installing-yabai-(latest-release) # 如果已经关闭 Mac 的 SIP，那么通过下面命令就可以让 yabai 的配置文件热更新了 # sudo yabai --load-sa # 也可以在该配置文件中增加这句，这样每次重启系统时不用自己输入 # yabai -m signal --add event=dock_did_restart action=\u0026#34;sudo yabai --load-sa\u0026#34; # ------------------------------------------------------------------------------------- # # ------------------------------global settings---------------------------------------- # # ------------------------------------------------------------------------------------- # # 在多显示器情况下，新建的窗口默认在**哪个显示器**出现 # - default: 在创建窗口的显示器出现（mac 的默认行为） # - focused: 在当前聚焦的显示器出现 # - cursor: 在鼠标指针所在的显示器出现 yabai -m config window_origin_display default # 当前屏幕下，新窗口的出现在**屏幕的哪个位置** # - first_child: （父节点模式）如果当前是 vertical split，则出现在*左侧*；如果是 horizontal split，则出现在*上方* # - second_child: （子节点模式）如果当前是 vertical split，则出现在*右侧*；如果是 horizontal split，则出现在*下方* yabai -m config window_placement second_child # 浮动窗口是否置顶 yabai -m config window_topmost on # 窗口阴影值 # - on: 总是展示 # - off: 总是关闭 # - float: 只有浮动窗口展示 yabai -m config window_shadow on # 窗口不透明 # - on: 总是展示 # - off: 总是关闭 yabai -m config window_opacity off # *激活*窗口的不透明度（仅当 window_opacity on 时才有效） yabai -m config active_window_opacity 1.0 # *普通*窗口不透明度（仅当 window_opacity on 时才有效） yabai -m config normal_window_opacity 0.90 # 激活窗口和普通窗口切换时，*不透明度的过渡时间*（仅当 window_opacity on 时才有效） yabai -m config window_opacity_duration 0.0 # 窗口边框 # - on: 总是展示 # - off: 总是关闭 yabai -m config window_border off # 窗口*边框宽度*（单位 px） yabai -m config window_border_width 6 # 激活窗口的边框颜色 yabai -m config active_window_border_color 0xff775759 # 普通窗口的边框颜色 yabai -m config normal_window_border_color 0xff555555 yabai -m config insert_feedback_color 0xffd75f5f # 所有窗口都使用相同比例的空间 # - on: 总是开启 # - off: 总是关闭 yabai -m config auto_balance on # 分屏后*旧:新*窗口的比例（仅当 auto_balance off 时有效） yabai -m config split_ratio 0.50 # ==================================================== # # ====================鼠标相关======================== # # ==================================================== # # 窗口切换时，鼠标自动移动到当前使用窗口的中心 # - on: 总是开启 # - off: 总是关闭 yabai -m config mouse_follows_focus off # 是否自动聚焦到鼠标所在窗口 # - off: 总是关闭 # - autoraise: # - autofocus: yabai -m config focus_follows_mouse off # 按住对应修饰键时，yabai 不自动调整平铺（默认情况下调整窗口大小时，yabai 会自适应调整平铺）；配置时通常会关闭 focus_follows_mouse # - cmd # - alt # - shift # - ctrl # - fn yabai -m config mouse_modifier fn # modifier + 左键的行为 # - move # - resize yabai -m config mouse_action1 move # modifier + 右键的行为 # - move # - resize yabai -m config mouse_action2 resize # 在平铺管理情况下，拖动一个窗口到另一窗口位置时的操作 # - swap: 交换窗口位置 # - stack: 堆叠在旧窗口上 yabai -m config mouse_drop_action swap # ------------------------------------------------------------------------------------- # # ---------------------------general space settings------------------------------------ # # ------------------------------------------------------------------------------------- # # yabai 布局模式 # - bsp: 平铺 # - stack: 堆叠 # - float: 浮动 yabai -m config layout bsp # 窗口和屏幕边缘的距离（优先级低于 gap） yabai -m config top_padding 08 yabai -m config bottom_padding 08 yabai -m config left_padding 08 yabai -m config right_padding 08 # 窗口与窗口之间的间距（优先级高于 padding） yabai -m config window_gap 05 # ------------------------------------------------------------------------------------- # # ---------------------------------specific apps--------------------------------------- # # ------------------------------------------------------------------------------------- # # manage: 是否使用 yabai 管理 # - on # - off # sticky: 是否总是置顶 # - on # - off # layer: # - below # - normal # - above yabai -m rule --add app=\u0026#34;^System Preferences$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^System Information$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Activity Monitor$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Finder$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Alfred Preferences$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^飞书$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Feishu$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Lark$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Lark Meetings$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Seal$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^AppCleaner$\u0026#34; sticky=off layer=above manage=off yabai -m rule --add app=\u0026#34;^Karabiner-Elements$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Karabiner-EventViewer$\u0026#34; sticky=on layer=above manage=off yabai -m rule --add app=\u0026#34;^Things$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^Spotify$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^Bartender 4$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^BetterTouchTool$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^Magnet$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^WeChat$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^微信$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^QQ$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^Clash for Windows$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^CleanMyMac X$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^PicGo$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^OpenCore-Patcher$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^ToDesk$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^Bandizip$\u0026#34; manage=off yabai -m rule --add app=\u0026#34;^Archive Utility$\u0026#34; manage=off echo \u0026#34;yabai configuration loaded..\u0026#34; .skhdrc #SKHD STUFF # if you\u0026#39;re having troubles finding key codes for a key just type skhd --observe in a terminal and type a key. Pretty cool! Or just check the wiki. ## HYPER == SHIFT + CMD + ALT + OPTION ### ============================================================================ ### ### Eitan\u0026#39;s Settings ### ### ============================================================================ ### # open terminal cmd - return : /Applications/Warp.app/Contents/MacOS/stable --single-instance -d ~ \u0026amp;\u0026gt; /dev/null ## Close active application (快速关闭窗口) ctrl + alt - backspace : $(yabai -m window $(yabai -m query --windows --window jq -re \u0026#34;.id\u0026#34;) --close) ## Equalize size of windows (平铺当前界面所有窗口) ctrl + alt - 0 : yabai -m space --balance ## focus window (切换窗口焦点) alt - x : yabai -m window --focus recent alt - h : yabai -m window --focus west alt - j : yabai -m window --focus south alt - k : yabai -m window --focus north alt - l : yabai -m window --focus east alt - z : yabai -m window --focus stack.prev alt - c : yabai -m window --focus stack.next ## swap window \u0026amp; move window in floating mode (交换窗口) shift + alt - x : yabai -m window --swap recent shift + alt - k : yabai -m window --swap north shift + alt - j : yabai -m window --swap south shift + alt - h : yabai -m window --swap west shift + alt - l : yabai -m window --swap east # move window (启动窗口) shift + cmd - h : yabai -m window --warp west shift + cmd - j : yabai -m window --warp south shift + cmd - k : yabai -m window --warp north shift + cmd - l : yabai -m window --warp east ## Rotate windows clockwise and anticlockwise (旋转窗口) ctrl + alt - e : yabai -m space --rotate 90 ctrl + alt - r : yabai -m space --rotate 270 ## float / Unfloat window (切换窗口浮动) ctrl + alt - space : yabai -m window --toggle float ; yabai -m window --grid 12:12:1:1:9:9 ## full screen / un-full screen(切换窗口全屏) 0x24 表示回车 ctrl + alt - 0x24 : yabai -m window --toggle zoom-fullscreen # toggle picture-in-picture(启用画中画) alt - p : yabai -m window --toggle border --toggle pip ## window resize ctrl + shift + alt - k : yabai -m window --resize top:0:-20 yabai -m window --resize bottom:0:-20 ctrl + shift + alt - j : yabai -m window --resize top:0:20 yabai -m window --resize bottom:0:20 ctrl + shift + alt - h : yabai -m window --resize left:-20:0 yabai -m window --resize right:-20:0 ctrl + shift + alt - l : yabai -m window --resize right:20:0 yabai -m window --resize left:20:0 ## send window to next monitor and follow focus (将窗口发送到另一个显示器) ctrl + alt - left : sh ~/.config/dotfiles/yabai/script/move_window_to_left.sh display ctrl + alt - right : sh ~/.config/dotfiles/yabai/script/move_window_to_right.sh display ## 创建桌面、移动窗口和跟随焦点 - 使用 jq 解析 JSON（brew install jq） shift + alt - n : yabai -m space --create \u0026amp;\u0026amp; \\ index=\u0026#34;$(yabai -m query --spaces --display jq \u0026#39;map(select(.\u0026#34;native-fullscreen\u0026#34; == 0))[-1].index\u0026#39;)\u0026#34; \u0026amp;\u0026amp; \\ yabai -m space --focus \u0026#34;${index}\u0026#34; ","permalink":"https://EitanWong.github.io/en/posts/other/yabai-mac%E4%B8%8B%E7%9A%84%E5%B9%B3%E9%93%BA%E5%BC%8F%E7%AA%97%E5%8F%A3%E7%AE%A1%E7%90%86%E7%A5%9E%E5%99%A8/","summary":"前言💬 最近日常使用的软件逐渐增多，目前多数人常用的的层叠式窗口管理，似乎开始不适合我的日常使用 所以我决定折腾一下mac下的平铺式窗口管理软件yabai 什么是yabai yabai 是一款适用于 macOS Big Sur 11.0.1+ 和 Monterey 12.0.0+ 的平铺式窗口管理器。 它使用二叉空间分割算法自动修改您的窗口布局，使您能够专注于窗口内容","title":"yabai-Mac🍎💻下的平铺式窗口管理神器"},{"content":"前言💬 之前在mac平台上使用Unity，使用Rider作为IDE进行开发，有一说一Rider的功能还是非常强大的，但是在我的老款MacBook上跑就有点笨重了，所以最近决定换到VSCode进行开发\n开发环境配置 首先当然是要安装 了 安装完成VSCode之后 需要安装.Net Core运行环境 还需要再安装 的环境 建议去 下载\nUnity项目中安装Visual Studio Code Editor 新版本当中默认就已经安装了，所以说一般来说不用再手动安装 如果没有安装的话，可以通过Window -\u0026gt; Package Manager安装Visual Studio Code Editor\n接着在Preferences-\u0026gt;External Tools 设置External Script Editor为Visual Studio Code\nVSCode配置 安装C#插件\n安装Unity相关的VSCode扩展插件，Debugger for Unity 还有 Unity Code Snippets\n以及C#XML Documentation Comments，这个插件可以帮助生成方法的注释文档\n推荐一个主题Halcyon，感觉很不错，推荐安装\n打开VSCode的Settings 1.设置Mono Path\n/Library/Frameworks/Mono.framework/Versions/Current 将telemetry Level 设置为off，这样可以禁止发送一些分析报告给微软\n可以将inlay hints设置为on，这样可以在写像c#这样的代码的函数时候直接在VSCode上提示有多少个引用，以及一些参数引用的提示\nwordwrap设置文字的换行 Word Wrap Column设置最多一行显示多少个字符，你也可以保持默认80或者自己设置\nWrapping Indent设置换行缩进，以便在换行时，再其周围缩进下一行\n取消勾选Use Modern Net\n至于为什么要取消勾选这一项，OmniSharp官方的解释是⬇️\n完成这些设置以后关闭VSCode并重新启动，打开Unity项目工程即可\n","permalink":"https://EitanWong.github.io/en/posts/other/macosvscodeunity%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%B0%83%E8%AF%95/","summary":"前言💬 之前在mac平台上使用Unity，使用Rider作为IDE进行开发，有一说一Rider的功能还是非常强大的，但是在我的老款MacBook上跑就有点笨重了，所以最近决定换到VSCode进行开发 开发环境配置 首先当然是要安装 了 安装完成VSCode之后 需要安装.Net Core运行环","title":"macOS+VSCode+Unity的开发环境配置及调试"},{"content":"正则表达式 什么是正则表达式 正则表达式（Regular Expression）是一种用于匹配和处理文本模式的字符序列。 它是一种强大的文本处理工具，常用于编程和文本处理任务中，可以用来搜索、替换、验证和提取符合特定模式的文本。\n语法 正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等\n普通字符 正则表达式中的普通字符是指与其本身字符一一匹配的字符，不具有特殊含义 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 例如用jesson匹配dsjessonjkdfjsWRFDd jessonFFEEGsddeed\n字符\n描述\n效果\n[ABC]\n匹配 [\u0026hellip;] 中的所有字符，例如 [aeiou] 匹配字符串 \u0026ldquo;google runoob taobao\u0026rdquo; 中所有的 e o u a 字母\n[^ABC]\n匹配除了 [\u0026hellip;] 中字符的所有字符，例如 [^aeiou] 匹配字符串 \u0026ldquo;google runoob taobao\u0026rdquo; 中除了 e o u a 字母的所有字母\n[A-Z]\n[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母\n.\n匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r]\n[\\s\\S]\n匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行\n\\w\n匹配字母、数字、下划线。等价于 [A-Za-z0-9_]\n非打印字符 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：\n字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 \u0026lsquo;c\u0026rsquo; 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 \\，runo\\*ob 匹配字符串 runo*ob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符\u0026quot;转义\u0026quot;，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符：\n特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， \u0026rsquo;n\u0026rsquo; 匹配字符 \u0026rsquo;n\u0026rsquo;。\u0026rsquo;\\n\u0026rsquo; 匹配换行符。序列 \u0026lsquo;\\\u0026rsquo; 匹配 \u0026ldquo;\u0026quot;，而 \u0026lsquo;(\u0026rsquo; 则匹配 \u0026ldquo;(\u0026quot;。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有：\n字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。***** 等价于 {0,}。 + 匹配前面的子表达式一次或多次。例如，zo+ 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;，但不能匹配 \u0026ldquo;z\u0026rdquo;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，do(es)? 可以匹配 \u0026ldquo;do\u0026rdquo; 、 \u0026ldquo;does\u0026rdquo;、 \u0026ldquo;doxy\u0026rdquo; 中的 \u0026ldquo;do\u0026rdquo; 和 \u0026ldquo;does\u0026rdquo;。? 等价于 {0,1} {n} n 是一个非负整数。匹配确定的 n 次。例如，o{2} 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 o，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 o，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。o{1,} 等价于 o+。o{0,} 则等价于 o*。 {n,m} m 和 n 均为非负整数，其中 n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，o{1,3} 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。o{0,1} 等价于 o?。请注意在逗号和两个数之间不能有空格。 |\\* 和 \\+ 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配 例如，您可能搜索 HTML 文档，以查找在 h1 标签内的内容。HTML 代码如下：\n\u0026lt;h1\u0026gt;RUNOOB-菜鸟教程\u0026lt;/h1\u0026gt; **贪婪：**下面的表达式匹配从开始小于符号 (\u0026lt;) 到关闭 h1 标记的大于符号 (\u0026gt;) 之间的所有内容。\n/\u0026lt;.*\u0026gt;/ **非贪婪：**如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 h1\n/\u0026lt;.*?\u0026gt;/ 定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有：\n字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首\n修饰符 标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。 标记不写在正则表达式里，标记位于表达式之外，格式如下：\n/pattern/flags 下表列出了正则表达式常用的修饰符：\n修饰符 含义 描述 i ignore - 不区分大小写 将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。 g global - 全局匹配 查找所有的匹配项。 m multi line - 多行匹配 使边界字符 ^ 和 $ 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。 s 特殊字符圆点 . 中包含换行符 \\n 默认情况下的圆点 . 是匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。 元字符 下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：\n字符 描述 \\ ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo; 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 \u0026lsquo;\\n\u0026rsquo; 或 \u0026lsquo;\\r\u0026rsquo; 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 \u0026ldquo;z\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，\u0026lsquo;zo+\u0026rsquo; 能匹配 \u0026ldquo;zo\u0026rdquo; 以及 \u0026ldquo;zoo\u0026rdquo;，但不能匹配 \u0026ldquo;z\u0026rdquo;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，\u0026ldquo;do(es)?\u0026rdquo; 可以匹配 \u0026ldquo;do\u0026rdquo; 或 \u0026ldquo;does\u0026rdquo; 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，\u0026lsquo;o{2}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但是能匹配 \u0026ldquo;food\u0026rdquo; 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，\u0026lsquo;o{2,}\u0026rsquo; 不能匹配 \u0026ldquo;Bob\u0026rdquo; 中的 \u0026lsquo;o\u0026rsquo;，但能匹配 \u0026ldquo;foooood\u0026rdquo; 中的所有 o。\u0026lsquo;o{1,}\u0026rsquo; 等价于 \u0026lsquo;o+\u0026rsquo;。\u0026lsquo;o{0,}\u0026rsquo; 则等价于 \u0026lsquo;o*\u0026rsquo;。 {n,m} m 和 n 均为非负整数，其中n \u0026lt;= m。最少匹配 n 次且最多匹配 m 次。例如，\u0026ldquo;o{1,3}\u0026rdquo; 将匹配 \u0026ldquo;fooooood\u0026rdquo; 中的前三个 o。\u0026lsquo;o{0,1}\u0026rsquo; 等价于 \u0026lsquo;o?\u0026rsquo;。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 \u0026ldquo;oooo\u0026rdquo;，\u0026lsquo;o+?\u0026rsquo; 将匹配单个 \u0026ldquo;o\u0026rdquo;，而 \u0026lsquo;o+\u0026rsquo; 将匹配所有 \u0026lsquo;o\u0026rsquo;。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 \u0026lsquo;\\n\u0026rsquo; 在内的任何字符，请使用像\u0026rdquo;(. (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 \u0026lsquo;(\u0026rsquo; 或 \u0026lsquo;)\u0026rsquo;。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \u0026ldquo;或\u0026rdquo; 字符 ( (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，\u0026ldquo;Windows(?=95 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如\u0026quot;Windows(?!95 (?\u0026lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，\u0026rdquo;(?\u0026lt;=95 (?\u0026lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如\u0026rdquo;(?\u0026lt;!95 x y [xyz] 字符集合。匹配所包含的任意一个字符。例如， \u0026lsquo;[abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的 \u0026lsquo;a\u0026rsquo;。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， \u0026lsquo;[^abc]\u0026rsquo; 可以匹配 \u0026ldquo;plain\u0026rdquo; 中的\u0026rsquo;p\u0026rsquo;、\u0026rsquo;l\u0026rsquo;、\u0026lsquo;i\u0026rsquo;、\u0026rsquo;n\u0026rsquo;。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，\u0026rsquo;[a-z]\u0026rsquo; 可以匹配 \u0026lsquo;a\u0026rsquo; 到 \u0026lsquo;z\u0026rsquo; 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，\u0026rsquo;[^a-z]\u0026rsquo; 可以匹配任何不在 \u0026lsquo;a\u0026rsquo; 到 \u0026lsquo;z\u0026rsquo; 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， \u0026rsquo;er\\b\u0026rsquo; 可以匹配\u0026quot;never\u0026quot; 中的 \u0026rsquo;er\u0026rsquo;，但不能匹配 \u0026ldquo;verb\u0026rdquo; 中的 \u0026rsquo;er\u0026rsquo;。 \\B 匹配非单词边界。\u0026rsquo;er\\B\u0026rsquo; 能匹配 \u0026ldquo;verb\u0026rdquo; 中的 \u0026rsquo;er\u0026rsquo;，但不能匹配 \u0026ldquo;never\u0026rdquo; 中的 \u0026rsquo;er\u0026rsquo;。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 \u0026lsquo;c\u0026rsquo; 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于\u0026rsquo;[A-Za-z0-9_]\u0026rsquo;。 \\W 匹配非字母、数字、下划线。等价于 \u0026lsquo;[^A-Za-z0-9_]\u0026rsquo;。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，\u0026rsquo;\\x41\u0026rsquo; 匹配 \u0026ldquo;A\u0026rdquo;。\u0026rsquo;\\x041\u0026rsquo; 则等价于 \u0026lsquo;\\x04\u0026rsquo; \u0026amp; \u0026ldquo;1\u0026rdquo;。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，\u0026rsquo;(.)\\1\u0026rsquo; 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 例子 下面是一些常用的正则表达式的例子：\n匹配邮箱地址：\n^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$ 匹配手机号码:\n^1[3456789]\\d{9}$ 匹配身份证号码（18位）：\n^\\d{17}[\\dXx]$ 匹配URL：\n^(httphttpsftp)://[^\\s/$.?#].[^\\s]*$ 匹配日期（yyyy-mm-dd）：\n^\\d{4}-\\d{2}-\\d{2}$ 匹配IP地址：\n^((25[0-5]2[0-4]\\d1\\d{2}[1-9]\\d\\d)\\.){3}(25[0-5]2[0-4]\\d1\\d{2}[1-9]\\d\\d)$ 匹配整数：\n^-?\\d+$ 匹配小数：\n^-?\\d+\\.\\d+$ 匹配中文字符：\n^[\\u4e00-\\u9fa5]+$ 匹配HTML标签：\n\u0026lt;([a-zA-Z]+)(\\s*\\w*\\s*=\\s*\u0026#34;[^\u0026#34;]*\u0026#34;)*\\s*/?\u0026gt; ","permalink":"https://EitanWong.github.io/en/posts/other/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fregular-expression/","summary":"正则表达式 什么是正则表达式 正则表达式（Regular Expression）是一种用于匹配和处理文本模式的字符序列。 它是一种强大的文本处理工具，常用于编程和文本处理任务中，可以用来搜索、替换、验证和提取符合特定模式的文本。 语法 正则表达式(regular expression)描述了一","title":"正则表达式(Regular Expression)"},{"content":"前言💬 前不久重装了macOS的系统，之前配置的环境都没了，这段时间Python用的比较多，所以准备安装配置anaconda进行使用\n什么是Anaconda❓ Anaconda是一个数据科学和机器学习的开发环境，包含多种工具和库，可管理和部署数据分析、科学计算和机器学习项目。它包含常用的Python库和其他编程语言支持，还有一个名为conda的包管理器，可安装、更新和卸载软件包。Anaconda还提供了一个集成开发环境（IDE）和Jupyter Notebook，用于数据分析和科学计算任务。\n安装⏬ 前置条件 已安装HomeBrew\n如果没有安装HomeBrew的话 执行以下命令安装\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 第一步 使用brew安装Anaconda brew install anaconda 第二步 配置环境变量 zsh用户\necho \u0026#39;export PATH=\u0026#34;/usr/local/anaconda3/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc source ~/.zshrc bash用户\necho \u0026#39;export PATH=\u0026#34;/usr/local/anaconda3/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile source ~/.bash_profile 第三部 验证安装 在终端中输入以下命令，检查安装是否成功：\nconda --version 如果显示conda的版本号，则表示安装成功\n现在您已经在Mac上通过Homebrew安装了Anaconda，并配置了环境变量。 可以开始使用conda命令创建和管理虚拟环境，以及安装Python包了\n","permalink":"https://EitanWong.github.io/en/posts/other/macos%E4%B8%8B%E9%80%9A%E8%BF%87homebrew%E5%AE%89%E8%A3%85anacond%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","summary":"前言💬 前不久重装了macOS的系统，之前配置的环境都没了，这段时间Python用的比较多，所以准备安装配置anaconda进行使用 什么是Anaconda❓ Anaconda是一个数据科学和机器学习的开发环境，包含多种工具和库，可管理和部署数据分析、科学计算和机器学习项目。它包含常用","title":"macOS🍎💻下通过Homebrew🍺安装Anacond🐍并配置环境变量"},{"content":"💬引言 Oh My Zsh 是什么 Oh My Zsh 是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于 zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 Oh My Zsh 是基于 zsh 命令行的一个扩展工具集，提供了丰富的扩展功能。 安装 Oh My Zsh 前提条件：必须已安装 zsh Zsh 是什么 Zsh 是一款强大的虚拟终端，既是一个系统的虚拟终端，也可以作为一个脚本语言的交互解析器。 ⏬安装 第一步，安装 作为 macOS 必备的包管理工具，相信大家肯定已经很熟悉了，没安装的朋友可以执行下面命令装一下，安装过的可以执行下面命令可以进行更新。\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 第二步，更新 zsh、git macOS 一般会自带 zsh，不过版本会比较早，我们先更新一下，以便使用最新特性。\nbrew install zsh 第三步，切换至 zsh 并安装 oh-my-zsh 查看当前使用的 shell\necho $SHELL 💡由于我这里已经是zsh了，其实可以不用切换，但为了写这篇博客，我下面还是演示一下 查看安装的 shell\ncat /etc/shells 切换为 zsh\nchsh -s /bin/zsh 💡我这里已经是zsh了，所以提示no changes made，如果zsh，执行这条命令后，重启终端即可使用 zsh。\n第四步，安装 oh-my-zsh sh -c \u0026#34;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026#34; 安装完成后，终端展示如下内容：\n第五步，配置 oh-my-zsh 看到这里，安装流程已经完毕啦，执行最后的配置，就可以进行体验了。 打开 oh-my-zsh 配置文件\n# 打开 zshrc 文件进行编辑，也可以使用 vim 编辑器 open ~/.zshrc # 本人使用的是 vs code open ~/.zshrc -a Visual\\ Studio\\ Code 主题 配置项 ZSH_THEME 即为 oh-my-zsh 的主题配置，oh-my-zsh 的 GitHub Wiki 页面提供了 当设置为 ZSH_THEME=random 时，每次打开终端都会使用一种随机的主题。 插件\nplugins=(git autojump zsh-autosuggestions zsh-syntax-highlighting) **注意：**其中 zsh-autosuggestions 和 zsh-syntax-highlighting 是自定义安装的插件，需要用 git 将插件 clone 到指定插件目录下：\n# 自动跳转插件 brew install autojump # 自动提示插件 git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions # 语法高亮插件 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 💡如果安装了autojump插件，需要把以下代码加到~/.zshrc文件的尾部\n# 使用brew安装的 [[ -s $(brew --prefix)/etc/profile.d/autojump.sh ]] \u0026amp;\u0026amp; . $(brew --prefix)/etc/profile.d/autojump.sh source $ZSH/oh-my-zsh.sh 需要其他插件的可以自行安装，如果插件未安装，开启终端的时候会报错，按照错误提示，安装对应的插件即可。 如果想要终端更好看的话，可以安装一个neofetch\nbrew install neofetch 安装完成之后，在~/.zshrc尾部写上neofetch 更新配置\nsource ~/.zshrc 更新完配置即可生效，不想更新配置的话，新开一个终端同样可以生效。 经过这一番捣鼓，电脑用起来更加顺手了，可以愉快的开发了。\n","permalink":"https://EitanWong.github.io/en/posts/other/macos-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AE%E7%BB%88%E7%AB%AF%E7%A5%9E%E5%99%A8-oh-my-zsh/","summary":"💬引言 Oh My Zsh 是什么 Oh My Zsh 是一款社区驱动的命令行工具，正如它的主页上说的，Oh My Zsh 是一种生活方式。它基于 zsh 命令行，提供了主题配置，插件机制，已经内置的便捷操作。给我们一种全新的方式使用命令行。 Oh My Zsh 是基于 zsh 命令行的一个扩展工具集，提供了丰富的扩展功能。 安装 Oh My Zsh 前提条件：必须已安装","title":"macOS 🍎💻系统下安装⏬并配置终端神器 oh-my-zsh"},{"content":"如果你使用的是黑苹果 或者像我一样使用老款的MacBookPro(2013) 你也许用了OpenCore Legacy Patcher升级到了最新的系统 但是有些程序需要你关闭SIP保护，可是你已经从白苹果成为黑苹果 在这种情况下你应该如何关闭SIP保护呢？\nSIP Configure设置项 CSR_ALLOW_UNTRUSTED_KEXTS (允许不受信任的内核扩展) 描述：允许从磁盘加载未签名的Kexts Kext Signing 值：0x1 引入于：macOS El Capitan CSR_ALLOW_UNRESTRICTED_FS (允许不受限制的FileSystem) 描述：文件系统访问Filesystem Protections 值：0x2 引入于：macOS El Capitan CSR_ALLOW_TASK_ FOR_ PID (允许特定进程ID执行任务) 描述：不受限制的task_ for_pid()任务 值：0x4 引入于：macOS El Capitan CSR_ALLOW_APPLE_INTERNAL (允许苹果内部功能) 描述：设置Apple内部功能 值：0x10 引入于：macOS El Capitan CSR_ALLOW_UNRESTRICTED_DTRACE (允许不受限制DTRACE) 描述：不受限制的DTrace使用 值：Ox20 引入于：macOS El Capitan CSR_ALLOW_UNRESTRICTED_NVRAM (允许不受限制的NVRAM) 描述：不受限制的NVRAM写入 值：0x40 引入于：macOS Ei Capitan CSR_ALLOW_DEVICE_CONFIGURATION (允许设备配置) 描述：允许自定义设备树 DTrace Restrictions 值：0x80 引入于：macOS El Capitan CSR_ALLOW_ANY_RECOVERY_OS (允许任何恢复操作系统) 描述：跳过基础系统验证BaseSystem Verification 数值：0x100 引入于：macOS Sierra CSR_ALLOW_UNAPPROVED_KEXTS (允许未批准的KEXTS) 描述：允许从磁盘中加载未经验证的Kexts 值：0x200 引入版本：macOS High Sierra CSR_ALLOW_EXECUTABLE_POLICY_OVERRIDE (允许执行策略覆盖) 描述：重写可执行文件策略 值：0x400 引入于：macOS Mojave CSR_ALLOW_UNAUTHENTICATED_ROOT (允许未经身份验证的根用户) 描述：允许根卷宗挂载 值：0x800 引入于：macOS Big Sur 使用以下命令查看SIP\ncsrutil status 对于yabai的安装，根据官方描述 不同的芯片有不同的关闭SIP的方法\n# # APPLE SILICON # # 如果您正在使用苹果芯片 macOS 13.x.x 或 12.x.x # 需要禁用文件系统保护、调试限制和 NVRAM 保护 #（打印的警告可以安全地忽略） csrutil disable --with kext --with dtrace --with basesystem # 1. 重启 # 2. 对于苹果芯片；启用非 Apple 签名的 arm64e 二进制文件 # Open a terminal and run the below command, then reboot sudo nvram boot-args=-arm64e_preview_abi # # INTEL # #如果您使用的是Intel macOS 13.x.x、12.x.x或11.x.x版本， #需要禁用文件系统保护和调试限制（这是一种解决方法，因为--without debug无法正常工作）。 csrutil disable --with kext --with dtrace --with nvram --with basesystem 根据文档描述，需要关闭kext、dtrace、nvram、basesystem 所以如果你使用OpenCore Legacy Patcher安装yabai，需要勾选以下几项\n构建好后，重新安装后，重启即可\n","permalink":"https://EitanWong.github.io/en/posts/other/opencore-legacy-patcher%E5%85%B3%E9%97%ADsip%E4%BF%9D%E6%8A%A4/","summary":"如果你使用的是黑苹果 或者像我一样使用老款的MacBookPro(2013) 你也许用了OpenCore Legacy Patcher升级到了最新的系统 但是有些程序需要你关闭SIP保护，可是你已经从白苹果成为黑苹果 在这种情况下你应该如何关闭SIP保护呢？ SIP Configure设置项 CSR_ALLOW_UNTRUSTED_KEXTS (允许不受信任的","title":"OpenCore Legacy Patcher关闭SIP保护🔒"},{"content":" 这是你MacBook💻 上面安装了很多不同版本的Python🐍 突然有一天，你不想再看见他们🙈 或者是你抛弃了最原始的python🐍，从而投奔anaconda或者pyenv时 你就需要卸载🗑️他们 那么问题来了，如何彻彻底底的卸载它们呢❓\n图形化操作 1、直接在Mac的“程序坞”中，点击“访达”应用程序图标，找到Python的图标，移入废纸篓就可以啦 ⚠️_但这种卸载方式会有残余的垃圾文件📃，需要手👋动删除🗑️_ 2、点击菜单栏“前往\u0026ndash;前往文件夹”/“Go\u0026ndash;Go to Folder\u0026hellip;”，输入/Library/Frameworks/Python.framework/Versions 3、右击“[你对应Python版本]例如:3.8”文件夹，移入废纸篓 4、同样方法删除链接 /usr/local/bin\n命令行操作 删除框架 $ ls /Library/Frameworks/Python.framework/Versions/[Python版本] $ sudo rm -rf /Library/Frameworks/Python.framework/Versions/[Python版本] 删除链接 ls -l /usr/local/bin grep \u0026#39;/Library/Frameworks/Python.framework/Versions/[Python版本]\u0026#39; cd /usr/local/bin/ ls -l /usr/local/bin ｜grep ‘ /Library/Frameworks/Python.framework/Versions/[Python版本] ’ ｜ awk \u0026#39;{print $9}\u0026#39;tr -d @ xargs rm (这里实际操作时提示文件或路径不存在，没有删除成功。 实际通过图形界面移入废纸箱) #删除环境变量(用户目录下) #bash用户 vi ~/.bash_profile #zsh用户 vi ./.zshrc 删除应用 $ sudo rm -rf /Applications/Python/[Python版本] $ sudo rm -rf /Applications/Python/[Python版本] Python2.x存放在/System/Library/Frameworks/Python.framework/Versions目录下\n卸载pip（使用root后可以卸载成功）\nsudo su python -m pip uninstall pip ","permalink":"https://EitanWong.github.io/en/posts/other/%E5%A6%82%E4%BD%95%E5%9C%A8macos%E7%B3%BB%E7%BB%9F%E4%B8%8B%E5%BD%BB%E5%BA%95%E7%9A%84%E5%8D%B8%E8%BD%BD%EF%B8%8Fpython/","summary":"这是你MacBook💻 上面安装了很多不同版本的Python🐍 突然有一天，你不想再看见他们🙈 或者是你抛弃了最原始的python🐍，从而投奔anaconda或者pyenv时 你就需要卸载🗑️他们 那么问题来了，如何彻彻底底的卸载它们呢❓ 图形化操作 1、直接在Mac的“程序坞”中，点击“访达","title":"如何🧐在macOS🍎系统💻下彻底的卸载🗑️Python🐍"},{"content":"🎠Trojan如何绕过🔥GFW🧱 与Shadowsocks相反，🎠Trojan不使用自定义的加密协议来隐藏自身。相反，使用特征明显的TLS协议(TLS/SSL)，使得流量看起来与正常的HTTPS网站相同。TLS是一个成熟的加密体系，HTTPS即使用TLS承载HTTP流量。使用正确配置的加密TLS隧道，可以保证传输的\n☑️保密性（GFW无法得知传输的内容） ☑️完整性（一旦GFW试图篡改传输的密文，通讯双方都会发现） ☑️不可抵赖（GFW无法伪造身份冒充服务端或者客户端） ☑️ 前向安全（即使密钥泄露，GFW也无法解密先前的加密流量） 对于被动检测，🎠Trojan协议流量与HTTPS流量的特征和行为完全一致。而HTTPS流量占据了目前互联网流量的一半以上，且TLS握手成功后流量均为密文，几乎不存在可行方法从其中分辨出🎠Trojan协议流量。 对于主动检测🔍，当🧱防火墙🔥主动连接🎠Trojan服务器进行检测时，🎠Trojan可以正确识别非Trojan协议的流量。与Shadowsocks等代理不同的是，此时🎠Trojan不会断开连接，而是将这个连接代理到一个正常的Web服务器。在GFW看来，该服务器的行为和一个普通的HTTPS网站行为完全相同，无法判断是否是一个🎠Trojan代理节点。这也是🎠Trojan推荐使用合法的域名、使用权威CA签名的HTTPS证书📄的原因: 这让你的服务器完全无法被GFW使用主动检测判定是一个🎠Trojan服务器。\n🔨搭建教程 1、关闭防火墙或放行80、443端口\n关闭防火墙 ufw disable 放行80端口 ufw allow 80 放行443端口 ufw allow 443 2、开启BBR加速\necho \u0026#34;net.core.default_qdisc=fq\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf echo \u0026#34;net.ipv4.tcp_congestion_control=bbr\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf sysctl -p 3、更新软件源\napt update apt upgrade apt full-upgrade 4、安装组件\napt install wget apt install unzip apt install socat 5、创建一个文件夹\nmkdir /etc/trojan-go 6、进入trojan-go文件夹\ncd /etc/trojan-go/ 7、下载trojan-gotrojan-go文档地址：https://github.com/p4gefau1t/trojan-gotrojan-go 完整配置文件地址：https://p4gefau1t.github.io/trojan-go/basic/full-config/ 8、解压trojan-go unzip trojan-go文件 9、创建config.json文件\ntouch config.json 复制如下代码（#和中文说明删掉）\n{ \u0026#34;run_type\u0026#34;: \u0026#34;server\u0026#34;, \u0026#34;local_addr\u0026#34;: \u0026#34;0.0.0.0\u0026#34;, \u0026#34;local_port\u0026#34;: 443, \u0026#34;remote_addr\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;remote_port\u0026#34;: 80, \u0026#34;password\u0026#34;: [ \u0026#34;your_awesome_password\u0026#34; #密码 ], \u0026#34;disable_http_check\u0026#34;: false, \u0026#34;udp_timeout\u0026#34;: 60, \u0026#34;ssl\u0026#34;: { \u0026#34;verify\u0026#34;: true, \u0026#34;verify_hostname\u0026#34;: true, \u0026#34;cert\u0026#34;: \u0026#34;/etc/trojan-go/server.crt\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;/etc/trojan-go/server.key\u0026#34;, \u0026#34;cipher\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;curves\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;prefer_server_cipher\u0026#34;: false, \u0026#34;sni\u0026#34;: \u0026#34;your-domain-name.com\u0026#34;, #你的域名 \u0026#34;alpn\u0026#34;: [ \u0026#34;http/1.1\u0026#34; ], \u0026#34;session_ticket\u0026#34;: true, \u0026#34;reuse_session\u0026#34;: true, \u0026#34;plain_http_response\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;fallback_addr\u0026#34;: \u0026#34;127.0.0.1\u0026#34;, \u0026#34;fallback_port\u0026#34;: 80, \u0026#34;fingerprint\u0026#34;: \u0026#34;firefox\u0026#34; }, \u0026#34;tcp\u0026#34;: { \u0026#34;no_delay\u0026#34;: true, \u0026#34;keep_alive\u0026#34;: true, \u0026#34;prefer_ipv4\u0026#34;: false }, \u0026#34;mux\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;concurrency\u0026#34;: 8, \u0026#34;idle_timeout\u0026#34;: 60 }, \u0026#34;router\u0026#34;: { \u0026#34;enabled\u0026#34;: false, \u0026#34;bypass\u0026#34;: [ ], \u0026#34;proxy\u0026#34;: [ ], \u0026#34;block\u0026#34;: [ ], \u0026#34;default_policy\u0026#34;: \u0026#34;proxy\u0026#34;, \u0026#34;domain_strategy\u0026#34;: \u0026#34;as_is\u0026#34;, \u0026#34;geoip\u0026#34;: \u0026#34;/etc/trojan-go/geoip.dat\u0026#34;, \u0026#34;geosite\u0026#34;: \u0026#34;/etc/trojan-go/geosite.dat\u0026#34; }, \u0026#34;websocket\u0026#34;: { \u0026#34;enabled\u0026#34;: true, \u0026#34;path\u0026#34;: \u0026#34;/ray123\u0026#34;, #路径 \u0026#34;host\u0026#34;: \u0026#34;your-domain-name.com\u0026#34; #你的域名 } } 10、退出trojan-go目录 11、安装acme：\ncurl \u0026lt;https://get.acme.sh\u0026gt; sh 12、添加软链接：\nln -s /root/.acme.sh/acme.sh /usr/local/bin/acme.sh 13、切换CA机构\nacme.sh --set-default-ca --server letsencrypt 14、申请证书： acme.sh --issue -d 你的域名 --standalone -k ec-256 --webroot /home/wwwroot/html 15、安装证书：\nacme.sh --install-cert -d 你的域名 --ecc --key-file /etc/trojan-go/server.key --fullchain-file /etc/trojan-go/server.crt 16、安装Nginx\napt install nginx 17、修改nginx配置文件 配置文件路径：/etc/nginx/nginx.conf 示例关键字：intext:登录 Cloudreve 替换http内容\nhttp { server { listen 80 default_server; listen [::]:80 default_server; server_name your-domain-name.com; #你的域名 location / { proxy_pass \u0026lt;https://www.bing.com\u0026gt;; #伪装网址 proxy_ssl_server_name on; proxy_redirect off; sub_filter_once off; sub_filter \u0026#34;www.bing.com\u0026#34; $server_name; #伪装网址 proxy_set_header Host \u0026#34;www.bing.com\u0026#34;; #伪装网址 proxy_set_header Referer $http_referer; proxy_set_header X-Real-IP $remote_addr; proxy_set_header User-Agent $http_user_agent; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; proxy_set_header Accept-Encoding \u0026#34;\u0026#34;; proxy_set_header Accept-Language \u0026#34;zh-CN\u0026#34;; } } } 18、重新加载nginx\nsystemctl reload nginx 19、查看nginx进程\nsystemctl status nginx.service 20、设置trojan-go开机自启 21、进入/etc/systemd/system文件夹创建trojan-go.service文件\ntouch trojan-go.service 复制如下代码\n[Unit] Description=Trojan-Go - An unidentifiable mechanism that helps you bypass GFW Documentation=https://github.com/p4gefau1t/trojan-go After=network.target nss-lookup.target Wants=network-online.target [Service] Type=simple User=root ExecStart=/etc/trojan-go/trojan-go -config /etc/trojan-go/config.json Restart=on-failure RestartSec=10 RestartPreventExitStatus=23 [Install] WantedBy=multi-user.target 22、重新加载守护进程\nsystemctl daemon-reload 23、设置开机自启\nsystemctl enable trojan-go 24、启动trojan-go\nsystemctl start trojan-go 25、查看trojan-go进程\n","permalink":"https://EitanWong.github.io/en/posts/passgfw/%E6%90%AD%E5%BB%BAtrojan-gotlsws%E7%BB%95%E8%BF%87gfw%E5%AE%A1%E6%9F%A5/","summary":"🎠Trojan如何绕过🔥GFW🧱 与Shadowsocks相反，🎠Trojan不使用自定义的加密协议来隐藏自身。相反，使用特征明显的TLS协议(TLS/SSL)，使得流量看起来与正常的HTTPS网站相同。TLS是一个成熟的加密体系，HTTPS即使用TLS承载HTTP流量。使用正确配","title":"搭建🎠Trojan-go+tls+ws，绕过🔥GFW🧱审查👮"},{"content":" Naive Proxy 👍优点：Naive Proxy的原理和trojan很像，Naive协议消除了客户端的tls指纹和tls-in-tls特征，并且Naive协议基于http2，自带多路复用，对比ws需要频繁握手来讲延迟更低，前面也说过Naive客户端使用chrome浏览器内核作为网络协议栈，从防火墙的角度来看，就像是你在正常的使用正常的谷歌浏览器访问正常的网站\n👎缺点：客户端生态不够完善\nGFW封锁升级：基于TLS的翻墙工具面临挑战，Naive Proxy暂时安全 自北京时间2022年10月3日起，超过一百名用户报告他们至少有一台基于TLS的翻墙服务器被封锁了。被封锁的服务器使用的协议包括了trojan，Xray，V2Ray TLS+Websocket，VLESS，以及gRPC。还未收到任何naiveproxy被封锁的消息。\n封锁先是针对翻墙服务的端口。如果用户在端口被封后，改换了端口，那么整个服务器都会被封锁。需要指出，封锁似乎只是基于端口或IP地址，与翻墙服务有关的域名似乎并没有被加入到GFW的DNS或SNI黑名单中。\n尽管大多数用户报告443端口被封，一部分使用非443端口的用户也报告了封锁。尽管大多数用户的服务器在流行的VPS提供商那里（比如），但至少有一位用户位于欧洲的家中的服务器也被封锁了。\n在一些案例中（并非全部案例中），封锁是动态的：用户通过浏览器还是可以直接访问翻墙端口，但同一个端口，用翻墙软件就连不通。\n所有以上的信息都指向GFW已经可以精准的识别并封锁这些翻墙协议，而并非简单地封锁所有的443端口，或封锁所有的流行机房。\n基于以上信息，我推测（但还未进行实证性的测量），这些封锁可能与翻墙软件客户端发出的Clienthello指纹相关。开发者们或许可以考虑采用uTLS。这个论文阅读小组，这篇总结，以及这篇博文都是关于TLS指纹的，也许会有帮助。\n准备工作 我实验的操作系统是ubuntu22.04 amd64，如果你使用其他操作系统，在搭建过程中如果和视频的预期效果不同，希望你能自行解决，域名要做好了dns解析绑定到了当前VPS的ip地址\n📎相关链接⬇️\nVPS购买搬瓦工：https://bwg.bulianglin.com优惠码： BWH3HYATVBJW\n域名购买namesilo：https://name.bulianglin.com优惠码：oldtong\nSSH工具FinalShell：https://www.hostbuf.com/t/988.html\nv2rayN客户端：https://github.com/2dust/v2rayN\nnaive服务端配置 编译安装caddy+naive： apt install golang-go go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest ~/go/bin/xcaddy build --with github.com/caddyserver/forwardproxy@caddy2=github.com/klzgrad/forwardproxy@naive 如果第二条指令执行出错，可以尝试执行go env -w GO111MODULE=on 再重试，还不行的话请自行搜索升级go版本方法\nvim Caddyfile Caddyfile配置： :443, naive.buliang0.tk #你的域名 tls example@example.com #你的邮箱 route { forward_proxy { basic_auth user pass #用户名和密码 hide_ip hide_via probe_resistance } #支持多用户 forward_proxy { basic_auth user2 pass2 #用户名和密码 hide_ip hide_via probe_resistance } reverse_proxy \u0026lt;https://demo.cloudreve.org\u0026gt; { #伪装网址 header_up Host {upstream_hostport} header_up X-Forwarded-Host {host} } } caddy常用指令： 前台运行caddy：./caddy run后台运行caddy：./caddy start停止caddy：./caddy stop重载配置：./caddy reload\ncaddy配置守护进程（开机自启）：https://github.com/klzgrad/naiveproxy/wiki/Run-Caddy-as-a-daemon\n自定义端口： naive如果要用自定义端口，需要使用json的配置方式，新手可以直接跳过\n启动方式：./caddy start --config config.json\nconfig.json内容：\n//需删除注释内容caddy才能加载 { \u0026#34;apps\u0026#34;: { \u0026#34;http\u0026#34;: { \u0026#34;servers\u0026#34;: { \u0026#34;srv0\u0026#34;: { \u0026#34;listen\u0026#34;: [ \u0026#34;:4431\u0026#34; //监听端口 ], \u0026#34;routes\u0026#34;: [ { \u0026#34;handle\u0026#34;: [ { \u0026#34;auth_user_deprecated\u0026#34;: \u0026#34;user\u0026#34;, //用户名 \u0026#34;auth_pass_deprecated\u0026#34;: \u0026#34;pass\u0026#34;, //密码 \u0026#34;handler\u0026#34;: \u0026#34;forward_proxy\u0026#34;, \u0026#34;hide_ip\u0026#34;: true, \u0026#34;hide_via\u0026#34;: true, \u0026#34;probe_resistance\u0026#34;: {} } ] }, { \u0026#34;handle\u0026#34;: [ { \u0026#34;handler\u0026#34;: \u0026#34;reverse_proxy\u0026#34;, \u0026#34;headers\u0026#34;: { \u0026#34;request\u0026#34;: { \u0026#34;set\u0026#34;: { \u0026#34;Host\u0026#34;: [ \u0026#34;{http.reverse_proxy.upstream.hostport}\u0026#34; ], \u0026#34;X-Forwarded-Host\u0026#34;: [ \u0026#34;{http.request.host}\u0026#34; ] } } }, \u0026#34;transport\u0026#34;: { \u0026#34;protocol\u0026#34;: \u0026#34;http\u0026#34;, \u0026#34;tls\u0026#34;: {} }, \u0026#34;upstreams\u0026#34;: [ { \u0026#34;dial\u0026#34;: \u0026#34;demo.cloudreve.org:443\u0026#34; //伪装网址 } ] } ] } ], \u0026#34;tls_connection_policies\u0026#34;: [ { \u0026#34;match\u0026#34;: { \u0026#34;sni\u0026#34;: [ \u0026#34;naive.buliang0.tk\u0026#34; //域名 ] }, \u0026#34;certificate_selection\u0026#34;: { \u0026#34;any_tag\u0026#34;: [ \u0026#34;cert0\u0026#34; ] } } ], \u0026#34;automatic_https\u0026#34;: { \u0026#34;disable\u0026#34;: true } } } }, \u0026#34;tls\u0026#34;: { \u0026#34;certificates\u0026#34;: { \u0026#34;load_files\u0026#34;: [ { \u0026#34;certificate\u0026#34;: \u0026#34;/root/a.crt\u0026#34;, //公钥路径 \u0026#34;key\u0026#34;: \u0026#34;/root/a.key\u0026#34;, //私钥路径 \u0026#34;tags\u0026#34;: [ \u0026#34;cert0\u0026#34; ] } ] } } } } 客户端配置 naive客户端：https://github.com/klzgrad/naiveproxy/releases/latest\n客户端配置：\n{ \u0026#34;listen\u0026#34;: \u0026#34;socks://127.0.0.1:1080\u0026#34;, \u0026#34;proxy\u0026#34;: \u0026#34;\u0026lt;https://user:pass@example.com\u0026gt;\u0026#34; } 使用v2rayN加载naive内核需要将配置文件的log行删除，否则会断流\nTLS指纹查看 jarm工具：https://github.com/salesforce/jarm\n下载jarm：wget \u0026lt;https://raw.githubusercontent.com/salesforce/jarm/master/jarm.py查看网站jarm指纹：python3\u0026gt; jarm.py naive.buliang0.tk\n网络空间资产搜索引擎：https://fofa.info\n","permalink":"https://EitanWong.github.io/en/posts/passgfw/naive-proxy%E8%8A%82%E7%82%B9%E6%90%AD%E5%BB%BA%E6%B6%88%E9%99%A4tls%E6%8C%87%E7%BA%B9%E4%B8%8Etls-in-tls%E7%89%B9%E5%BE%81%E8%BD%BB%E6%9D%BE%E7%BB%95%E8%BF%87gfw%E5%B0%81%E9%94%81/","summary":"Naive Proxy 👍优点：Naive Proxy的原理和trojan很像，Naive协议消除了客户端的tls指纹和tls-in-tls特征，并且Naive协议基于http2，自带多路复用，对比ws需要频繁握手来讲延迟更低，前面也说过Naive客户端使用chrome浏览器内核作为网络协议栈，从防火","title":"Naive Proxy节点搭建：消除TLS指纹与TLS-in-TLS特征，轻松绕过GFW封锁"},{"content":" 使用X-UI面板搭建vmess+ws+tls+web或者vless+ws+tls+web的节点 这是目前相对安全的搭建方式并且为了更进一步的安全🔐，有些步骤甚至有点繁琐，这都是值得的 只有安全了才能实现省时省心，至于高速稳定只有靠钞💰能力解决了\n作为电信用户的我，刨除高攀不起的专线，\n个人承受范围内最好的线路是CN2 GIA 本教程使用的是 线路，经过了三网优化，电信、移动、联通用户都能获得非常稳定的体验，\n实现全天稳定丝滑的科学上网体验，告别晚高峰拥堵的情况考虑到GIA线路比较贵， 最后给大家提供一种使用x-ui面板通过WS路径分流实现单端口多用户的合租方案，可以和你的朋友合租来分摊费用\nVPS购买 搬瓦工：https://bwg.bulianglin.com 优惠码：BWH3HYATVBJW\n域名购买 namesilo：https://name.bulianglin.com 优惠码：oldtong\nSSH工具 FinalShell：https://www.hostbuf.com/t/988.html\n节点搭建 #更新软件源 apt update #启用 BBR TCP 拥塞控制算法 echo \u0026#34;net.core.default_qdisc=fq\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf echo \u0026#34;net.ipv4.tcp_congestion_control=bbr\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf sysctl -p # 原版或者魔改版二选一即可 #安装原版x-ui： bash \u0026lt;(curl -Ls \u0026lt;https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh\u0026gt;) #X-UI魔改版： wget -N \u0026lt;https://gitlab.com/rwkgyg/x-ui-yg/raw/main/install.sh\u0026gt; \u0026amp;\u0026amp; bash install.sh #安装nginx apt install nginx #安装acme： curl \u0026lt;https://get.acme.sh\u0026gt; sh #添加软链接： ln -s /root/.acme.sh/acme.sh /usr/local/bin/acme.sh #切换CA机构： acme.sh --set-default-ca --server letsencrypt #申请证书： acme.sh --issue -d 你的域名 -k ec-256 --webroot /var/www/html #安装证书： acme.sh --install-cert -d 你的域名 --ecc --key-file /etc/x-ui/server.key --fullchain-file /etc/x-ui/server.crt --reloadcmd \u0026#34;systemctl force-reload nginx\u0026#34; 寻找适合的伪装站 http站点优先，个人网盘符合单节点大流量特征\n示例关键字：intext:登录 Cloudreve\n配置nginx 配置文件路径：/etc/nginx/nginx.conf\nuser www-data; worker_processes auto; pid /run/nginx.pid; include /etc/nginx/modules-enabled/*.conf; events { worker_connections 1024; } http { sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; gzip on; server { listen 443 ssl; server_name nicename.co; #你的域名 ssl_certificate /etc/x-ui/server.crt; #证书位置 ssl_certificate_key /etc/x-ui/server.key; #私钥位置 ssl_session_timeout 1d; ssl_session_cache shared:MozSSL:10m; ssl_session_tickets off; ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers off; location / { proxy_pass \u0026lt;https://bing.com\u0026gt;; #伪装网址 proxy_redirect off; proxy_ssl_server_name on; sub_filter_once off; sub_filter \u0026#34;bing.com\u0026#34; $server_name; proxy_set_header Host \u0026#34;bing.com\u0026#34;; proxy_set_header Referer $http_referer; proxy_set_header X-Real-IP $remote_addr; proxy_set_header User-Agent $http_user_agent; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; proxy_set_header Accept-Encoding \u0026#34;\u0026#34;; proxy_set_header Accept-Language \u0026#34;zh-CN\u0026#34;; } location /ray { #分流路径 proxy_redirect off; proxy_pass \u0026lt;http://127.0.0.1:10000\u0026gt;; #Xray端口 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } location /xui { #xui路径 proxy_redirect off; proxy_pass \u0026lt;http://127.0.0.1:9999\u0026gt;; #xui监听端口 proxy_http_version 1.1; proxy_set_header Host $host; } } server { listen 80; location /.well-known/ { root /var/www/html; } location / { rewrite ^(.*)$ \u0026lt;https://$host$1\u0026gt; permanent; } } } 每次修改nginx配置文件后必须使用 systemctl reload nginx 命令重新加载配置文件\n多用户合租 通过修改nginx的配置文件实现ws path路径分流\nlocation /ray { #分流路径 proxy_redirect off; proxy_pass http://127.0.0.1:10000; #Xray端口 proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \u0026#34;upgrade\u0026#34;; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } ","permalink":"https://EitanWong.github.io/en/posts/passgfw/%E4%BD%BF%E7%94%A8x-ui%E9%9D%A2%E6%9D%BF%E6%90%AD%E5%BB%BAvmesswstlsweb%E8%8A%82%E7%82%B9/","summary":"使用X-UI面板搭建vmess+ws+tls+web或者vless+ws+tls+web的节点 这是目前相对安全的搭建方式并且为了更进一步的安全🔐，有些步骤甚至有点繁琐，这都是值得的 只有安全了才能实现省时省心，至于高速稳定只有靠钞💰能力解决了 作为电信用户的我，刨除高攀不起的专线， 个","title":"使用X-UI面板搭建vmess+ws+tls+web节点🪜"},{"content":"引言 GFW具有重大的社会意义。无论是正面的社会意义，还是负面的意义。无论你是讨厌，还是憎恨。它都在那里。在可以预见的将来，墙还会继续存在。我们要学会如何与其共存。 我们把翻墙看成一场我们与GFW之间的博弈，是一个不断对抗升级的动态过程。目前整体的博弈态势来讲是GFW占了绝对的上风。我们花费了大量的金钱（买VPS买VPN），花费大量时间（学习各种翻墙技术），而GFW只需要简单发几个包，配几个路由规则就可以让你的心血都白费。 GFW并不需要检查所有的上下行流量中是不是有不和谐的内容，很多时候只需要检查连接的前几个包就可以判断出是否要阻断这个连接。为了规避这种检查，我们就需要把所有的流量都通过第三方代理，还要忍受不稳定，速度慢等各种各样的问题。花费的是大量的研究的时间，切换线路的时间，找出是什么导致不能用的时间，当然还有服务器的租用费用和带宽费用。我的感觉是，这就像太极里的四两拨千斤。GFW只需要付出很小的成本，就迫使了我们去付出很大的反封锁成本，而且这种成本好像是越来越高了。 这场博弈的不公平之处在于，GFW拥有国家的资源和专业的团队。而我们做为个体，愿意花费在翻墙上的时间与金钱是非常有限的。在竞争激烈的北上广深，每天辛苦忙碌的白领们。翻墙无非是为了方便自己的工作而已。不可能在每天上下班从拥挤的地铁中挤出来之后再去花费已经少得可怜的业余时间去学习自己不是翻墙根本不需要知道的名词到底是什么意思。于是乎，我们得过且过。不用Google也不会死，对不对？。博弈的天平远远不是平衡的，而是一边倒。\n全面学习GFW GFW会是一个长期的存在。要学会与之共存，必须先了解GFW是什么。做为局外人，学习GFW有六个角度。渐进的来看分别是： 首先我们学习到的是what和when。比如说，你经常听到人的议论是“昨天”，“github”被封了。其中的昨天就是when，github就是what。这是学习GFW的最天然，最朴素的角度。在这个方面做得非常极致的是一个叫做 的网站。这个网站长期监控成千上万个网站和关键词。通过长期监控，不但可以掌握为什么被封锁了，还可以知道什么时候被封的，什么时候被解封的。 接下来的角度是who。比如说，“方校长”这个人名就经常和GFW同时出现。但是如果仅仅是掌握一个两个人名，然后天天在twitter上骂一遍，除了把这个人名骂成名人之外，没有什么特别的积极意义。我们可以通过网络上的公开信息，掌握GFW的哪些方面与哪些人有关系，这些合作者之间又有什么联系。除了大家猜测的将来可以鞭尸之外，对现在也是有积极的意义的。比如关注这些人的研究动态和思想发展，可以猜测GFW的下一步发展方向。比如阅读过去发表的论文，可以了解GFW的技术演进历史，可以从历史中找到一些技术或者管理体制上的缺陷。 再接下来就是why了。github被封之后就常听人说，github这样的技术网站你封它干啥？是什么原因促成了一个网站的被封与解封的？我们做为局外人，真正的原因当然是无从得知的。但是我们可以猜测。基于猜测，可以把不同网站被封，与网络上的舆情时间做关联和分类。我们知道，方校长对于网路舆情监控是有很深入研究的。有一篇论文（Whiskey, Weed, and Wukan on the World Wide Web: On Measuring Censors’ Resources and Motivations）专门讨论监管者的动机的。观测触发被封的事件与实际被封之间的时间关系，也可以推测出一些有趣的现象。比如有人报告，翻墙触发的封端口和封IP这样的事情一般都发生在中国的白天。也就是说，GFW背后不光是机器，有一些组件是血肉构成的。 剩下的两个角度就是对如何翻墙穿墙最有价值的两个角度了：how和where。how是非常好理解的，就是在服务器和客户端两边抓包，看看一个正常的网络通信，GFW做为中间人，分别给两端在什么时候发了什么包或者过滤掉了什么包。而这些GFW做的动作，无论是过滤还是发伪包又是如何干扰客户端与服务器之间的正常通信的。where是在知道了how之后的进一步发展，不但要了解客户端与服务器这两端的情况，更要了解GFW是挂在两端中间的哪一级路由器上做干扰的。在了解到GFW的关联路由器的IP的基础上，可以根据不同的干扰行为，不同的运营商归属做分组，进一步了解GFW的整体部署情况。 整体上来说，对GFW的研究都是从what和when开始，让偏人文的就去研究who和why，像我们这样偏工程的就会去研究how和where。以上就是全面了解GFW的主体脉络。接下来，我们就要以how和where这两个角度去看一看GFW的原理。\nGFW的原理 要与GFW对抗不能仅仅停留在什么不能访问了，什么可以访问之类的表面现象上。知道youtube不能访问了，对于翻墙来说并无帮助。但是知道GFW是如何让我们不能访问youtube的，则对下一步的翻墙方案的选择和实施具有重大意义。所以在讨论如何翻之前，先要深入原理了解GFW是如何封的。 总的来说，GFW是一个分布式的入侵检测系统，并不是一个严格意义上的防火墙。不是说每个出入国境的IP包都需要先经过GFW的首可。做为一个入侵检测系统，GFW把你每一次访问facebook都看做一次入侵，然后在检测到入侵之后采取应对措施，也就是常见的连接重置。整个过程一般话来说就是：\n检测有两种方式。一种是人工检测，一种是机器检测。你去国新办网站举报，就是参与了人工检测。在人工检测到不和谐的网站之后，就会采取一些应对方式来防止国内的网民访问该网站。对于这类的封锁，规避检测就不是技术问题了，只能从GFW采取的应对方式上采取反制措施。另外一类检测是机器检测，其检测过程又可以再进一步细分：\n重建 重建是指GFW从网络上监听过往的IP包，然后分析其中的TCP协议，最后重建出一个完整的字节流。分析是在这个重建的字节流上分析具体的应用协议，比如HTTP协议。然后在应用协议中查找是不是有不和谐的内容，然后决定采用何种应对方式。 所以，GFW机器检测的第一步就是重建出一个字节流。那么GFW是如何拿到原始的IP包的呢？真正的GFW部署方式，外人根本无从得知。据猜测，GFW是部署在国家的出口路由器的旁路上，用“分光”的方式把IP包复制一份到另外一根光纤上，从而拿到所有进出国境的IP包。\nGFW通过配置骨干网的BGP路由规则，是可以让国内机房的流量经过它。一个例子是当我们访问被封的网站触发连接重置的时候，往往收到两个RST包，但是TTL不同。还有一个例子是对于被封的IP，访问的IP包还没有到达国际出口就已经被丢弃。所以GFW应该在其他地方也部署有设备，据推测是在省级骨干路由的位置。 对于GFW到底在哪这个话题，最近又有国外友人表达了兴趣（ https://github.com/mothran/mongol）。其原理是基于一个IP协议的特性叫TTL。TTL是Time to Live的简写。IP包在没经过一次路由的时候，路由器都会把IP包的TTL减去1。如果TTL到零了，路由器就不会再把IP包发给下一级路由。然后我们知道GFW会在监听到不和谐的IP包之后发回RST包来重置TCP连接。那么通过设置不同的TTL就可以知道从你的电脑，到GFW之间经过了几个路由器。比如说TTL设置成9不触发RST，但是10就触发RST，那么到GFW就是经过了10个路由器。另外一个IP协议的特性是当TTL耗尽的时候，路由器应该发回一个TTL EXCEEDED的ICMP包，并把自己的IP地址设置成SRC（来源）。结合这两点，就可以探测出IP包是到了IP地址为什么的路由器之后才被GFW检测到。有了IP地址之后，再结合IP地址地理位置的数据库就可以知道其地理位置。据说，得出的位置大概是这样的：\n但是这里检测出来的IP到底是GFW的还是骨干路由器的？更有可能的是骨干路由器的IP。GFW做为一个设备用“分光”的方式挂在主干路由器旁边做入侵检测。无论如何，GFW通过某种神奇的方式，可以拿到你和国外服务器之间来往的所有的IP包，这点是肯定的。更严谨的理论研究有： GFW在拥有了这些IP包之后，要做一个艰难的决定，那就是到底要不要让你和服务器之间的通信继续下去。GFW不能太过于激进，毕竟全国性的不能访问国外的网站是违反GFW自身存在价值的。GFW就需要在理解了IP包背后代表的含义之后，再来决定是不是可以安全的阻断你和国外服务器之间的连接。这种理解就要建立了前面说的“重建”这一步的基础上。大概用图表达一下重建是在怎么一回事：\n重建这样的字节流有一个难点是如何处理巨大的流量？其原理与网站的负载均衡器一样。对于给定的来源和目标，使用一个HASH算法取得一个节点值，然后把所有符合这个来源和目标的流量都往这个节点发。所以在一个节点上就可以重建一个TCP会话的单向字节流。 最后为了讨论完整，再提两点。虽然GFW的重建发生在旁路上是基于分光来实现的，但并不代表整个GFW的所有设备都在旁路。后面会提到有一些GFW应对形式必须是把一些GFW的设备部署在了主干路由上，也就是GFW是要参与部分IP的路由工作的。另外一点是，重建是单向的TCP流，也就是GFW根本不在乎双向的对话内容，它只根据监听到的一个方向的内容然后做判断。但是监听本身是双向的，也就是无论是从国内发到国外，还是从国外发到国内，都会被重建然后加以分析。所以一个TCP连接对于GFW来说会被重建成两个字节流。具体的证据会在后面谈如何直穿GFW中详细讲解。\n分析 分析是GFW在重建出字节流之后要做的第二步。对于重建来说，GFW主要处理IP协议，以及上一层的TCP和UDP协议就可以了。但是对于分析来说，GFW就需要理解各种各样的应用层的稀奇古怪的协议了。甚至，我们也可以自己发明新的协议。 总的来说，GFW做协议分析有两个相似，但是不同的目的。第一个目的是防止不和谐内容的传播，第二个目的是防止使用翻墙工具绕过GFW的审查。下面列举一些已知的GFW能够处理的协议。 对于GFW具体是怎么达到目的一，也就是防止不和谐内容传播的就牵涉到对HTTP协议和DNS协议等几个协议的明文审查。大体的做法是这样的:\n像HTTP这样的协议会有非常明显的特征供检测，所以第一步就没什么好说的了。当GFW发现了包是HTTP的包之后就会按照HTTP的协议规则拆包。这个拆包过程是GFW按照它对于协议的理解来做的。比如说，从HTTP的GET请求中取得请求的URL。然后GFW拿到这个请求的URL去与关键字做匹配，比如查找Twitter是否在请求的URL中。为什么有拆包这个过程？首先，拆包之后可以更精确的打击，防止误杀。另外可能预先做拆包，比全文匹配更节省资源。其次，GFW还是先去理解协议，然后才做关键字匹配的。关键字匹配应该就是使用了一些高效的正则表达式算法，没有什么可以讨论的。 HTTP代理和SOCKS代理，这两种明文的代理都可以被GFW识别。之前笔者认为GFW可以在识别到HTTP代理和SOCKS代理之后，再拆解其内部的HTTP协议的正文。也就是做两次拆包。但是分析发现，HTTP代理的关键字列表和HTTP的关键字列表是不一样的，所以笔者现在认为HTTP代理协议和SOCKS代理协议是当作单独的协议来处理的，并不是拆出载荷的HTTP请求再进行分析的。 目前已知的GFW会做的协议分析如下：\nDNS 查询 GFW可以分析53端口的UDP协议的DNS查询。如果查询的域名匹配关键字则会被DNS劫持。可以肯定的是，这个匹配过程使用的是类似正则的机制，而不仅仅是一个黑名单，因为子域名实在太多了。证据是：2012年11月9日下午3点半开始，防火长城对Google的泛域名 .google.com 进行了大面积的污染，所有以 google.com 结尾的域名均遭到污染而解析错误不能正常访问，其中甚至包括不存在的域名。 目前为止53端口之外的查询也没有被劫持。但是TCP的DNS查询已经可以被TCP RST切断了，表明了GFW具有这样的能力，只是不屑于大规模部署。而且TCP查询的关键字比UDP劫持的域名要少的多。\nHTTP 请求 GFW可以识别出HTTP协议，并且检查GET的URL与HOST。如果匹配了关键字则会触发TCP RST阻断。\nHTTP 响应 GFW除了会分析上行的HTTP GET请求，对于HTTP返回的内容也会做全文关键字检查。这种检查与对请求的关键字检查不是由同一设备完成的，而且对GFW的资源消耗也更大。\nHTTP代理协议 略\nSOCKS4/5代理协议 略\nSMTP 协议 因为有很多翻墙软件都是以邮件索取下载地址的方式发布的，所以GFW有针对性的封锁了SMTP协议，阻止这样的邮件往来。 封锁有三种表现方式，简单概要的说就是看邮件是不是发往上了黑名单的邮件地址的，如果发现了就立马用TCP RST包切断连接。\n发现发件人在黑名单中，立即重置TCP链接\nfrom scapy.all import * send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;S\u0026#39;, seq=0)) send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;A\u0026#39;, seq=1)) send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;A\u0026#39;, seq=1) / \u0026#39;MAIL FROM: xiazai@upup.info\\r\\n\u0026#39;) 看似普通的三个包其实暗藏玄机。首先，目标地址是1.2.3.4，这显然是我胡写的一个地址，而且TTL设置为9。所以这个包发出去就没有打算让最终的目标机器接到，而只是发给GFW看的。这个TTL值要大于你的机器到GFW的跳数，一般11是一个保险的值。\n然后要触发GFW的响应，有以下几个缺一不可的条件:\n目标端口是25，我尝试了其他几个端口没有发现触发响应。 第二个包虽然内容是空的，但是必须存在。而且必须是ACK。内容也可以不为空，GFW似乎不care内容是什么，只要有这个包就可以。 第三个包的seq必须为1，哪怕第二包有内容了，这个包的seq也必须为1。而且MAIL FROM: \\r\\n这个格式必须对，不能替换成FROM MAIL啥的。还有一个条件就是邮件地址必须上了黑名单。这里举的例子是一个翻墙软件的索取地址，所以上了黑名单。 观测到的响应是GFW发一个TCP RST包。而且每次都是一个，从来不多发。如果少了中间那个空的ACK，则是连做两次探测触发一个TCP RST。貌似GFW把两次探测认为是一个连接了。\n发现收件人在黑名单中，立即重置TCP链接 from scapy.all import * send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;S\u0026#39;, seq=0)) send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;A\u0026#39;, seq=1)) send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;A\u0026#39;, seq=1) / \u0026#39;RCPT TO: xiazai@upup.info\\r\\n\u0026#39;) 这与上面的MAIL FROM的例子基本上是一样的。不同之处只有一点就是有的时候可以看到两个TCP RST的回包。\n发现收件人在黑名单中，发回用户不存在的错误消息 from scapy.all import * send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;S\u0026#39;, seq=0)) send(IP(dst=\u0026#39;1.2.3.4\u0026#39;, ttl=9) / TCP(dport=25, flags=\u0026#39;A\u0026#39;, seq=1) / \u0026#39;EHLO anything-here\\nRCPT TO: xiazai@upup.info\\n\u0026#39;) 得到的错误消息是 “551 User not local; please try \\r\\n”。有的时候还会伴随有数个连续的TCP RST。同样因为包根本没有到对方的服务器，而且这个服务器压根就不存在，所以这个用户不存在的错误消息只能是GFW做出的响应。 触发的条件是\n目标端口必须是25 第二个包的第一个命令必须是EHLO或者HELO，内容没有关系 第二个包的第二个命令必须是RCPT TO，而且邮件地址要在黑名单中。 \\r\\n没有关系，\\n也是可以触发的 这次触发的条件是一个合法的SMTP请求过程。而之前的触发过程根本就不是合法的SMTP请求。而且另外一个特征是这样触发的TCP RST，会有三个重叠，ack递加的现象，与HTTP全文关键字的响应非常类似。我推测，两型的响应是两个不同的模块。单独对MAIL FROM和RCPT TO的封锁，与对HTTP关键字的封锁类似，属于看到就封型。而后一种更智能的，还会回答错误消息的是能够真正理解SMTP协议的模块，可能还用于做邮件全文内容的关键字检测。\n电驴(ed2k)协议 GFW还会过滤电驴（ed2k）协议中的查询内容。因为ed2k还有一个混淆模式，会加密往来的数据包，GFW会切断所有使用混淆模式的ed2k连接，迫使客户端使用明文与服务器通讯。然后如果客户端发起了搜索请求，查找的关键字中包含敏感词的话就会被用TCP RST包切断连接。\n对翻墙流量的分析识别 GFW的第二个目的是封杀翻墙软件。为了达到这个目的GFW采取的手段更加暴力。原因简单，对于HTTP协议的封杀如果做不好会影响互联网的正常运作，GFW与互联网是共生的关系，它不会做威胁自己存在的事情。但是对于TOR这样的几乎纯粹是为翻墙而存在的协议，只要检测出来就是格杀勿论的了。GFW具体是如何封杀各种翻墙协议的，我也不是很清楚，事态仍然在不断更新中。但是举两个例子来证明GFW的高超技术。 第一个例子是GFW对TOR的自动封杀，体现了GFW尽最大努力去理解协议本身。根据这篇博客（ \u0026laquo;https://blog.torproject.org/blog/knock-knock-knockin-bridges-doors\u003e \u0026gt;）。使用中国的IP去连接一个美国的TOR网桥，会被GFW发现。然后GFW回头（15分钟之后）会亲自假装成客户端，用TOR的协议去连接那个网桥。如果确认是TOR的网桥，则会封当时的那个端口。换了端口之后，可以用一段时间，然后又会被封。这表现出了GFW对于协议的高超检测能力，可以从国际出口的流量中敏锐地发现你连接的TOR网桥。据TOR的同志说是因为TOR协议中的握手过程具有太明显的特征了。另外一点就表现了GFW的不辞辛劳，居然会自己伪装成客户端过去连连看。 第二个例子表现了GFW根本不在乎加密的流量中的具体内容是不是有敏感词。只要疑似翻墙，特别是提供商业服务给多个翻墙，就会被封杀。使用ShadowSocks协议, 预先部署密钥，没有明显的握手过程仍然被封。据说是GFW已经升级为能够机器识别出哪些加密的流量是疑似翻墙服务的。 总结起来就是，GFW已经基本上完成了目的一的所有工作。明文的协议从HTTP到SMTP都可以分析然后关键字检测，甚至电驴这样不是那么大众的协议GFW都去搞了。从原理上来说也没有什么好研究的，就是明文，拆包，关键字。GFW显然近期的工作重心在分析网络流量上，从中识别出哪些是翻墙的流量。这方面的研究还比较少，而且一个显著的特征是自己用没关系，大规模部署就容易出问题。我目前没有在GFW是如何封翻墙工具上有太多研究，只能是道听途说了。\n应对 GFW的应对措施是三步中最明显的，因为它最直接。GFW的重建过程和协议分析的过程需要耐心的试探才能大概推测出GFW是怎么实现的。但是GFW的应对手段我们每天都可以见到，比如连接重置。GFW的应对目前可以感受到的只有一个目的就是阻断。但是从广义上来说，应对方式应该不限于阻断。比如说记录下日志，然后做统计分析，秋后算账什么的也可以算是一种应对。就阻断方式而言，其实并不多，那么我们一个个来列举吧。\n封IP 一般常见于人工检测之后的应对。还没有听说有什么方式可以直接使得GFW的机器检测直接封IP。一般常见的现象是GFW机器检测，然后用TCP RST重置来应对。过了一段时间才会被封IP，而且没有明显的时间规律。所以我的推测是，全局性的封IP应该是一种需要人工介入的。注意我强调了全局性的封IP，与之相对的是部分封IP，比如只对你访问那个IP封个3分钟，但是别人还是可以访问这样的。这是一种完全不同的封锁方式，虽然现象差不多，都是ping也ping不通。要观摩的话ping twitter.com就可以了，都封了好久了。 其实现方式是把无效的路由黑洞加入到主干路由器的路由表中，然后让这些主干网上的路由器去帮GFW把到指定IP的包给丢弃掉。路由器的路由表是动态更新的，使用的协议是BGP协议。GFW只需要维护一个被封的IP列表，然后用BGP协议广播出去就好了。然后国内主干网上的路由器都好像变成了GFW的一份子那样，成为了帮凶。\n如果我们使用traceroute去检查这种被全局封锁的IP就可以发现，IP包还没有到GFW所在的国际出口就已经被运营商的路由器给丢弃了。这就是BGP广播的作用了。\nDNS劫持 这也是一种常见的人工检测之后的应对。人工发现一个不和谐网站，然后就把这个网站的域名给加到劫持列表中。其原理是基于DNS与IP协议的弱点，DNS与IP这两个协议都不验证服务器的权威性，而且DNS客户端会盲目地相信第一个收到的答案。所以你去查询facebook.com的话，GFW只要在正确的答案被返回之前抢答了，然后伪装成你查询的DNS服务器向你发错误的答案就可以了。\n下图为GFW对域名telegram.org的劫持：\n可见许多地区的IP被解析到Twitter和Facebook等已被封锁的IP上。\nTCP RST阻断 TCP协议规定，只要看到RST包，连接立马被中断。从浏览器里来看就是连接已经被重置。我想对于这个错误大家都不陌生。据我个人观感，这种封锁方式是GFW目前的主要应对手段。大部分的RST是条件触发的，比如URL中包含某些关键字。还有一些网站，会被无条件RST。也就是针对特定的IP和端口，无论包的内容就会触发RST。比较著名的例子是https的wikipedia。GFW在TCP层的应对是利用了IPv4协议的弱点，也就是只要你在网络上，就假装成任何人发包。所以GFW可以很轻易地让你相信RST确实是Google发的，而让Google相信RST是你发的。\n封端口 GFW除了自身主体是挂在骨干路由器旁路上的入侵检测设备，利用分光技术从这个骨干路由器抓包下来做入侵检测 (所谓 IDS)，除此之外这个路由器还会被用来封端口 (所谓 IPS)。GFW在检测到入侵之后可以不仅仅可以用TCP RST阻断当前这个连接，而且利用骨干路由器还可以对指定的IP或者端口进行从封端口到封IP，设置选择性丢包的各种封禁措施。可以理解为骨干路由器上具有了类似“iptables”的能力（网络层和传输层的实时拆包，匹配规则的能力）。这个iptables的能力在CISCO路由器上叫做ACL Based Forwarding (ABF)。而且规则的部署是全国同步的，一台路由器封了你的端口，全国的挂了GFW的骨干路由器都会封。一般这种封端口都是针对翻墙服务器的，如果检测到服务器是用SSH或者VPN等方式提供翻墙服务。GFW会在全国的出口骨干路由上部署这样的一条ACL规则，来封你这个服务器+端口的下行数据包。也就是如果包是从国外发向国内的，而且src（源ip）是被封的服务器ip，sport（源端口）是被封的端口，那么这个包就会被过滤掉。这样部署的规则的特点是，上行的数据包是可以被服务器收到的，而下行的数据包会被过滤掉。 如果被封端口之后服务器采取更换端口的应对措施，很快会再次被封。而且多次尝试之后会被封IP。初步推断是，封端口不是GFW的自动应对行为，而是采取黑名单加人工过滤地方式实现的。一个推断的理由就是网友报道，封端口都是发生在白天工作时间。 在进入了封端口阶段之后，还会有继发性的临时性封其他端口的现象，但是这些继发性的封锁具有明显的超时时间，触发了之后（触发条件不是非常明确）会立即被封锁，然后过了一段时间就自动解封。\nHTTPS间歇性丢包 对于Github的HTTPS服务，GFW不愿意让其完全不能访问。所以采取的办法是对于Github的某些IP的443端口采取间歇性丢包的措施。其原理应该类似于封端口，是在骨干路由器上做的丢包动作。但是触发条件并不只是看IP和端口，加上了时间间隔这样一个条件。\n翻墙原理 前面从原理上讲解了GFW的运作原理。翻墙的原理与之相对应，分为两大类。第一类是大家普遍的使用的绕道的方式。IP包经由第三方中转已加密的形式通过GFW的检查。这样的一种做法更像“翻”墙，是从墙外绕过去的。第二类是找出GFW检测过程的中一些BUG，利用这些BUG让GFW无法知道准确的会话内容从而放行。这种做法更像“穿”墙。曾经引起一时轰动的西厢计划第一季就是基于这种方式的实现。 基于绕道法的翻墙方式无论是VPN还是代理，原理都是类似的。都是以国外有一个代理服务器为前提，然后你与代理服务器通信，代理服务器再与目标服务器通信。\n绕道法对于IP封锁来说，因为最终的IP包是由代理服务器在墙外发出的，所以国内骨干路由封IP并不会产生影响。对于TCP重置来说，因为TCP重置是以入侵检测为前提的，客户端与代理之间的加密通信规避了入侵检测，使得TCP重置不会被触发。 但是对于反DNS污染来说，VPN和代理代理却有不同。基于VPN的翻墙方法，得到正确的DNS解析的结果需要设置一个国外的没有被污染的DNS服务器。然后发UDP请求去解析域名的时候，VPN会用绕道的方式让UDP请求不被劫持地通过GFW。\n但是SOCKS代理和HTTP代理这些更上层的代理协议则可以选择不同的方式。因为代理与应用之间有更紧密的关系，应用程序比如浏览器可以把要访问的服务器的域名直接告诉本地的代理。然后SOCKS代理可以选择不在本地做解析，直接把请求发给墙外的代理服务器。在代理服务器去与目标服务器做连接的时候再在代理服务器上做DNS解析，从而避开了GFW的DNS劫持。\nVPN与代理的另外一个主要区别是应用程序是如何使用上代理去访问国外的服务器的。先来看不加代理的时候，应用程序是如何访问网络的。\n应用程序把IP包交给操作系统，操作系统会去决定把包用机器上的哪块网卡发出去。VPN的客户端对于操作系统来说就是一个虚拟出来的网卡。应用程序完全不用知道VPN客户端的存在，操作系统甚至也不需要区分VPN客户端与普通网卡的区别。\nVPN客户端在启动之后会把操作系统的缺省路由改成自己。这样所有的IP包都会经由这块虚拟的网卡发出去。这样VPN就能够再打包成加密的流量发出去（当然线路还是之前的线路），发回去的加密流量再解密拆包交还给操作系统。 应用层的代理则不同。其流量走不走代理的线路并不是由操作系统使用路由表选择网卡来决定的，而是在应用程序里自己做的。也就是说，对于操作系统来说，使用代理的TCP连接和不使用代理的TCP连接并没有任何的不同。应用程序自己去选择是直接与目标服务器建立连接，还是与代理服务器建立TCP连接，然后由SOCKS代理服务器去建立第二个TCP连接，两个TCP连接的数据由代理服务器中转。\n绕道法的翻墙原理就是这些了，相对来说非常简单。其针对的都是GFW的分析那一步，通过加密使得GFW无法分析出流量的原文从而让GFW放行。但是GFW最近的升级表明，GFW虽然无法解密这些加密的流量，但是GFW可以结合流量与其他协议特征探测出这些流量是不是“翻墙”的，然后就直接暴力的切断。绕道法的下一步发展就是要从原理弄明白，GFW是如何分析出翻墙流量的，从而要么降低自身的流量特征避免上短名单被协议分析，或者通过混淆协议把自己伪装成其他的无害流量。\n穿墙原理 DNS劫持观测 我们要做的第一个实验是用python代码观测到DNS劫持的全过程。\n应用层观测 dig是DNS的客户端，可以很方便地构造出我们想要的DNS请求。 dig @8.8.8.8 twitter.com 。可以得到相应如下：\n; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 5494 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;twitter.com. IN A ;; ANSWER SECTION: twitter.com. 4666 IN A 59.24.3.173 ;; Query time: 110 msec ;; SERVER: 8.8.8.8#53(8.8.8.8) ;; WHEN: Sun Jan 13 13:22:10 2013 ;; MSG SIZE rcvd: 45 可以很清楚地看到我们得到的错误答案59.24.3.173。\n抓包观测 使用iptables我们可以让特定的IP包经过应用层的代码，从而使得我们用python观测DNS查询过程提供了可能。代码如下:\nfrom netfilterqueue import NetfilterQueue import subprocess import signal def observe_dns_hijacking(nfqueue_element): print(\u0026#39;packet past through me\u0026#39;) nfqueue_element.accept() nfqueue = NetfilterQueue() nfqueue.bind(0, observe_dns_hijacking) def clean_up(*args): subprocess.call(\u0026#39;iptables -D OUTPUT -p udp --dst 8.8.8.8 -j QUEUE\u0026#39;, shell=True) subprocess.call(\u0026#39;iptables -D INPUT -p udp --src 8.8.8.8 -j QUEUE\u0026#39;, shell=True) signal.signal(signal.SIGINT, clean_up) try: subprocess.call(\u0026#39;iptables -I INPUT -p udp --src 8.8.8.8 -j QUEUE\u0026#39;, shell=True) subprocess.call(\u0026#39;iptables -I OUTPUT -p udp --dst 8.8.8.8 -j QUEUE\u0026#39;, shell=True) print(\u0026#39;running..\u0026#39;) nfqueue.run() except KeyboardInterrupt: print(\u0026#39;bye\u0026#39;) 执行此脚本，再使用dig @8.8.8.8 twitter.com应该可以看到package past through me。这就说明DNS的请求和答案都经过了python代码了。 上一步主要是验证NetfilterQueue是不是工作正常。这一步则要靠dpkt的了。代码如下：\nfrom netfilterqueue import NetfilterQueue import subprocess import signal import dpkt import traceback import socket def observe_dns_hijacking(nfqueue_element): try: ip_packet = dpkt.ip.IP(nfqueue_element.get_payload()) dns_packet = dpkt.dns.DNS(ip_packet.udp.data) print(repr(dns_packet)) for answer in dns_packet.an: print(socket.inet_ntoa(answer[\u0026#39;rdata\u0026#39;])) nfqueue_element.accept() except: traceback.print_exc() nfqueue_element.accept() nfqueue = NetfilterQueue() nfqueue.bind(0, observe_dns_hijacking) def clean_up(*args): subprocess.call(\u0026#39;iptables -D OUTPUT -p udp --dst 8.8.8.8 -j QUEUE\u0026#39;, shell=True) subprocess.call(\u0026#39;iptables -D INPUT -p udp --src 8.8.8.8 -j QUEUE\u0026#39;, shell=True) signal.signal(signal.SIGINT, clean_up) try: subprocess.call(\u0026#39;iptables -I INPUT -p udp --src 8.8.8.8 -j QUEUE\u0026#39;, shell=True) subprocess.call(\u0026#39;iptables -I OUTPUT -p udp --dst 8.8.8.8 -j QUEUE\u0026#39;, shell=True) print(\u0026#39;running..\u0026#39;) nfqueue.run() except KeyboardInterrupt: print(\u0026#39;bye\u0026#39;) 执行此脚本，再使用dig @8.8.8.8 twitter.com应该可以看到类似如下的输出：\nDNS(ar=[RR(type=41, cls=4096)], qd=[Q(name=\u0026#39;twitter.com\u0026#39;)], id=8613, op=288) DNS(an=[RR(name=\u0026#39;twitter.com\u0026#39;, rdata=\u0026#39;;\\x18\\x03\\xad\u0026#39;, ttl=19150)], qd=[Q(name=\u0026#39;twitter.com\u0026#39;)], id=8613, op=33152) .24.3.173 DNS(an=[RR(name=\u0026#39;twitter.com\u0026#39;, rdata=\u0026#39;\\xc7;\\x95\\xe6\u0026#39;, ttl=27), RR(name=\u0026#39;twitter.com\u0026#39;, rdata=\u0026#39;\\xc7;\\x96\\x07\u0026#39;, ttl=27), RR(name=\u0026#39;twitter.com\u0026#39;, rdata=\u0026#34;\\xc7;\\x96\u0026#39;\u0026#34;, ttl=27)], ar=[RR(type=41, cls=512)], qd=[Q(name=\u0026#39;twitter.com\u0026#39;)], id=8613, op=33152) .59.149.230 .59.150.7 .59.150.39 可以看到我们发出去了一个包，收到了两个包。其中第一个收到的包是GFW发回来的错误答案，第二个包才是正确的答案。但是由于dig只取第一个返回的答案，所以我们实际看到的解析结果是错误的。\n观测劫持发生的位置 利用IP包的TTL特性，我们可以把TTL值从1开始递增，直到我们收到错误的应答为止。结合TTL EXECEEDED ICMP返回的IP地址，就可以知道DNS请求是在第几跳的路由器分光给GFW的。代码如下:\nfrom netfilterqueue import NetfilterQueue import subprocess import signal import dpkt import traceback import socket import sys DNS_IP = \u0026#39;8.8.8.8\u0026#39; # source http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93 WRONG_ANSWERS = { \u0026#39;4.36.66.178\u0026#39;, \u0026#39;8.7.198.45\u0026#39;, \u0026#39;37.61.54.158\u0026#39;, \u0026#39;46.82.174.68\u0026#39;, \u0026#39;59.24.3.173\u0026#39;, \u0026#39;64.33.88.161\u0026#39;, \u0026#39;64.33.99.47\u0026#39;, \u0026#39;64.66.163.251\u0026#39;, \u0026#39;65.104.202.252\u0026#39;, \u0026#39;65.160.219.113\u0026#39;, \u0026#39;66.45.252.237\u0026#39;, \u0026#39;72.14.205.99\u0026#39;, \u0026#39;72.14.205.104\u0026#39;, \u0026#39;78.16.49.15\u0026#39;, \u0026#39;93.46.8.89\u0026#39;, \u0026#39;128.121.126.139\u0026#39;, \u0026#39;159.106.121.75\u0026#39;, \u0026#39;169.132.13.103\u0026#39;, \u0026#39;192.67.198.6\u0026#39;, \u0026#39;202.106.1.2\u0026#39;, \u0026#39;202.181.7.85\u0026#39;, \u0026#39;203.161.230.171\u0026#39;, \u0026#39;207.12.88.98\u0026#39;, \u0026#39;208.56.31.43\u0026#39;, \u0026#39;209.36.73.33\u0026#39;, \u0026#39;209.145.54.50\u0026#39;, \u0026#39;209.220.30.174\u0026#39;, \u0026#39;211.94.66.147\u0026#39;, \u0026#39;213.169.251.35\u0026#39;, \u0026#39;216.221.188.182\u0026#39;, \u0026#39;216.234.179.13\u0026#39; } current_ttl = 1 def locate_dns_hijacking(nfqueue_element): global current_ttl try: ip_packet = dpkt.ip.IP(nfqueue_element.get_payload()) if dpkt.ip.IP_PROTO_ICMP == ip_packet[\u0026#39;p\u0026#39;]: print(socket.inet_ntoa(ip_packet.src)) elif dpkt.ip.IP_PROTO_UDP == ip_packet[\u0026#39;p\u0026#39;]: if DNS_IP == socket.inet_ntoa(ip_packet.dst): ip_packet.ttl = current_ttl current_ttl += 1 ip_packet.sum = 0 nfqueue_element.set_payload(str(ip_packet)) else: if contains_wrong_answer(dpkt.dns.DNS(ip_packet.udp.data)): sys.stdout.write(\u0026#39;* \u0026#39;) sys.stdout.flush() nfqueue_element.drop() return else: print(\u0026#39;END\u0026#39;) nfqueue_element.accept() except: traceback.print_exc() nfqueue_element.accept() def contains_wrong_answer(dns_packet): for answer in dns_packet.an: if socket.inet_ntoa(answer[\u0026#39;rdata\u0026#39;]) in WRONG_ANSWERS: return True return False nfqueue = NetfilterQueue() nfqueue.bind(0, locate_dns_hijacking) def clean_up(*args): subprocess.call(\u0026#39;iptables -D OUTPUT -p udp --dst %s -j QUEUE\u0026#39; % DNS_IP, shell=True) subprocess.call(\u0026#39;iptables -D INPUT -p udp --src %s -j QUEUE\u0026#39; % DNS_IP, shell=True) subprocess.call(\u0026#39;iptables -D INPUT -p icmp -m icmp --icmp-type 11 -j QUEUE\u0026#39;, shell=True) signal.signal(signal.SIGINT, clean_up) try: subprocess.call(\u0026#39;iptables -I INPUT -p icmp -m icmp --icmp-type 11 -j QUEUE\u0026#39;, shell=True) subprocess.call(\u0026#39;iptables -I INPUT -p udp --src %s -j QUEUE\u0026#39; % DNS_IP, shell=True) subprocess.call(\u0026#39;iptables -I OUTPUT -p udp --dst %s -j QUEUE\u0026#39; % DNS_IP, shell=True) print(\u0026#39;running..\u0026#39;) nfqueue.run() except KeyboardInterrupt: print(\u0026#39;bye\u0026#39;) 执行 dig +tries=30 +time=1 @8.8.8.8 twitter.com 可以得到类似下面的输出：\n.158.100.166 .158.11.150 * 219.158.97.30 * * 219.158.27.30 * 72.14.215.130 * 209.85.248.60 * 216.239.43.19 * * END 出现*号前面的那个IP就是挂了GFW的路由了。脚本只能执行一次，第二次需要重启。另外同一个DNS不能被同时查询，把8.8.8.8改成你没有在用的DNS。这个脚本的一个“副作用”就是dig返回的答案是正确的了，因为错误的答案被丢弃了。\n反向观测 前面我们已经知道从国内请求国外的DNS服务器大体是怎么一个被劫持的过程了。接下来我们在国内搭建一个服务器，从国外往国内发请求，看看是不是可以观测到被劫持的现象。 把路由器的WAN口的防火墙打开。配置本地的dnsmasq为使用非标准端口代理查询从而保证本地做dig查询的时候可以拿到正确的结果。然后在国外的服务器上执行dig @国内路由器ip twitter.com 可以看到收到的答案是错误的。执行前面的路由跟踪代码，结果如下：\n.160.187.13 .248.76.73 .158.33.181 .158.29.129 .158.19.165 * 219.158.96.225 * * * 219.158.101.233 END 可以看到不但有DNS劫持，而且DNS劫持发生在非常靠近国内路由器的位置。这也证实了论文中提出的观测结果。GFW并没有严格地部署在出国境前第一跳的位置，而是更加靠前。并且是双向的，至少DNS劫持是双向经过实验证实了。\n反DNS劫持 通过避免GFW重建请求反DNS劫持 使用非标准端口 这个实验就非常简单了。使用53之外的端口查询DNS，观测是否有错误答案被返回。 使用的DNS服务器是OpenDNS，端口为5353端口。使用非标准端口的DNS服务器不多，并不是所有的DNS服务器都会提供非标准端口供查询。结果如下：\n; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.9.1-P3 \u0026lt;\u0026lt;\u0026gt;\u0026gt; @208.67.222.222 -p 5353 twitter.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 5367 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 8192 ;; QUESTION SECTION: ;twitter.com. IN A ;; ANSWER SECTION: twitter.com. 5 IN A 199.59.150.39 twitter.com. 5 IN A 199.59.148.82 twitter.com. 5 IN A 199.59.148.10 ;; Query time: 194 msec ;; SERVER: 208.67.222.222#5353(208.67.222.222) ;; WHEN: Mon Jan 14 11:47:46 2013 ;; MSG SIZE rcvd: 88 可见，非标准端口还是可以得到正确结果的。但是这种穿墙并不能被应用程序直接使用，因为几乎所有的应用程序都不支持使用非标准端口查询。有很多种办法把端口变成53端口能用:\n使用本地DNS服务器转发（dnsmasq，pdnsd） 用NetfilterQueue改写IP包 用iptables改写IP包： iptables -t nat -I OUTPUT --dst 208.67.222.222 -p udp --dport 53 -j DNAT --to-destination 208.67.222.222:5353 使用TCP查询 这个实验就更加简单了，也是一条命令：\ndig +tcp @8.8.8.8 twitter.com GFW在日常是不屏蔽TCP的DNS查询的，所以可以得到正确的结果。但是和非标准端口一样，几乎所有的应用程序都不支持使用TCP查询。已知的TCP转UDP方式是使用pdnsd或者unbound转。 但是GFW现在不屏蔽TCP的DNS查询并不代表GFW不能这么干。做一个小实验：\nroot@OpenWrt:~# dig +tcp @8.8.8.8 dl.dropbox.com ;; communications error to 8.8.8.8#53: connection reset 可以看到GFW是能够知道你在查询什么的。与HTTP关键字过滤一样，一旦发现查询的内容不恰当，立马就发RST包过来切断连接。那么为什么GFW不审查所有的TCP的DNS查询呢？原因很简单，用TCP查询的绝对少数，尚不值得这么去干。而且就算你能查询到正确域名，GFW自认为还有HTTP关键字过滤和封IP等后着守着呢，犯不着在DNS上卡这么死。\n使用单向代理 严格来说单向代理并不是穿墙，因为它仍然需要在国外有一个代理服务器。使用代理服务器把DNS查询发出去，但是DNS查询并不经由代理服务器而是直接发回客户端。这样的实现在目前有更好的反劫持的手段（比如非标准端口）的情况下并不是一个有实际意义的做法。但是对于观测GFW的封锁机制还是有帮助的。据报道在敏感时期，对DNS不仅仅是劫持，而是直接丢包。通过单向代理可以观测丢包是针对出境流量的还是入境流量的。 客户端需要使用iptables把DNS请求转给NetfilterQueue，然后用python代码把DNS请求包装之后发给中转代理。对于应用程序来说，这个包装的过程是透明的，它仍然认为请求是直接发给DNS服务器的。 客户端代码如下:\nfrom netfilterqueue import NetfilterQueue import subprocess import signal import traceback import socket IMPERSONATOR_IP = \u0026#39;x.x.x.x\u0026#39; IMPERSONATOR_PORT = 19840 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP) def smuggle_packet(nfqueue_element): try: original_packet = nfqueue_element.get_payload() print(\u0026#39;smuggled\u0026#39;) udp_socket.sendto(original_packet, (IMPERSONATOR_IP, IMPERSONATOR_PORT)) nfqueue_element.drop() except: traceback.print_exc() nfqueue_element.accept() nfqueue = NetfilterQueue() nfqueue.bind(0, smuggle_packet) def clean_up(*args): subprocess.call(\u0026#39;iptables -D OUTPUT -p udp --dst 8.8.8.8 --dport 53 -j QUEUE\u0026#39;, shell=True) signal.signal(signal.SIGINT, clean_up) try: subprocess.call(\u0026#39;iptables -I OUTPUT -p udp --dst 8.8.8.8 --dport 53 -j QUEUE\u0026#39;, shell=True) print(\u0026#39;running..\u0026#39;) nfqueue.run() except KeyboardInterrupt: print(\u0026#39;bye\u0026#39;) 服务器端代码如下:\nimport socket import dpkt.ip def main_loop(server_socket, raw_socket): while True: packet_bytes, from_ip = server_socket.recvfrom(4096) packet = dpkt.ip.IP(packet_bytes) dst = socket.inet_ntoa(packet.dst) print(\u0026#39;%s:%s =\u0026gt; %s:%s\u0026#39; % (socket.inet_ntoa(packet.src), packet.data.sport, dst, packet.data.dport)) raw_socket.sendto(packet_bytes, (dst, 0)) server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) try: server_socket.bind((\u0026#39;0.0.0.0\u0026#39;, 19840)) raw_socket = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW) try: raw_socket.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, 1) main_loop(server_socket, raw_socket) finally: raw_socket.close() finally: server_socket.close() 在路由器上运行的时候要把WAN的防火墙规则改为接受INPUT，否则进入的UDP包会因为没有对应的出去的UDP包而被过滤掉。这是单向代理的一个缺陷，需要在墙上开洞。把防火墙整个打开是一种开洞的极端方式。后面专门讨论单向代理的时候会有更多关于防火墙凿洞的讨论。 第二个运行的条件是服务器所在的网络没有对IP SPROOFING做过滤。服务器实际上使用了和GFW发错误答案一样的技术，就是伪造SRC地址。通过把SRC地址填成客户端所在的IP地址，使得DNS查询的结果不需要经过代理服务器中装直接到达客户端。\n通过丢弃错误答案反DNS劫持 使用iptables过滤 前两种方式都是针对GFW的重建这一步。因为GFW没有在日常的时候监听所有UDP端口以及监听TCP流量，所以非标准端口或者TCP的DNS查询可以被放行。选择性丢包则针对的是GFW的应对措施。既然GFW发错误的答案回来，只要我们不认它给的答案，等正确的答案来就是了。 代码如下：\nmport sys import subprocess # source http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93 WRONG_ANSWERS = { \u0026#39;4.36.66.178\u0026#39;, \u0026#39;8.7.198.45\u0026#39;, \u0026#39;37.61.54.158\u0026#39;, \u0026#39;46.82.174.68\u0026#39;, \u0026#39;59.24.3.173\u0026#39;, \u0026#39;64.33.88.161\u0026#39;, \u0026#39;64.33.99.47\u0026#39;, \u0026#39;64.66.163.251\u0026#39;, \u0026#39;65.104.202.252\u0026#39;, \u0026#39;65.160.219.113\u0026#39;, \u0026#39;66.45.252.237\u0026#39;, \u0026#39;72.14.205.99\u0026#39;, \u0026#39;72.14.205.104\u0026#39;, \u0026#39;78.16.49.15\u0026#39;, \u0026#39;93.46.8.89\u0026#39;, \u0026#39;128.121.126.139\u0026#39;, \u0026#39;159.106.121.75\u0026#39;, \u0026#39;169.132.13.103\u0026#39;, \u0026#39;192.67.198.6\u0026#39;, \u0026#39;202.106.1.2\u0026#39;, \u0026#39;202.181.7.85\u0026#39;, \u0026#39;203.161.230.171\u0026#39;, \u0026#39;207.12.88.98\u0026#39;, \u0026#39;208.56.31.43\u0026#39;, \u0026#39;209.36.73.33\u0026#39;, \u0026#39;209.145.54.50\u0026#39;, \u0026#39;209.220.30.174\u0026#39;, \u0026#39;211.94.66.147\u0026#39;, \u0026#39;213.169.251.35\u0026#39;, \u0026#39;216.221.188.182\u0026#39;, \u0026#39;216.234.179.13\u0026#39; } rules = [\u0026#39;-p udp --sport 53 -m u32 --u32 \u0026#34;4 \u0026amp; 0x1FFF = 0 \u0026amp;\u0026amp; 0 \u0026gt;\u0026gt; 22 \u0026amp; 0x3C @ 8 \u0026amp; 0x8000 = 0x8000 \u0026amp;\u0026amp; 0 \u0026gt;\u0026gt; 22 \u0026amp; 0x3C @ 14 = 0\u0026#34; -j DROP\u0026#39;] for wrong_answer in WRONG_ANSWERS: hex_ip = \u0026#39; \u0026#39;.join([\u0026#39;%02x\u0026#39; % int(s) for s in wrong_answer.split(\u0026#39;.\u0026#39;)]) rules.append(\u0026#39;-p udp --sport 53 -m string --algo bm --hex-string \u0026#34;%s\u0026#34; --from 60 --to 180 -j DROP\u0026#39; % hex_ip) try: for rule in rules: print(rule) subprocess.call(\u0026#39;iptables -I INPUT %s\u0026#39; % rule, shell=True) print(\u0026#39;running..\u0026#39;) sys.stdin.readline() except KeyboardInterrupt: print(\u0026#39;bye\u0026#39;) finally: for rule in reversed(rules): subprocess.call(\u0026#39;iptables -D INPUT %s\u0026#39; % rule, shell=True) 本地有了这些iptables规则之后就可以丢弃掉GFW发回来的错误答案，从而得到正确的解析结果。这个脚本用到了两个iptables模块一个是u32一个是string。这两个内核模块不是所有的linux机器都有的。比如大部分的Android手机都没有这两个内核模块。所以上面的脚本适合内核模块很容易安装的场景，比如你的ubuntu pc。因为linux的内核模块与内核版本（每次编译基本都不同）是一一对应的，所以不同的linux机器是无法共享同样的内核模块的。所以基于内核模块的方案天然地具有安装困难的缺陷。\n使用nfqueue过滤 对于没有办法自己安装或者编译内核模块的场景，比如最常见的Android手机，厂家不告诉你内核的具体版本以及编译参数，普通用户是没有办法重新编译linux内核的。对于这样的情况，iptables提供了nfqueue，我们可以把内核模块做的ip过滤的工作交给用户态（也就是普通的应用程序）来完成。\nCLEAN_DNS = \u0026#39;8.8.8.8\u0026#39; RULES = [] for iface in network_interface.list_data_network_interfaces(): # this rule make sure we always query from the \u0026#34;CLEAN\u0026#34; dns RULE_REDIRECT_TO_CLEAN_DNS = ( {\u0026#39;target\u0026#39;: \u0026#39;DNAT\u0026#39;, \u0026#39;iface_out\u0026#39;: iface, \u0026#39;extra\u0026#39;: \u0026#39;udp dpt:53 to:%s:53\u0026#39; % CLEAN_DNS}, (\u0026#39;nat\u0026#39;, \u0026#39;OUTPUT\u0026#39;, \u0026#39;-o %s -p udp --dport 53 -j DNAT --to-destination %s:53\u0026#39; % (iface, CLEAN_DNS)) ) RULES.append(RULE_REDIRECT_TO_CLEAN_DNS) RULE_DROP_PACKET = ( {\u0026#39;target\u0026#39;: \u0026#39;NFQUEUE\u0026#39;, \u0026#39;iface_in\u0026#39;: iface, \u0026#39;extra\u0026#39;: \u0026#39;udp spt:53 NFQUEUE num 1\u0026#39;}, (\u0026#39;filter\u0026#39;, \u0026#39;INPUT\u0026#39;, \u0026#39;-i %s -p udp --sport 53 -j NFQUEUE --queue-num 1\u0026#39; % iface) ) RULES.append(RULE_DROP_PACKET) # source http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93 WRONG_ANSWERS = { \u0026#39;4.36.66.178\u0026#39;, \u0026#39;8.7.198.45\u0026#39;, \u0026#39;37.61.54.158\u0026#39;, \u0026#39;46.82.174.68\u0026#39;, \u0026#39;59.24.3.173\u0026#39;, \u0026#39;64.33.88.161\u0026#39;, \u0026#39;64.33.99.47\u0026#39;, \u0026#39;64.66.163.251\u0026#39;, \u0026#39;65.104.202.252\u0026#39;, \u0026#39;65.160.219.113\u0026#39;, \u0026#39;66.45.252.237\u0026#39;, \u0026#39;72.14.205.99\u0026#39;, \u0026#39;72.14.205.104\u0026#39;, \u0026#39;78.16.49.15\u0026#39;, \u0026#39;93.46.8.89\u0026#39;, \u0026#39;128.121.126.139\u0026#39;, \u0026#39;159.106.121.75\u0026#39;, \u0026#39;169.132.13.103\u0026#39;, \u0026#39;192.67.198.6\u0026#39;, \u0026#39;202.106.1.2\u0026#39;, \u0026#39;202.181.7.85\u0026#39;, \u0026#39;203.161.230.171\u0026#39;, \u0026#39;203.98.7.65\u0026#39;, \u0026#39;207.12.88.98\u0026#39;, \u0026#39;208.56.31.43\u0026#39;, \u0026#39;209.36.73.33\u0026#39;, \u0026#39;209.145.54.50\u0026#39;, \u0026#39;209.220.30.174\u0026#39;, \u0026#39;211.94.66.147\u0026#39;, \u0026#39;213.169.251.35\u0026#39;, \u0026#39;216.221.188.182\u0026#39;, \u0026#39;216.234.179.13\u0026#39;, \u0026#39;243.185.187.39\u0026#39; } def handle_nfqueue(): try: nfqueue = NetfilterQueue() nfqueue.bind(1, handle_packet) nfqueue.run() except: LOGGER.exception(\u0026#39;stopped handling nfqueue\u0026#39;) dns_service_status.error = traceback.format_exc() def handle_packet(nfqueue_element): try: ip_packet = dpkt.ip.IP(nfqueue_element.get_payload()) dns_packet = dpkt.dns.DNS(ip_packet.udp.data) if contains_wrong_answer(dns_packet): # after the fake packet dropped, the real answer can be accepted by the client LOGGER.debug(\u0026#39;drop fake dns packet: %s\u0026#39; % repr(dns_packet)) nfqueue_element.drop() return nfqueue_element.accept() dns_service_status.last_activity_at = time.time() except: LOGGER.exception(\u0026#39;failed to handle packet\u0026#39;) nfqueue_element.accept() def contains_wrong_answer(dns_packet): if dpkt.dns.DNS_A not in [question.type for question in dns_packet.qd]: return False # not answer to A question, might be PTR for answer in dns_packet.an: if dpkt.dns.DNS_A == answer.type: resolved_ip = socket.inet_ntoa(answer[\u0026#39;rdata\u0026#39;]) if resolved_ip in WRONG_ANSWERS: return True # to find wrong answer else: LOGGER.info(\u0026#39;dns resolve: %s =\u0026gt; %s\u0026#39; % (dns_packet.qd[0].name, resolved_ip)) return False # if the blacklist is incomplete, we will think it is right answer return True # to find empty answer 其原理是一样的，过滤所有的DNS应答，如果发现是错误的答案就丢弃。因为是基于nfqueue的，所以只要linux内核支持nfqueue，而且iptables可以添加nfqueue的target，就可以使用以上方式来丢弃DNS错误答案。目前已经成功在主流的android手机上运行该程序，并获得正确的DNS解析结果。另外，上面的实现利用iptables的重定向能力，达到了更换本机dns服务器的目的。无论机器设置的dns服务器是什么，通过上面的iptables规则，统统给你重定向到干净的DNS（8.8.8.8）。 自此DNS穿墙的讨论基本上就完成了。DNS劫持是所有GFW封锁手段中最薄弱的一环，有很多种方法都可以穿过。如果不想写代码，用非标准端口是最容易的部署方式。如果愿意部署代码，用nfqueue丢弃错误答案是最可靠通用的方式，不依赖于特定的服务器。\n封IP观测 观测twitter.com 首先使用dig获得twitter.com的ip地址：\n; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.9.1-P3 \u0026lt;\u0026lt;\u0026gt;\u0026gt; +tcp @8.8.8.8 twitter.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 8015 ;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1 ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 512 ;; QUESTION SECTION: ;twitter.com. IN A ;; ANSWER SECTION: twitter.com. 7 IN A 199.59.149.230 twitter.com. 7 IN A 199.59.150.39 twitter.com. 7 IN A 199.59.150.7 根据前面的内容我们知道使用dns over tcp，大部分的域名解析都不会被干扰的。这里得到了三个ip地址。先来测试199.59.149.230\ntraceroute to 199.59.149.230 (199.59.149.230), 30 hops max, 38 byte packets 123.114.32.1 19.862 ms 4.267 ms 101.431 ms 61.148.163.73 920.148 ms 5.108 ms 3.868 ms 124.65.56.129 7.596 ms 7.742 ms 7.735 ms 123.126.0.133 5.310 ms 7.745 ms 7.573 ms * * * * * * 这个结果是最常见的。在骨干路由器上，针对这个ip丢包了。这种封锁方式就是最传统的封IP方式，BGP路由扩散，现象就是针对上行流量的丢包。再来看199.59.150.39\ntraceroute to 199.59.150.39 (199.59.150.39), 30 hops max, 38 byte packets 123.114.32.1 14.046 ms 20.322 ms 19.918 ms 61.148.163.229 7.461 ms 7.182 ms 7.540 ms 124.65.56.157 4.491 ms 3.342 ms 7.260 ms 123.126.0.93 6.715 ms 7.309 ms 7.438 ms 219.158.4.126 5.326 ms 3.217 ms 3.596 ms 219.158.98.10 3.508 ms 3.606 ms 4.198 ms 219.158.33.254 140.965 ms 133.414 ms 136.979 ms 129.250.4.107 132.847 ms 137.153 ms 134.207 ms 61.213.145.166 253.193 ms 253.873 ms 258.719 ms 199.16.159.15 257.592 ms 258.963 ms 256.034 ms 199.16.159.55 267.503 ms 268.595 ms 267.590 ms 199.59.150.39 266.584 ms 259.277 ms 263.364 ms 在我撰写的时候，这个ip还没有被封。但是根据经验，twitter.com享受了最高层次的GFW关怀，新的ip基本上最慢也是隔日被封的。不过通过这个traceroute可以看到219.158.4.126其实就是那个之前捣乱的服务器，包是在它手里被丢掉的（严格来说并不一定是219.158.4.126，因为ip包经过的路由对于不同的目标ip设置不同的端口都可能会不一样）。再来看199.59.150.7\ntraceroute to 199.59.150.7 (199.59.150.7), 30 hops max, 38 byte packets 123.114.32.1 11.379 ms 10.420 ms 23.008 ms 61.148.163.229 6.102 ms 6.777 ms 7.373 ms 61.148.153.61 5.638 ms 3.148 ms 3.235 ms 123.126.0.9 3.473 ms 3.306 ms 3.216 ms 219.158.4.198 2.839 ms !H * 6.136 ms !H 这次同样是封IP，但是现象不同。通过抓包可以观察到是什么问题：\n:46:11.355913 IP (tos 0x0, ttl 251, id 0, offset 0, flags [none], proto ICMP (1), length 56) .158.4.198 \u0026gt; 123.114.40.44: ICMP host r-199-59-150-7.twttr.com unreachable, length 36 IP (tos 0x0, ttl 1, id 0, offset 0, flags [DF], proto UDP (17), length 38) .114.40.44.45021 \u0026gt; r-199-59-150-7.twttr.com.33449: UDP, length 10 原来219.158.4.198发回来了一个ICMP包，内容是地址不可到达（unreachable）。于是traceroute就在那里断掉了。 如果把unreachable类型的ICMP包丢弃掉，会发现ip包仍然过不去\ntraceroute to 199.59.150.7 (199.59.150.7), 30 hops max, 38 byte packets 123.114.32.1 4.866 ms 3.165 ms 3.212 ms 61.148.163.229 3.107 ms 3.104 ms 3.270 ms 61.148.153.61 6.001 ms 7.246 ms 7.398 ms 123.126.0.9 7.840 ms 7.223 ms 7.443 ms * * * 这次就和被丢包了是一样的观测现象了。 同时，可以看到我们仍然是收到了icmp地址不可到达的包的，只是被我们drop掉了。\n观测被封ip的反向流量 之前的观测中，被封的ip是ip包的dst。如果我们从国外往国内发包，其src是被封的ip，那么ip包是否会被GFW过滤掉呢？登录到一台国外的vps上执行下面的python代码:\nfrom scapy.all import * send(IP(src=\u0026#34;http://drops.wooyun.org/papers/199.59.150.7\u0026#34;, dst=\u0026#34;123.114.40.44\u0026#34;)/ICMP()) 然后在国内的路由器上执行抓包程序\ntcpdump: listening on pppoe-wan, link-type LINUX_SLL (Linux cooked), capture size 65535 bytes :41:14.294671 IP (tos 0x0, ttl 50, id 1, offset 0, flags [none], proto ICMP (1), length 28) r-199-59-150-7.twttr.com \u0026gt; 123.114.40.44: ICMP echo request, id 0, seq 0, length 8 :41:14.294779 IP (tos 0x0, ttl 64, id 25013, offset 0, flags [none], proto ICMP (1), length 28) .114.40.44 \u0026gt; r-199-59-150-7.twttr.com: ICMP echo reply, id 0, seq 0, length 8 可以看到，如果该ip是src而不是dst并不会被GFW过滤。这一行为有两种可能：要么GFW认为封dst就可以了，不屑于再封src了。另外一种可能是GFW封twitter的IP用的是路由表扩散技术，而传统的路由表是基于dst做路由判断的（高级的路由器可以根据src甚至端口号做为路由的依据），所以dst路由表导致的路由黑洞并不会影响该ip为src的情况。我相信是后者，但是GFW在封个人翻墙主机上所表现的实力（对大量的ip做精确到端口的全国性丢包）让我们相信，GFW很容易把封锁变成双向的。不过说实话，在这个硬实力的背后，靠的更多的是CISCO下一代骨干网路由器的超强处理能力，而不是GFW自身。\n单向代理 因为GFW对IP的封锁是针对上行流量的，所以使得单向代理就可以突破封锁。上行的IP包经过单向代理转发给目标服务器，下行的IP包直接由目标服务器发回给客户端。代码与DNS（UDP协议）的单向代理是一样的。因为单向代理利用的是IP协议，所以TCP与UDP都是一样的。除了单向代理，目前尚没有其他的办法穿过GFW访问被封的IP，只能使用传统的翻墙技术，代理或者VPN这些。\n结语 GFW与网民之间已经或者即将形成某种稳态，这种稳态是双方斗争状况下的动态平衡，是需要有意识维护的。一个无法控制的网络是无法被政府所容忍的，当网络无法控制时政府是不吝于切断一切网络的（你一定知道我在说什么），稳态的破坏也就意味着环境的毁灭。一个理想的稳态就是网络处于“看起来”可以控制的状态，让GFW处于不断取得小型封锁成功的虚幻胜利感之中，网民个人各自掌握非中心化的翻墙方法。一个中心化的大众翻墙方法（最典型的例子就是设置hosts静态解析）必定无法避免被当局发现并被GFW封锁。下一代的翻墙方法应该是去中心化的（p2p）、小众的、多样化的、混合型的、动态更新的。\n","permalink":"https://EitanWong.github.io/en/posts/passgfw/%E4%BB%8Egfw%E5%8E%9F%E7%90%86%E5%88%B0%E7%BF%BB%E5%A2%99%E5%AE%9E%E8%B7%B5/","summary":"引言 GFW具有重大的社会意义。无论是正面的社会意义，还是负面的意义。无论你是讨厌，还是憎恨。它都在那里。在可以预见的将来，墙还会继续存在。我们要学会如何与其共存。 我们把翻墙看成一场我们与GFW之间的博弈，是一个不断对抗升级的动态过程。目前整体的博弈态势来讲是GFW占了绝对的上风。","title":"从GFW原理到翻墙实践"},{"content":"💬前言 以前记录一些笔记文章，都用Notion这款软件🖊️📒 但是有一天我发现连不上🚫Notion的网站了(平时主要在线用网页写文章) 误以为Notion跑路🏃了\u0026hellip;.后来才发现是我的网络🛜问题 不过数据在别人那里，总归是有风险的，无论是信息安全🔐，还是数据安全🔐 所以我打算把Notion里面所有的笔记导出➡️成markdown📃格式\n🔧实施 Notion网页当中就已经包含了导出功能，点击Export按钮，就可以导出PDF，HTML，Markdown\n导出之后是一个压缩包，解压之后可以看到，里面有很多文件夹，还有markdown文件， 图片就是存放在对应命名的文件夹中\n可以看到markdown中的图片是链接到本地的\n我们可以将图片一个一个上传到在线的图床上，替换这个连接就可以了 吗❓ 如果我有1000篇文章，我要一个个替换到🐒🧨🐎🌛去\u0026hellip;\u0026hellip; 就算上传到图床上去了，玩意在线图床挂了，那就凉凉\n🙋如何解决这些问题呢？ 答案就是让图片进行base64编码存储 这里有一个网站可以在线base64编解码https://base64.us/\n🧑‍💻编码 为了实现批量处理这些文档中图片的编码 我需要实现一个Python脚步，来帮我自动处理这些文件 脚本代码如下\nimport os import base64 import urllib.parse import re from PIL import Image def replace(directory, output_directory,quality): # 遍历目录中的所有markdown文件 for root, _, files in os.walk(directory): for filename in files: if filename.endswith(\u0026#34;.md\u0026#34;): filepath = os.path.join(root, filename) # 读取markdown文件内容 with open(filepath, \u0026#34;r\u0026#34;) as f: content = f.read() # 查找所有的图片链接并替换为base64编码 pattern = r\u0026#34;!\\[(.*?)\\]\\((.*?)\\)\u0026#34; matches = re.findall(pattern, content) ref_dict = {} for match in matches: img_path = os.path.abspath(os.path.join(os.path.dirname(filepath), urllib.parse.unquote(match[1]))) print(\u0026#34;读取图片:\u0026#34;+img_path) if not match[1].startswith(\u0026#34;https://\u0026#34;): try: with Image.open(img_path) as img: img = img.convert(\u0026#39;RGB\u0026#39;) img.save(\u0026#34;temp.webp\u0026#34;, \u0026#34;WebP\u0026#34;, quality=quality) with open(\u0026#34;temp.webp\u0026#34;, \u0026#34;rb\u0026#34;) as f: img_data = f.read() img_base64 = base64.b64encode(img_data).decode(\u0026#34;utf-8\u0026#34;) ref_id = f\u0026#34;img-{base64.b32encode(match[1].encode()).decode()}\u0026#34; ref_dict[ref_id] = f\u0026#34;data:image/webp;base64,{img_base64}\u0026#34; img_tag = f\u0026#34;![{match[0]}][{ref_id}]\u0026#34; content = content.replace(f\u0026#34; ![{match![0]}]({match[1]}) \u0026#34;, img_tag) except IOError: print (\u0026#34;Error: \u0026#34;+img_path+\u0026#34;没有找到文件或读取文件失败\u0026#34;) else: print(\u0026#34;替换\u0026#34;+img_path+\u0026#34;成功\u0026#34;) img.close() # 取消\u0026lt;aside\u0026gt;标签前后的换行符 content = re.sub(r\u0026#34;\\n\\s*\u0026lt;/aside\u0026gt;\u0026#34;, \u0026#34;\u0026lt;/aside\u0026gt;\u0026#34;, content) content = re.sub(r\u0026#34;\u0026lt;aside\u0026gt;\\s*\\n\u0026#34;, \u0026#34;\u0026lt;aside\u0026gt;\u0026#34;, content) # 在markdown文件末尾添加引用 ref_content = \u0026#34;\\n\\n\u0026#34;.join([f\u0026#34;[{ref_id}]: {ref_url}\u0026#34; for ref_id, ref_url in ref_dict.items()]) content += f\u0026#34;\\n\\n{ref_content}\u0026#34; # 写入修改后的markdown内容 output_filepath = os.path.join(output_directory, filename) with open(output_filepath, \u0026#34;w\u0026#34;) as f: f.write(content) if __name__ == \u0026#39;__main__\u0026#39;: replace(input(\u0026#34;请输入markdown所在的文件夹路径: \u0026#34;), input(\u0026#34;请输入输出文件夹的路径: \u0026#34;),float(input(\u0026#34;请输入图片质量(0~100): \u0026#34;))) 在终端当中输入markdown所在的文件夹路径，以及处理后输出的文件夹路径 回车，程序就会从文件夹中自动搜寻图片，并进行base64编码，然后替换\n📄结果 这些就是输出后的文件\n替换后为了方便编辑和阅读markdown的图片地址，采用的引用的方式\n具体的base64的编码在文档的最后面\n🎙️总结 💡经过这样处理后的markdown文件，图片就内置在了文件当中，只要文件在图片就一直存在 💡缺点的话可能就是markdown文件体积增大了一点，不过你可以选择降低图片质量\n","permalink":"https://EitanWong.github.io/en/posts/other/notion%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA%EF%B8%8Fmarkdown%E5%B9%B6%E8%A7%A3%E5%86%B3%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/","summary":"💬前言 以前记录一些笔记文章，都用Notion这款软件🖊️📒 但是有一天我发现连不上🚫Notion的网站了(平时主要在线用网页写文章) 误以为Notion跑路🏃了\u0026hellip;.后来才发现是我的网络🛜问题 不过数据在别人那里，总归是有风险的，无论是信息安全🔐，还是数据安全🔐 所以我打算把","title":"Notion笔记📒导出➡️markdown📄，并解决图片路径依赖问题"},{"content":"法线 💡 法线（normal line），是指始终垂直于某平面的直线。 在几何学中，法线指平面上垂直于曲线在某点的切线的一条线。 法线也应用于光学的平面镜反射上。\nPython实现的光照渲染Demo （依赖包：numpy、opencv） 1、编写变换的矩阵包括移动、旋转、缩放、投影\nimport numpy as np from math import * def M_Move(x,y,z): return np.array([1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1]).reshape(4,4) def M_Scale(x,y,z): return np.array([x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1]).reshape(4,4) def M_RotateY(angle): return np.array([cos(angle),0,sin(angle),0,0,1,0,0,-sin(angle),0,cos(angle),0,0,0,0,1]).reshape(4,4) def M_RotateX(angle): return np.array([1,0,0,0,0,cos(angle),-sin(angle),0,0,sin(angle),cos(angle),0,0,0,0,1]).reshape(4,4) def M_Projection(distance): return np.array([1,0,0,0,0,1,0,0,0,0,1,1/distance,0,0,0,1]).reshape(4,4) def GetPoint(vector4): offset=250 d=1 if vector4[3]==0 else vector4[3] # d=-d if d\u0026lt;0 else d return (int(offset+vector4[0]/d),int(offset-vector4[1]/d)) def GetNomalizedDir(targetPos,vector4): Dir=targetPos-np.array([vector4[0],vector4[1],vector4[2]]) return nomalizeVector3(Dir) def mul(matrix4x4_1,matrix4x4_2): return np.matmul(matrix4x4_1,matrix4x4_2) def nomalizeVector3(vector3): return vector3/np.linalg.norm(vector3) 2、实现TriangleClass，实现三角面的变换与绘制\nimport cv2 as cv import numpy as np from math import * from matrix import * class Trangle: def __init__(self,a,b,c): self.a=np.array(a);self.b=np.array(b);self.c=np.array(c) self.A=self.a;self.B=self.b;self.C=self.c self.cullMask=False self.drawLines=True self.thickness=1 self.linesColor=(255,255,255) self.lightPos=np.array([0,0,-1]) self.cameraPos=np.array([0,0,-1]) def transform(self,matrix): self.A=mul(self.a,matrix);self.B=mul(self.b,matrix);self.C=mul(self.c,matrix) self.pointA=GetPoint(self.A);self.pointB=GetPoint(self.B);self.pointC=GetPoint(self.C) u=self.B-self.A;v=self.C-self.A self.U=np.array([u[0],u[1],u[2]]) ;self.V=np.array([v[0],v[1],v[2]]) def drawCall(self,img): points=[self.pointA,self.pointB,self.pointC] if self.drawLines: cv.line(img,points[0],points[1],self.linesColor,self.thickness) cv.line(img,points[1],points[2],self.linesColor,self.thickness) cv.line(img,points[2],points[0],self.linesColor,self.thickness) self.normal=np.cross(self.U,self.V) self.normal=self.normal/np.linalg.norm(self.normal) eyeDir=-self.cameraPos self.cullMask =np.dot(eyeDir,self.normal)\u0026lt;0 if not self.cullMask: lightDir=nomalizeVector3(-self.lightPos) l=np.dot(lightDir,self.normal) l= 0 if l\u0026lt;0 else l col=int(200*l)+55 cv.fillPoly(img,[np.array(points)], (col,col,col)) return img 3、实现Cube Class，根据定点构建立方体三角面，并编写绘制与变换方法\nfrom Triangle import * class Cube: def __init__(self,vertices): self.vertices=vertices self.triangles=[ # Top Trangle(self.vertices[0],self.vertices[1],self.vertices[2]), Trangle(self.vertices[0],self.vertices[2],self.vertices[3]), # Down Trangle(self.vertices[4],self.vertices[7],self.vertices[5]), Trangle(self.vertices[5],self.vertices[7],self.vertices[6]), # Front Trangle(self.vertices[3],self.vertices[7],self.vertices[6]), Trangle(self.vertices[3],self.vertices[6],self.vertices[2]), # Back Trangle(self.vertices[0],self.vertices[1],self.vertices[4]), Trangle(self.vertices[1],self.vertices[5],self.vertices[4]), # Left Trangle(self.vertices[3],self.vertices[0],self.vertices[7]), Trangle(self.vertices[0],self.vertices[4],self.vertices[7]), # Right Trangle(self.vertices[2],self.vertices[6],self.vertices[5]), Trangle(self.vertices[2],self.vertices[5],self.vertices[1]), ] self.drawLines=True self.thickness=1 self.linesColor=(255,255,255) self.lightPos=np.array([0,0,-1]) self.cameraPos=np.array([0,0,-1]) def transform(self,matrix): for t in self.triangles: t.transform(matrix) def drawCall(self,img): for t in self.triangles: t.drawLines=self.drawLines t.thickness=self.thickness t.linesColor=self.linesColor # t.lightPos=self.lightPos # t.cameraPos=self.cameraPos img=t.drawCall(img) return img 4、main脚本中，初始化顶点等相关数据，进行循环绘制，实现立方体旋转效果\nfrom Cube import * lightPos=np.array([10,10,-10]) cameraPos=np.array([0,0,-10]) moveSpeed=10 fov=250 rotateY=0 if __name__==\u0026#39;__main__\u0026#39;: a=[-0.5, 0.5, 0.5, 1] b=[0.5, 0.5, 0.5, 1] c=[0.5, 0.5, -0.5, 1] d=[-0.5, 0.5, -0.5, 1] e=[-0.5, -0.5, 0.5, 1] f=[0.5, -0.5, 0.5, 1] g=[0.5, -0.5, -0.5, 1] h=[-0.5, -0.5, -0.5, 1] cube= Cube([a,b,c,d,e,f,g,h]) done = False while not done: img=np.zeros((500,500,3),np.uint8) cube.lightPos=lightPos cube.cameraPos=cameraPos cube.drawLines=False rotateY+=0.05 matMove=M_Move(cameraPos[0],cameraPos[1],cameraPos[2]) distance=-cameraPos[2] if cameraPos[2]\u0026lt;0 else cameraPos[2] distance=0.001 if distance\u0026lt;=0 else distance matScale= M_Scale(200,200,200) matRotate=mul(M_RotateX(rotateY),M_RotateY(rotateY)) m=matMove matProjection=M_Projection(fov) m=mul(matScale,m) m=mul(matRotate,m) m=mul(m,matProjection) cube.transform(m) graphics= cube.drawCall(img) cv.imshow(\u0026#34;img\u0026#34;,graphics) key=cv.waitKey(10) if key==27: done=True cv.destroyAllWindows() elif key==119: cameraPos[2]-=moveSpeed elif key==115: cameraPos[2]+=moveSpeed elif key==97: cameraPos[0]+=moveSpeed elif key==100: cameraPos[0]-=moveSpeed elif key==101: cameraPos[1]-=moveSpeed elif key==113: cameraPos[1]+=moveSpeed ","permalink":"https://EitanWong.github.io/en/posts/shader/%E5%85%89%E7%85%A7%E6%B8%B2%E6%9F%93/","summary":"法线 💡 法线（normal line），是指始终垂直于某平面的直线。 在几何学中，法线指平面上垂直于曲线在某点的切线的一条线。 法线也应用于光学的平面镜反射上。 Python实现的光照渲染Demo （依赖包：numpy、opencv） 1、编写变换的矩阵包括移动、旋转、缩放、投影 import numpy as np from math import","title":"光照渲染"},{"content":"1、法向量：垂直于平面的向量，包括两个方向 在真正的模型顶点数据就会存储法向量，在存储过后，它抛弃了在数学概念上的两个方向的法向量 只保留了正方向的法向量 2、这里有一个很简单的示意图，蓝色是从顶点引出垂直于平面的法向量， 黄色的是从外部射向表面的光向量 💡 光的方向是相反的，一定是从模型指向光 光向量也会被形象理解为，光在距离顶点很远的位置，这个向量的长度很长\n那么它和我们的计算有没有关系呢 3、对于两个向量求点击，它们有一个很明显的几何意义，就是能够得到这两个向量之间夹角的大小 也就是求的余弦值cos 对于v1和v2求点积，其实就等于v1和v2的模长相乘再乘上它们之间夹角的余弦值 反过来说求夹角的余弦值其实，就是用点积的结果除以v1v2模长的乘积 结合上图，如果光向量的长度很长，那就必须求的它的模长，还要求的法向量的模长，只有两个向量模长得到之后，才能求得准确的余弦值 反三角函数求具体的角度在这里不需要应用，但是有些情况下可能会需要求解具体的角度 一般情况下角度如果大于90度，cos值是小于0的， 在这样的情况下，我们正好就可以考虑如果两个向量之间的夹角是小于90度的，它们点积的结果就应该是0～1之间的范围 如果能够让v1和v2能够把它们做到是一个单位向量，那么它们模长相乘结果就为1 也就是说两个这样的两个向量它们之间的夹角就是两个向量之间的点积\n💡 对于光的计算需要两个向量 1.关于法向量 2.关于顶点指向光源的光向量 3.再把这两个向量做到归一化的时候，夹角的余弦值就是两个向量点积的结果 💡 利用这个点积值0～1之间，就可以拿来进行着色 夹角越小光照亮度越亮\n法向量的计算 使用U和V两个向量，它们不一定要垂直，它们描述的是U和V所在的一个平面 用U和V进行一个左手方向的差积，就可以得到一个垂直于平面方向的法向量N\n5、根据左手坐标系，下方的向量计算，如果是V1*V2垂直的法向量是朝着屏幕里面的， 为了得到垂直于V1V2所在平面的正确的法向量，应该v2乘以v1，这样法向量的朝向是朝向屏幕外边的，也就是朝向观察者的方向，这样才可以通过夹角计算光照，并得到正确的光照效果\n6、所以对于下方的三角形，在计算法向量是，和顶点的顺序是密不可分的，例如要计算正确的法向量，那么就要计算V1和V2的向量，一个是B-A另一个是C-A， 如果ABC对于的顺序分别是0、1、2 V1和V2向量也就是\n[1]-[0]和[2]-[0] 那么这样子的话就必须要保证顶点遍历的顺序，如果是其他的顺序，就会得到错误的法线方向 ","permalink":"https://EitanWong.github.io/en/posts/shader/%E6%B3%95%E5%90%91%E9%87%8F%E5%92%8C%E5%85%89%E7%85%A7%E8%AE%A1%E7%AE%97/","summary":"1、法向量：垂直于平面的向量，包括两个方向 在真正的模型顶点数据就会存储法向量，在存储过后，它抛弃了在数学概念上的两个方向的法向量 只保留了正方向的法向量 2、这里有一个很简单的示意图，蓝色是从顶点引出垂直于平面的法向量， 黄色的是从外部射向表面的光向量 💡 光的方向是相反的，一定是从模型指","title":"法向量和光照计算"},{"content":"简易的波纹效果 💡 利用Sin周期函数，让顶点的Y轴进行波动\nShader \u0026#34;ShaderLearning/VertexShader/wave\u0026#34; { Properties{ _Amplitude(\u0026#34;Amplitude\u0026#34;,float)=1 _Frequency(\u0026#34;Frequency\u0026#34;,Range(0,5))=1 _Speed(\u0026#34;_Speed\u0026#34;,float)=1 } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; float _Amplitude; float _Frequency; float _Speed; struct v2f { float4 vertex : POSITION; float4 color : COLOR; }; v2f vert (appdata_base v) { float up =sin(v.vertex.x)+_Time.y; // float4x4 m={ // 1,0,0,0, // 0,sin(up)/8+0.5,0,0, // 0,0,1,0, // 0,0,0,1 // };//由于Plane模型顶点的y值都为0和矩阵相乘的结果也都为0，所以定位没有进行移动 // v.vertex=mul(m,v.vertex); //A*sin(w*x+t) v.vertex.y+=_Amplitude*sin(v.vertex.z*_Frequency+_Time.y*_Speed); v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.color=fixed4(v.vertex.y,v.vertex.y,v.vertex.y,1); return o; } fixed4 frag (v2f i) : COLOR { return i.color; } ENDCG } } } 实现圆心波效果 💡 只需要计算顶点到圆心的模长，传入sin周期函数\nv.vertex.y+=_Amplitude*sin(-length(v.vertex.xz)*_Frequency+_Time.y*_Speed); 利用顶点x方向于z方向之和作为周期传入sin v.vertex.y+=_Amplitude*sin((v.vertex.x+v.vertex.z)*_Frequency+_Time.y*_Speed); 简易水面波浪效果 💡 根据英伟达在早期的GPU编程精粹这样的数据当中有提到，仿真一个水波，要用到4个正弦波，在移动设备上可能运算量会很大 下面的示例demo，简化尝试将两个正弦波叠加\nShader \u0026#34;ShaderLearning/VertexShader/wave\u0026#34; { Properties{ _Amplitude(\u0026#34;Amplitude\u0026#34;,float)=1 _Frequency(\u0026#34;Frequency\u0026#34;,Range(0,5))=1 _Speed(\u0026#34;_Speed\u0026#34;,float)=1 } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; float _Amplitude; float _Frequency; float _Speed; struct v2f { float4 vertex : POSITION; float4 color : COLOR; }; v2f vert (appdata_base v) { float up =sin(v.vertex.x)+_Time.y; // float4x4 m={ // 1,0,0,0, // 0,sin(up)/8+0.5,0,0, // 0,0,1,0, // 0,0,0,1 // };//由于Plane模型顶点的y值都为0和矩阵相乘的结果也都为0，所以定位没有进行移动 // v.vertex=mul(m,v.vertex); //A*sin(w*x+t) v.vertex.y+=_Amplitude*sin((v.vertex.x+v.vertex.z)*_Frequency+_Time.y*_Speed); v.vertex.y+=_Amplitude*sin((v.vertex.x-v.vertex.z)*_Frequency+_Time.w*_Speed); v2f o; o.vertex = UnityObjectToClipPos(v.vertex); o.color=lerp(fixed4(0,0.5,1,1),fixed4(1,1,1,1),v.vertex.y); return o; } fixed4 frag (v2f i) : COLOR { return i.color; } ENDCG } } } ","permalink":"https://EitanWong.github.io/en/posts/shader/%E9%A1%B6%E7%82%B9%E5%8F%98%E6%8D%A2-%E6%B3%A2%E7%BA%B9%E6%95%88%E6%9E%9C/","summary":"简易的波纹效果 💡 利用Sin周期函数，让顶点的Y轴进行波动 Shader \u0026#34;ShaderLearning/VertexShader/wave\u0026#34; { Properties{ _Amplitude(\u0026#34;Amplitude\u0026#34;,float)=1 _Frequency(\u0026#34;Frequency\u0026#34;,Range(0,5))=1 _Speed(\u0026#34;_Speed\u0026#34;,float)=1 } SubShader { Pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; float _Amplitude; float _Frequency; float _Speed; struct v2f { float4 vertex : POSITION; float4 color : COLOR; }; v2f vert (appdata_base v) { float up =sin(v.vertex.x)+_Time.y; // float4x4 m={ // 1,0,0,0, // 0,sin(up)/8+0.5,0,0, // 0,0,1,0, // 0,0,0,1 // };//由于Plane模型顶点的y值都为0和矩阵相乘的结果也都为0，所以定位没有进行移动 // v.vertex=mul(m,v.vertex); //A*sin(w*x+t) v.vertex.y+=_Amplitude*sin(v.vertex.z*_Frequency+_Time.y*_Speed); v2f o; o.vertex = UnityObjectToClipPos(v.vertex);","title":"顶点变换-波纹效果"},{"content":"顶点扭曲Shader案例 💡 可以在Shader当中构建旋转矩阵，来实现顶点的旋转，从而达到模型的扭曲效果\nShader \u0026#34;ShaderLeaning/VertexDistortion/vf1\u0026#34; { Properties{ } SubShader{ Pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f { float4 pos: POSITION; fixed4 col: COLOR; }; v2f vert(appdata_base v) { v2f o; float angle=length(v.vertex)*_SinTime.w;//计算顶点到中心点的模长，与SinTime相乘，实现角度的周期性变化 float4x4 m={ cos(angle),0,sin(angle),0, 0,1,0,0, -sin(angle),0,cos(angle),0, 0,0,0,1 };//构建绕Y轴旋转的矩阵 float4 p=mul(m,v.vertex);//将旋转矩阵与顶点相乘 o.pos=UnityObjectToClipPos(p); o.col=fixed4(0,1,1,1); return o; } fixed4 frag(v2f v):COLOR { return v.col; } ENDCG } } } 💡 但是每次顶点程序计算当中，都进行了矩阵乘法运算，掌握了矩阵运算规则 可以发现，顶点只是在x，与z方向上移动，所以y值没有必要参与矩阵乘法 所以可以根据这个规律编写优化的代码，提高执行效率\n//优化顶点扭曲变换的代码 float x= x=v.vertex.x*cos(angle)+v.vertex.z*sin(angle); float z=v.vertex.x*(-sin(angle))+v.vertex.z*cos(angle); v.vertex.x=x; v.vertex.z=z; o.pos=UnityObjectToClipPos(v.vertex); xyz同时旋转扭曲\nShader \u0026#34;ShaderLeaning/VertexDistortion/vf1\u0026#34; { Properties{ } SubShader{ Pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f { float4 pos: POSITION; fixed4 col: COLOR; }; v2f vert(appdata_base v) { v2f o; float angle=length(v.vertex)*_SinTime.w*1.5; float4x4 mx={ 1,0,0,0, 0,cos(angle),-sin(angle),0, 0,sin(angle),cos(angle),0, 0,0,0,1 }; float4x4 my={ cos(angle),0,sin(angle),0, 0,1,0,0, -sin(angle),0,cos(angle),0, 0,0,0,1 }; float4x4 mz={ cos(angle),-sin(angle),0,0, sin(angle),cos(angle),0,0, 0,0,1,0, 0,0,0,1 }; v.vertex= mul(mz,mul(my,mul(mx,v.vertex))); o.pos=UnityObjectToClipPos(v.vertex); o.col=fixed4(0,1,1,1); return o; } fixed4 frag(v2f v):COLOR { return v.col; } ENDCG } } 实现根据根据音量大小实现波动效果 Shader \u0026#34;ShaderLeaning/VertexDistortion/vf2\u0026#34; { Properties{ } SubShader{ Pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; uniform float _Height=1; struct v2f { float4 pos: POSITION; fixed4 col: COLOR; }; v2f vert(appdata_base v) { v2f o; float angle=length(v.vertex)*_Time.y; v.vertex.x=v.vertex.x* (sin(angle)/16+1); v.vertex.z=v.vertex.z* (cos(angle)/16+1); v.vertex.y=v.vertex.y+(sin(angle)*cos(angle))*_Height; o.pos=UnityObjectToClipPos(v.vertex); o.col=fixed4(0,1,1,1); return o; } fixed4 frag(v2f v):COLOR { return v.col; } ENDCG } } } using System.Collections; using System.Collections.Generic; using UnityEngine; public class VoiceControl : MonoBehaviour { [SerializeField] float multiplyer=10; AudioClip clip; string device=null; Material mat; // Start is called before the first frame update void Start() { device= Microphone.devices[0]; clip=Microphone.Start(device,true,999,44100); mat=GetComponent().sharedMaterial; } private void Update() { var volume= GetVolume(); mat.SetFloat(\u0026#34;_Height\u0026#34;,volume*multiplyer); //Debug.Log(volume); } public float GetVolume() { if(Microphone.IsRecording(device)) { int sampleSize=128; float[] samples=new float[sampleSize]; int startPosition= Microphone.GetPosition(device)-(sampleSize+1); clip.GetData(samples,startPosition); float levelMax=0; for (int i = 0; i \u0026lt; sampleSize; i++) { float wavePeak=samples[i]; if(levelMax\u0026lt;wavePeak) { levelMax=wavePeak; } } return levelMax; } return 0; } } ","permalink":"https://EitanWong.github.io/en/posts/shader/%E9%A1%B6%E7%82%B9%E6%89%AD%E6%9B%B2/","summary":"顶点扭曲Shader案例 💡 可以在Shader当中构建旋转矩阵，来实现顶点的旋转，从而达到模型的扭曲效果 Shader \u0026#34;ShaderLeaning/VertexDistortion/vf1\u0026#34; { Properties{ } SubShader{ Pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f { float4 pos: POSITION; fixed4 col: COLOR; }; v2f vert(appdata_base v) { v2f o; float angle=length(v.vertex)*_SinTime.w;//计算顶点到中心点的模长，与SinTime","title":"顶点扭曲"},{"content":"顶点位移Shader案例 💡 length(xy): 求向量模长度 等同于sqrt(x_x+y_y); 1、抬升地面\nShader \u0026#34;Custom/s_ten\u0026#34; { Properties{ _R(\u0026#34;R\u0026#34;,range(0,5))=1 } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float dis; float r; float _R; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { //x、y坐标 float2 xy = v.vertex.xz; //求到圆心的距离，即半径 //float d = sqrt((xy.x - 0)*(xy.x - 0) + (xy.y-0)*(xy.y - 0)); //也可以使用下面的计算摸长的方式 float d = _R - length(xy); //d小于0则不抬升，否则抬升 d = d \u0026lt; 0 ? 0 : d; float height=1; float4 uppos = float4(v.vertex.x,height*d,v.vertex.z,v.vertex.w); v2f o; o.pos = mul(UNITY_MATRIX_MVP, uppos); //x的坐标值 float x = o.pos.x / o.pos.w; if (x \u0026gt;dis \u0026amp;\u0026amp; x\u0026lt;dis+r)//在屏幕最左边 o.color = fixed4(1, 0, 0, 1);//显示为红色 else o.color = fixed4(x/2+0.5,x/2+0.5,x/2+0.5,1);//灰度 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 通过更改R的值更改地表凸起的高度 2、实现雪山效果\nShader \u0026#34;Custom/s_ten\u0026#34; { Properties{ _R(\u0026#34;R\u0026#34;,range(0,5))=1 } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float dis; float r; float _R; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { //x、y坐标 float2 xy = v.vertex.xz; //求到圆心的距离，即半径 //float d = sqrt((xy.x - 0)*(xy.x - 0) + (xy.y-0)*(xy.y - 0)); //也可以使用下面的计算摸长的方式 float d = _R - length(xy); //d小于0则不抬升，否则抬升 d = d \u0026lt; 0 ? 0 : d; float height=1; float4 uppos = float4(v.vertex.x,height*d,v.vertex.z,v.vertex.w); v2f o; o.pos = mul(UNITY_MATRIX_MVP, uppos); //x的坐标值 float x = o.pos.x / o.pos.w; o.color = fixed4(uppos.y,uppos.y,uppos.y,1); return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 3、将坐标改为世界的，那么只有在一个模型上会有抬升，其它的模型都没有\nShader \u0026#34;Custom/s_ten\u0026#34; { Properties{ _R(\u0026#34;R\u0026#34;,range(0,5))=1 } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float dis; float r; float _R; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { float4 wpos = mul(_Object2World,v.vertex); float2 xy = wpos.xz; float d = _R - length(xy); //d小于0则不抬升，否则抬升 d = d \u0026lt; 0 ? 0 : d; float height=1; float4 uppos = float4(v.vertex.x,height*d,v.vertex.z,v.vertex.w); v2f o; o.pos = mul(UNITY_MATRIX_MVP, uppos); //x的坐标值 float x = o.pos.x / o.pos.w; o.color = fixed4(uppos.y,uppos.y,uppos.y,1); return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 4、改变顶点的位置信息\nShader \u0026#34;Custom/s_ten\u0026#34; { Properties{ _R(\u0026#34;R\u0026#34;,range(0,5))=1 _OX(\u0026#34;OX\u0026#34;,range(-5,5))=0 } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float dis; float r; float _R; float _OX; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { float4 wpos = mul(_Object2World,v.vertex); float2 xy = wpos.xz; float d = _R - length(xy - float2(_OX,0)); //d小于0则不抬升，否则抬升 d = d \u0026lt; 0 ? 0 : d; float height=1; float4 uppos = float4(v.vertex.x,height*d,v.vertex.z,v.vertex.w); v2f o; o.pos = mul(UNITY_MATRIX_MVP, uppos); //x的坐标值 float x = o.pos.x / o.pos.w; o.color = fixed4(uppos.y,uppos.y,uppos.y,1); return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } ","permalink":"https://EitanWong.github.io/en/posts/shader/%E9%A1%B6%E7%82%B9%E4%BD%8D%E7%A7%BB/","summary":"顶点位移Shader案例 💡 length(xy): 求向量模长度 等同于sqrt(x_x+y_y); 1、抬升地面 Shader \u0026#34;Custom/s_ten\u0026#34; { Properties{ _R(\u0026#34;R\u0026#34;,range(0,5))=1 } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float dis; float r; float _R; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { //x、y坐标 float2 xy = v.vertex.xz; //求到圆心的距离，即半径 //float d = sqrt((xy.x - 0)*(xy.x - 0) + (xy.y-0)*(xy.y - 0)); //也可以使用下面的计算摸长的方式 float d = _R - length(xy);","title":"顶点位移"},{"content":"1、顶点颜色变换\n// Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Custom/s_nine\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float4x4 mvp; float4x4 rm; float4x4 sm; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; float4x4 m = mul(sm, UNITY_MATRIX_MVP); o.pos = mul(m,v.vertex); if (float(v.vertex.x) \u0026gt; 0) o.color = fixed4(1, 0, 0, 1);//显示为红色 else o.color = fixed4(0,0,1,1);//显示为蓝色 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 运行结果：中间颜色自动渐变 2、改变某个顶点的颜色值\n// Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Custom/s_nine\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float4x4 mvp; float4x4 rm; float4x4 sm; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; float4x4 m = mul(sm, UNITY_MATRIX_MVP); o.pos = mul(m,v.vertex); if (float(v.vertex.x) == 0.5\u0026amp;\u0026amp;v.vertex.y==0.5\u0026amp;\u0026amp;v.vertex.z==0.5) o.color = fixed4(1, 0, 0, 1);//显示为红色 else o.color = fixed4(0,0,1,1);//显示为蓝色 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 3、 在不同的位置，颜色不一样 4、加上时间因子后，颜色的变化\n// Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Custom/s_nine\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float4x4 mvp; float4x4 rm; float4x4 sm; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; float4x4 m = mul(sm, UNITY_MATRIX_MVP); o.pos = mul(m,v.vertex); if (float(v.vertex.x) == 0.5\u0026amp;\u0026amp;v.vertex.y == 0.5\u0026amp;\u0026amp;v.vertex.z == 0.5) o.color = fixed4(_SinTime.w/2+0.5,_CosTime.w/2+0.5,_SinTime.y/2 + 0.5,1);//显示为红色 else o.color = fixed4(0, 0, 1, 1);//显示为蓝色 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 1、在最左边是一个颜色值，在最右边又是另一个颜色值\nShader \u0026#34;Custom/s_ten\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float4x4 mvp; float4x4 rm; float4x4 sm; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP,v.vertex); //x的坐标值 float x = o.pos.x / o.pos.w; if (x \u0026lt; -1)//在屏幕最左边 o.color = fixed4(1, 0, 0, 1);//显示为红色 else if (x \u0026gt;= 1)//在屏幕最右边 o.color = fixed4(0, 0, 1, 1);//显示为蓝色 else o.color = fixed4(x/2+0.5,x/2+0.5,x/2+0.5,1); return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 在屏幕最左端时显示为一个颜色 多拷贝几个cube，可以看到灰度变化 2、使用plane，显示颜色变换光带 3、灰度在某个区间之内显示一条光带，在区间之外显示灰度\nShader \u0026#34;Custom/s_ten\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float4x4 mvp; float4x4 rm; float4x4 sm; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP,v.vertex); //x的坐标值 float x = o.pos.x / o.pos.w; if (x \u0026gt;0 \u0026amp;\u0026amp; x\u0026lt;0.1)//在屏幕最左边 o.color = fixed4(1, 0, 0, 1);//显示为红色 else o.color = fixed4(x/2+0.5,x/2+0.5,x/2+0.5,1);//灰度 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 4、随时间推移而变换的光带\nusing System.Collections; using System.Collections.Generic; using UnityEngine; public class SetFloat : MonoBehaviour { private float dis =-1; private float r = 0.1f; // Use this for initialization void Start () { } // Update is called once per frame void Update () { dis += Time.deltaTime*0.1f; GetComponent().material.SetFloat(\u0026#34;dis\u0026#34;, dis); GetComponent().material.SetFloat(\u0026#34;r\u0026#34;, r); } } Shader \u0026#34;Custom/s_ten\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float dis; float r; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; o.pos = mul(UNITY_MATRIX_MVP,v.vertex); //x的坐标值 float x = o.pos.x / o.pos.w; if (x \u0026gt;dis \u0026amp;\u0026amp; x\u0026lt;dis+r)//在屏幕最左边 o.color = fixed4(1, 0, 0, 1);//显示为红色 else o.color = fixed4(x/2+0.5,x/2+0.5,x/2+0.5,1);//灰度 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } ","permalink":"https://EitanWong.github.io/en/posts/shader/%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2%E5%8F%98%E6%8D%A2/","summary":"1、顶点颜色变换 // Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Custom/s_nine\u0026#34; { SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;unitycg.cginc\u0026#34; float4x4 mvp; float4x4 rm; float4x4 sm; struct v2f { float4 pos:POSITION; fixed4 color : COLOR; }; v2f vert(appdata_base v) { v2f o; float4x4 m = mul(sm, UNITY_MATRIX_MVP); o.pos = mul(m,v.vertex); if (float(v.vertex.x) \u0026gt; 0) o.color = fixed4(1, 0, 0, 1);//显示为红色 else o.color = fixed4(0,0,1,1);//显示为蓝色 return o; } fixed4 frag(v2f IN) :COLOR{ return IN.color; } ENDCG } } } 运行结果：中间颜色自动渐变 2、改变某个顶点","title":"顶点颜色变换"},{"content":"1.声明Properties，并使用其值 Shader \u0026#34;Custom/vertex_shader\u0026#34; { //必须位于SubShader之上 Properties{ _MainColor(\u0026#34;Main Color\u0026#34;,color) = (1,1,1,1) } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag //必须将上面的Properties名称先进行声明，且名字必须与上面的一致 float4 _MainColor; struct v2f { float4 pos:POSITION; float2 objPos:TEXCOORDO; float4 col:COLOR; }; struct appdata_base { float2 pos:POSITION; float4 color:COLOR; }; //使用结构体的方式返回，此时不需要再指定一个具体的语义 //参数也使用结构体 v2f vert(appdata_base v) { v2f o; o.pos = float4(v.pos, 0, 1); o.objPos = float2(1,0); //使用结构体默认的颜色 o.col = v.color; return o; } //使用结构体进行输入 float4 frag(v2f IN) :COLOR{ //return IN.col; return _MainColor; } ENDCG } } } Uniform 💡 Uniform关键词，定义变量从自定义的应用程序当中获取值 声明方式：\nuniform float4 _SecondColor; 完整代码：\nShader \u0026#34;Learning/VertexShader/vf2\u0026#34; { Properties { _MainColor(\u0026#34;MainColor\u0026#34;,Color)=(1,1,1,1) } SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag //引入sbin.cginc #include \u0026#34;sbin.cginc\u0026#34; float4 _MainColor; uniform float4 _SecondColor; typedef struct { float4 pos:POSITION; float2 objPos:TEXCOORD0; fixed4 col:COLOR; }v2f; v2f vert(appdata_base v) { v2f o; o.pos=float4(v.pos,0,1); o.objPos=float2(1,0); o.col=v.col; return o; } fixed4 frag(v2f IN):COLOR { return _MainColor*_SecondColor; } ENDCG } } } 💡 在上方的Shader当中，片元着色器最终输出的是_MainColor与_SecondColor相乘的结果 _MainColor在Properties中设置为白色，但是由于_SecondColor没有给其赋值，所以默认值为0，即相乘结果也为零，所以呈现黑色\n给uniform赋值 1.编写脚本\nusing UnityEngine; [ExecuteInEditMode] public class Uniform : MonoBehaviour { [SerializeField] Color secondColor; void Update(){ GetComponent().material.SetVector(\u0026#34;_SecondColor\u0026#34;, secondColor); } } 2.绑定到被渲染物体上\n效果\n由于红色RGB值为(1,0,0),G和B值无论与任何数相乘都得0，所以使用呈现红色\n修改片元着色器，颜色融合 fixed4 frag(v2f IN):COLOR { return _MainColor*0.5+_SecondColor*0.5; } 💡 两个颜色各乘0.5，再相加，颜色占比各取百分之五十，进行叠加 💡 同时可以调整相乘系数，来调整乘的权重值\nLerp插值函数 fixed4 frag(v2f IN):COLOR { return lerp(_MainColor,_SecondColor,0.9); } 💡 从_MainColor差值过度到_SecondColor, 0.9值其插值位置\n💡 Uniform 关键字 默认也可以不用写，外部也可以写入数据\n","permalink":"https://EitanWong.github.io/en/posts/shader/uniform%E4%B8%8Eproperties/","summary":"1.声明Properties，并使用其值 Shader \u0026#34;Custom/vertex_shader\u0026#34; { //必须位于SubShader之上 Properties{ _MainColor(\u0026#34;Main Color\u0026#34;,color) = (1,1,1,1) } SubShader{ pass { CGPROGRAM #pragma vertex vert #pragma fragment frag //必须将上面的Properties名称先进行声明，且名字必须与上面的一致 float4 _MainColor; struct v2f { float4 pos:POSITION; float2 objPos:TEXCOORDO; float4 col:COLOR; }; struct appdata_base { float2 pos:POSITION; float4 color:COLOR; }; //使用结构体的方式返回，此时不需要再指定一个具体的语","title":"Uniform与Properties"},{"content":"MVP矩阵是图形学中常用的一种矩阵变换方式，用于将三维世界坐标系中的物体转换到二维屏幕坐标系中进行显示。 MVP矩阵是由三个矩阵相乘得到的，它们分别是模型矩阵（Model Matrix）、视图矩阵（View Matrix）和投影矩阵（Projection Matrix）。\n模型矩阵用于将物体从自身坐标系转换到世界坐标系。 视图矩阵用于将世界坐标系中的物体转换到相机坐标系中。 投影矩阵用于将相机坐标系中的物体投影到二维屏幕坐标系中。 MVP矩阵的计算方式为：MVP = ProjectionMatrix x ViewMatrix x ModelMatrix。 使用MVP矩阵的好处是可以将多个物体同时进行变换和投影，从而提高渲染速度和效率。 需要注意的是，不同的图形库和引擎可能对MVP矩阵的计算方式和顺序有所不同，因此在使用MVP矩阵时需要了解具体的实现方式和参数设置。\n首先是MVP中的M 由模型空间经过M(模型变换)矩阵转为世界空间 将顶点坐标从模型转为世界的顺序为:先缩放,然后旋转,最后进行平移(顶点坐标变换顺序) 但书写顺序是从右向左 所以 矩阵平移矩阵旋转矩阵缩放矩阵�矩阵=平移矩阵⋅旋转矩阵⋅缩放矩阵\n将模型空间下顶点坐标×M矩阵 即可得到世界空间下顶点坐标 然后是MVP中的V 由世界空间经过V(视图变换)矩阵转为观察空间(此步在右手坐标系进行) 将顶点坐标从世界转为观察的顺序为: 1.平移整个观察空间,将相机原点和世界坐标原点重合,坐标轴重合 2.相机在世界空间先旋转,后平移 3.进行逆变换,先平移,再旋转,最后取反 矩阵旋转矩阵平移矩阵M矩阵=旋转矩阵⋅平移矩阵\n最后是MVP中的P 由观察空间经过P(投影变换)矩阵转为裁剪空间 目的:判断顶点是否在可见范围内 矩阵对进行缩放作为范围值如果在范围内则该点位于裁剪空间P矩阵:对X,Y,Z进行缩放,W作为范围值,如果XYZ在W范围内,则该点位于裁剪空间 这一步分为透视投影和正交投影两种 在Unity内置的ShaderLab中，提供了许多内置的变换矩阵\n变量名\n描述\nUNITY_MATRIX_MVP\n当前的模型观察投影矩阵，用于将顶点/方向矢量从模型空间转换到裁剪空间\nUNITY_MATRIX_MV\n当前的模型观察矩阵，用于将顶点/方向矢量从模型空间转换到观察空间\nUNITY_MATRIX_V\n当前的观察矩阵，用于将顶点/方向矢量从世界空间转换到观察空间\nUNITY_MATRIX_P\n当前的投影矩阵，用于将顶点/方向矢量从观察空间转换到裁剪空间\nUNITY_MATRIX_VP\n当前的观察投影矩阵，用于将顶点/方向矢量从世界空间转换到裁剪空间\nUNITY_MATRIX_T_MV\nUNITY_MATRIX_MV 的转置\nUNITY_MATRIX_IT_MV\nUNITY_MATRIX_MV 的逆转置矩阵，常用于将法线从模型空间转换到观察空间\n_Object2World\n当前的模型矩阵，用于将顶点/方向矢量从模型空间转换到世界空间\n_World2Object\n_Object2World 的逆矩阵，用于将顶点/方向矢量从世界空间转换到模型空间\n有了这些内置矩阵，在顶点变换时候，就有很多的方式\nv2f vert (appdata v) { v2f o; // 方式一 o.vertex = mul(UNITY_MATRIX_P, mul(UNITY_MATRIX_MV, v.vertex)); // 方式二 o.vertex = mul(UNITY_MATRIX_P, mul(UNITY_MATRIX_V, mul(_Object2World, v.vertex))); // 方式三 o.vertex = mul(UNITY_MATRIX_VP, mul(_Object2World, v.vertex)); // 方式四，通过构造一个模型观察投影矩阵，然后变换顶点坐标 float4x4 m = mul(UNITY_MATRIX_P, UNITY_MATRIX_MV); o.vertex = mul(m, v.vertex); // 方式五，最常见也是最高效的做法 o.vertex = mul(UNITY_MATRIX_MVP, v.vertex); o.uv = v.uv; return o; } 💡 在新版本的Unity当中 mul(UNITY_MATRIX_MVP, v.vertex);被替换为用函数UnityObjectToClipPos进行几何变换 UnityObjectToClipPos(v.vertex);\n完整代码 // Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Learning/GeomertricTransformation/vf1\u0026#34; { SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f{ float4 pos:POSITION; }; v2f vert(appdata_base v) { v2f o; o.pos=UnityObjectToClipPos(v.vertex); return o; } fixed4 frag(v2f IN):COLOR { return fixed4(1,1,1,1); } ENDCG } } } 采用C#实现物体自身的几何变换(理解Unity矩阵变换的过程) 1.先尝试使用模型变换到世界的矩阵✖️世界变换到摄像机✖️透视矩阵\nMatrix4x4 mvp=transform.localToWorldMatrix*Camera.main.worldToCameraMatrix* Camera.main.projectionMatrix; 2.将矩阵传入着色器，记得一定要在Update中不断更新mvp和更新数据\nGetComponent().sharedMaterial.SetMatrix(\u0026#34;_MVP\u0026#34;,mvp); 3.在着色器的顶点程序当中用传入的矩阵与模型的顶点相乘\nuniform float4x4 _MVP; struct v2f{ float4 pos:POSITION; }; v2f vert(appdata_base v) { v2f o; o.pos=mul(_MVP,v.vertex); return o; } 💡 运行时候会发现，模型并没有被正确渲染\n💡 原因是，在Unity中矩阵乘法的顺序定义有一些区别 mvp矩阵改成下方相乘顺序即可\nMatrix4x4 mvp=Camera.main.projectionMatrix*Camera.main.worldToCameraMatrix*transform.localToWorldMatrix; 最终在Game视图中可以被正确渲染， 但是在Editor中由于Scene存在另外的PreviewCamera，上面的矩阵只与游戏当中的MainCamera的矩阵相乘进行变换， 所以在Scene中的PreviewCamera并没有显示其在Scene场景中的视图变换 💡 所以，通常来说在编写Shader时，采用内置的UNITY_MATRIX_MVP即可，Unity内部已经对编辑器的PreviewCamera和运行时的Camera都做了对应的矩阵的相乘， （Unity新版本中，直接使用UnityObjectToClipPos就可以了）\n完整代码 Shader：\n// Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Learning/GeomertricTransformation/vf1\u0026#34; { SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; uniform float4x4 _MVP; struct v2f{ float4 pos:POSITION; }; v2f vert(appdata_base v) { v2f o; o.pos=mul(_MVP,v.vertex); return o; } fixed4 frag(v2f IN):COLOR { return fixed4(1,1,1,1); } ENDCG } } } C#：\nusing UnityEngine; public class MVP : MonoBehaviour { void Update() { Matrix4x4 mvp=Camera.main.projectionMatrix*Camera.main.worldToCameraMatrix*transform.localToWorldMatrix; GetComponent().sharedMaterial.SetMatrix(\u0026#34;_MVP\u0026#34;,mvp); } } 在C#中构建旋转矩阵使模型旋转 using UnityEngine; public class MVP : MonoBehaviour { void Update() { //构建绕Y轴旋转的矩阵 Matrix4x4 rm=new Matrix4x4(); rm[0,0]=Mathf.Cos(Time.realtimeSinceStartup); rm[0,2]=Mathf.Sin(Time.realtimeSinceStartup); rm[1,1]=1; rm[2,0]=-Mathf.Sin(Time.realtimeSinceStartup); rm[2,2]=Mathf.Cos(Time.realtimeSinceStartup); rm[3,3]=1; Matrix4x4 mvp=Camera.main.projectionMatrix*Camera.main.worldToCameraMatrix*transform.localToWorldMatrix; GetComponent().sharedMaterial.SetMatrix(\u0026#34;_MVP\u0026#34;,mvp); GetComponent().sharedMaterial.SetMatrix(\u0026#34;_RM\u0026#34;,rm);//传入着色器 } } // Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Learning/GeomertricTransformation/vf1\u0026#34; { SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; uniform float4x4 _MVP; uniform float4x4 _RM; struct v2f{ float4 pos:POSITION; }; v2f vert(appdata_base v) { v2f o; //将传入的旋转矩阵与顶点相乘 float4 p=mul(_RM,v.vertex); //将顶点变换到裁剪空间 o.pos=UnityObjectToClipPos(p); return o; } fixed4 frag(v2f IN):COLOR { return fixed4(1,1,1,1); } ENDCG } } } 在C#中构建缩放矩阵使模型缩放 Matrix4x4 sm=new Matrix4x4(); sm[0,0]=Mathf.Sin(Time.realtimeSinceStartup)/4+0.5f; sm[1,1]=Mathf.Cos(Time.realtimeSinceStartup)/8+0.5f; sm[2,2]=Mathf.Sin(Time.realtimeSinceStartup)/6+0.5f; sm[3,3]=1; GetComponent().sharedMaterial.SetMatrix(\u0026#34;_SM\u0026#34;,sm);//传入着色器 v2f vert(appdata_base v) { v2f o; float4 p=mul(_RM,v.vertex); //将缩放矩阵与顶点相乘 p=mul(_SM,p); o.pos=UnityObjectToClipPos(p); return o; } 在Shader内部实现模型旋转 // Upgrade NOTE: replaced \u0026#39;mul(UNITY_MATRIX_MVP,*)\u0026#39; with \u0026#39;UnityObjectToClipPos(*)\u0026#39; Shader \u0026#34;Learning/GeomertricTransformation/vf1\u0026#34; { SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag #include \u0026#34;UnityCG.cginc\u0026#34; struct v2f{ float4 pos:POSITION; }; //构建绕Y轴旋转的矩阵 float4x4 RotateY(float _Angle) { float4x4 R_M={ cos(_Angle),0,sin(_Angle),0, 0,1,0,0, -sin(_Angle),0,cos(_Angle),0, 0,0,0,1 }; return R_M; } v2f vert(appdata_base v) { v2f o; float4 p=mul(RotateY(_Time*10),v.vertex); o.pos=UnityObjectToClipPos(p); return o; } fixed4 frag(v2f IN):COLOR { return fixed4(1,1,1,1); } ENDCG } } } ","permalink":"https://EitanWong.github.io/en/posts/shader/mvp%E7%9F%A9%E9%98%B5/","summary":"MVP矩阵是图形学中常用的一种矩阵变换方式，用于将三维世界坐标系中的物体转换到二维屏幕坐标系中进行显示。 MVP矩阵是由三个矩阵相乘得到的，它们分别是模型矩阵（Model Matrix）、视图矩阵（View Matrix）和投影矩阵（Projection Matrix）。 模型矩阵用于将物","title":"MVP矩阵"},{"content":"2D变换矩阵 平移矩阵 旋转矩阵 示例代码 using UnityEngine; public class Matrix2DTransformDemo : MonoBehaviour { MeshRenderer _renderer; MeshFilter _filter; Mesh _mesh; void Awake() { if (!TryGetComponent(out _renderer)) { _renderer = gameObject.AddComponent(); _renderer.sharedMaterial = new Material(Shader.Find(\u0026#34;Standard\u0026#34;)); } if (!TryGetComponent(out _filter)) { _filter = gameObject.AddComponent(); _mesh=GenerateTriangleMesh(); _filter.sharedMesh = _mesh; } } void FixedUpdate() { Rotate(_mesh,1); } private Mesh GenerateTriangleMesh() { Mesh mesh = new Mesh(); mesh.vertices = new[] { new Vector3(0, 0.25f, 0),//0 new Vector3(0.25f, -0.25f, 0),//1 new Vector3(-0.25f, -0.25f, 0),//2 }; mesh.triangles = new[] {0,1,2}; mesh.RecalculateNormals(); return mesh; } private void Rotate(Mesh mesh,int degree) { float angle = degree * Mathf.PI/180; Vector3[] vertices = mesh.vertices; for (int i = 0; i \u0026lt; vertices.Length; i++) { vertices[i]=TransformVertex(vertices[i],angle); } mesh.SetVertices(vertices); mesh.RecalculateNormals(); } private Vector3 TransformVertex(Vector3 vertex,float angle) { var newX = vertex.x * Mathf.Cos(angle) - vertex.y * Mathf.Sin(angle); var newY = vertex.x * Mathf.Sin(angle) + vertex.y * Mathf.Cos(angle); vertex.Set(newX,newY,vertex.z); return vertex; } } 2D缩放矩阵 3D变换矩阵 3D平移矩阵 平移矩阵也称位移矩阵，平移矩阵用到了第四列（w列），这也是为什么三维空间变换矩阵为什么是四维的。平移矩阵也比较容易理解，因为可以通过结果看出想x 、y、z确实各自平移了T步。\n3D旋转矩阵 💡 绕不同的坐标轴进行旋转的3D矩阵\n3D缩放矩阵 3D旋转矩阵与平移矩阵相乘 透视投影 透视投影矩阵 变换的种类 变换的组合 C#顶点变换demo 1.编写矩阵Matrix4x4，与其对应的矩阵乘法方法\ninternal struct Matrix4x4 { float[,] elements=new float[4,4]; public Matrix4x4() { elements[0, 0] = 1; elements[1, 1] = 1; elements[2, 2] = 1; elements[3, 3] = 1; } public float this[int i, int j] { get { return elements[i - 1, j - 1]; } set {elements[i - 1, j - 1]= value;} } public Matrix4x4 Mul(Matrix4x4 matrix) { Matrix4x4 result= new Matrix4x4(); for (int h = 1; h \u0026lt;= 4; h++) { for (int l = 1; l \u0026lt;= 4; l++) { for (int n = 1; n \u0026lt;= 4; n++) { result[h, l] += this[h, n] * matrix[n, l]; } } } return result; } public Vector4 Mul(Vector4 vector) { Vector4 result=new Vector4(); result.x = this[1, 1] * vector.x + this[1, 2] * vector.y + this[1, 3] * vector.z + this[1, 4] * vector.w; result.y = this[2, 1] * vector.x + this[2, 2] * vector.y + this[2, 3] * vector.z + this[2, 4] * vector.w; result.z = this[3, 1] * vector.x + this[3, 2] * vector.y + this[3, 3] * vector.z + this[3, 4] * vector.w; result.w = this[4, 1] * vector.x + this[4, 2] * vector.y + this[4, 3] * vector.z + this[4, 4] * vector.w; return result; } } 2.编写向量Vector4，与其对应的乘法方法\ninternal struct Vector4 { public float x, y, z, w; public Vector4(float x, float y, float z, float w) { this.x = x; this.y= y; this.z = z; this.w = w; } public Vector4 Mul(Matrix4x4 matrix) { Vector4 result = new Vector4(); result.x = this.x * matrix[1, 1] + this.y * matrix[2,1]+this.z* matrix[3, 1] + this.w * matrix[4,1]; result.y = this.x * matrix[1, 2] + this.y * matrix[2, 2] + this.z * matrix[3, 2] + this.w * matrix[4, 2]; result.z = this.x * matrix[1, 3] + this.y * matrix[2, 3] + this.z * matrix[3, 3] + this.w * matrix[4, 3]; result.w = this.x * matrix[1, 4] + this.y * matrix[2, 4] + this.z * matrix[3, 4] + this.w * matrix[4, 4]; return result; } } 编写CubeMesh类，初始化顶点数据，编写绘制图形与Transform方法 internal class CubeMesh { public Vector4[] vertices; public Vector4[] vertices_transformed; public CubeMesh() { vertices =new Vector4[8]; vertices[0] = new Vector4(-0.5f, 0.5f, -0.5f, 1); vertices[1] = new Vector4(0.5f, 0.5f, -0.5f, 1); vertices[2] = new Vector4(-0.5f, -0.5f, -0.5f, 1); vertices[3] = new Vector4(0.5f, -0.5f, -0.5f, 1); vertices[4] = new Vector4(-0.5f, 0.5f, 0.5f, 1); vertices[5] = new Vector4(0.5f, 0.5f, 0.5f, 1); vertices[6] = new Vector4(-0.5f, -0.5f, 0.5f, 1); vertices[7] = new Vector4(0.5f, -0.5f, 0.5f, 1); vertices_transformed = new Vector4[8]; } public void Transform(Matrix4x4 matrix) { for (int i = 0; i \u0026lt; vertices.Length; i++) { vertices_transformed[i] = vertices[i].Mul(matrix); } } private PointF GetPoint( Vector4 vector) { return new PointF(vector.x/vector.w, vector.y / vector.w); } public void Draw(Graphics g) { Pen pen = new Pen(Color.Red); g.DrawLine(pen, GetPoint(vertices_transformed[0]), GetPoint(vertices_transformed[1])); g.DrawLine(pen, GetPoint(vertices_transformed[1]), GetPoint(vertices_transformed[3])); g.DrawLine(pen, GetPoint(vertices_transformed[3]), GetPoint(vertices_transformed[2])); g.DrawLine(pen, GetPoint(vertices_transformed[2]),GetPoint(vertices_transformed[0])); g.DrawLine(pen, GetPoint(vertices_transformed[4]), GetPoint(vertices_transformed[5])); g.DrawLine(pen, GetPoint(vertices_transformed[5]), GetPoint(vertices_transformed[7])); g.DrawLine(pen, GetPoint(vertices_transformed[7]), GetPoint(vertices_transformed[6])); g.DrawLine(pen, GetPoint(vertices_transformed[6]), GetPoint(vertices_transformed[4])); g.DrawLine(pen, GetPoint(vertices_transformed[0]), GetPoint(vertices_transformed[4])); g.DrawLine(pen, GetPoint(vertices_transformed[1]), GetPoint(vertices_transformed[5])); g.DrawLine(pen, GetPoint(vertices_transformed[2]), GetPoint(vertices_transformed[6])); g.DrawLine(pen, GetPoint(vertices_transformed[3]), GetPoint(vertices_transformed[7])); } } 编写TransformHelper类，获取对应变换方式的矩阵 internal static class TransformHelper { public static Matrix4x4 ScaleMatrix4x4(float x,float y,float z) { Matrix4x4 matrix= new Matrix4x4(); matrix[1, 1] = x; matrix[2, 2] = y; matrix[3, 3] = z; matrix[4, 4] = 1; return matrix; } public static Matrix4x4 RotateYMatrix4x4(float angle) { Matrix4x4 matrix = new Matrix4x4(); matrix[1, 1] = MathF.Cos(angle); matrix[1,3]=MathF.Sin(angle); matrix[3, 1] = -MathF.Sin(angle); matrix[3,3]=MathF.Cos(angle); matrix[2, 2] = 1; matrix[4, 4] = 1; return matrix; } public static Matrix4x4 TranslateMatrix4x4(float x,float y,float z) { Matrix4x4 matrix = new Matrix4x4(); matrix[1, 1] = 1; matrix[2, 2] = 1; matrix[3, 3] = 1; matrix[4, 4] = 1; matrix[4, 1] = x; matrix[4, 2] = y; matrix[4, 3] = z; return matrix; } public static Matrix4x4 ProjectionMatrix4x4(float fov) { Matrix4x4 matrix = new Matrix4x4(); matrix[1, 1] = 1; matrix[2, 2] = 1; matrix[3, 3] = 1; matrix[4, 4] = 1; matrix[3, 4] = 1/fov; return matrix; } } 5.主窗体上添加Timer，每一帧中进行矩阵的相乘，并将该矩阵变换于CubeMesh，调用Draw方法绘制\npublic partial class MainForm : Form { CubeMesh mesh; Matrix4x4 Scale_Matrix; Matrix4x4 RotateY_Matrix; Matrix4x4 View_Matrix; Matrix4x4 Projection_Matrix; float angle; float distance=500; float x,y,z; float moveSpeed=100; public MainForm() { InitializeComponent(); } private void MainForm_Load(object sender, EventArgs e) { mesh = new CubeMesh(); Scale_Matrix=TransformHelper.ScaleMatrix4x4(500, 500, 500); RotateY_Matrix = TransformHelper.RotateYMatrix4x4(0.1f); } private void MainForm_KeyPress(object sender, KeyPressEventArgs e) { switch (e.KeyChar) { case\u0026#39;w\u0026#39;: z -= moveSpeed; break; case \u0026#39;s\u0026#39;: z += moveSpeed; break; case \u0026#39;a\u0026#39;: x += moveSpeed; break; case \u0026#39;d\u0026#39;: x -= moveSpeed; break; case \u0026#39;q\u0026#39;: y -= moveSpeed; break; case \u0026#39;e\u0026#39;: y += moveSpeed; break; default: break; } //Debug.WriteLine(e.KeyChar); } private void MainForm_Paint(object sender, PaintEventArgs e) { e.Graphics.TranslateTransform(this.Width / 2, this.Height / 2); mesh.Draw(e.Graphics); } private void UpdateTimer_Tick(object sender, EventArgs e) { angle += 0.005f; View_Matrix = TransformHelper.TranslateMatrix4x4(x, y, z); Projection_Matrix = TransformHelper.ProjectionMatrix4x4(distance); RotateY_Matrix = TransformHelper.RotateYMatrix4x4(angle); var m = Scale_Matrix.Mul(RotateY_Matrix).Mul(View_Matrix).Mul(Projection_Matrix); mesh.Transform(m); this.Invalidate(); } } 最终效果 ","permalink":"https://EitanWong.github.io/en/posts/shader/%E7%9F%A9%E9%98%B5%E5%92%8C%E5%8F%98%E6%8D%A2/","summary":"2D变换矩阵 平移矩阵 旋转矩阵 示例代码 using UnityEngine; public class Matrix2DTransformDemo : MonoBehaviour { MeshRenderer _renderer; MeshFilter _filter; Mesh _mesh; void Awake() { if (!TryGetComponent(out _renderer)) { _renderer = gameObject.AddComponent(); _renderer.sharedMaterial = new Material(Shader.Find(\u0026#34;Standard\u0026#34;)); } if (!TryGetComponent(out _filter)) { _filter = gameObject.AddComponent(); _mesh=GenerateTriangleMesh(); _filter.sharedMesh = _mesh; } } void FixedUpdate() { Rotate(_mesh,1); } private Mesh GenerateTriangleMesh() { Mesh mesh = new Mesh(); mesh.vertices = new[] { new Vector3(0, 0.25f, 0),//0 new Vector3(0.25f, -0.25f, 0),//1 new Vector3(-0.25f, -0.25f, 0),//2 }; mesh.triangles = new[] {0,1,2}; mesh.RecalculateNormals(); return mesh; } private void Rotate(Mesh mesh,int degree) { float angle = degree * Mathf.PI/180; Vector3[] vertices = mesh.vertices; for (int i = 0; i \u0026lt; vertices.Length; i++) { vertices[i]=TransformVertex(vertices[i],angle); } mesh.SetVertices(vertices); mesh.RecalculateNormals(); } private Vector3 TransformVertex(Vector3 vertex,float angle) { var newX = vertex.x","title":"矩阵和变换"},{"content":"案例 在mesh网格中立方体的范围从-0.5到+0.5，当传入POSITION数据时才用了float2类型， 实际上只传入了xy两个分量，输出的pos经过float4重置组合，将w分量设为1，为了保证矩阵相乘时结果不出错， 把这样的pos传给片元着色器时，片元程序默认pos已经经过矩阵变换了， 所以就将其映射到设备空间，在设备空间当中，最左边到最右边的x值与y值，是从-1到+1， 所以随着屏幕的缩小与放大，这个图形总是等比例适配于屏幕空间 这类的Shader不是大多数使用的，如果要做关于UI的系统，可以在用这类Shader的原理 （在实际UI系统当中，还要考虑到让图形显示在所有场景的最上面，也就是最靠近摄像机的位置，当然还考虑到资源架构的组织问题）\nvoid vert(in float2 objPos:POSITION,out float4 pos:POSITION,out fixed4 col:COLOR) { pos=float4(objPos,0,1); col=pos; } void frag(inout fixed4 col:COLOR) { float arr[]={0.5,0.5}; col.y=Func2(arr); } 输入与输出 作为一个顶点程序，其实可以有返回值的 （修改前）\nvoid vert(in float2 objPos:POSITION,out float4 pos:POSITION,out fixed4 col:COLOR) { pos=float4(objPos,0,1); col=pos; } （修改后）\nfloat4 vert(in float2 objPos:POSITION,out float4 pos:POSITION): COLOR { pos=float4(objPos,0,1); return pos; } 💡 将col作为顶点程序的返回值返回，类型为float4，顶点程序后面，要加上语义，以表示返回值的语义，例如上方在vert顶点程序中加上了: COLOR,说明返回值返回的是一个float4类型的COLOR颜色 如果没有写上语义，将无法编译此着色器，导致报错\n其实函数可以带上语义的 frag片元函数也一样\nfixed4 frag(in fixed4 col:COLOR):COLOR { float arr[]={0.5,0.5}; col.y=Func2(arr); return col; } 语义重复 在下方程序当中，objPos，定义为inout，既是输入又是输入，输出的POSITION语义与pos输出的语义重复了，片段程序不知道哪一个才是vert输出的POSITION，所以导致该着色器编译失败，出现报错\nfloat4 vert(inout float2 objPos:POSITION,out float4 pos:POSITION): COLOR { pos=float4(objPos,0,1); return pos; } Unity当中语义本身不能重复，可以有多个输出，但一个语义只能有一个输出\nfloat4 vert(in float2 objPos:POSITION,out float4 pos:POSITION,out float2 opos:POSITION): COLOR { pos=float4(objPos,0,1); return pos; } fixed4 frag(in float2 opos:POSITION,in fixed4 col:COLOR):COLOR { float arr[]={0.5,0.5}; col.y=Func2(arr); return col; } 在下方的的vert函数中out输出的opos的语义COLOR与vert函数返回值输出的语义COLOR也发生的重复，所以导致了着色器编译不通过报错\nfloat4 vert(in float2 objPos:POSITION,out float4 pos:POSITION,out float2 opos:COLOR): COLOR { pos=float4(objPos,0,1); opos=float2(1,1); return pos; } 将vert中的模型坐标传给frag 在下方的Shader程序当中将传入的POSITION也就是objPos赋值给opos，由于都是float2类型，所以可以互相赋值 💡 语义只是强调参数的环境与具体用途，语义不同，只要类型相同就可以赋值\nfloat4 vert(in float2 objPos:POSITION,out float4 pos:POSITION,out float2 opos:TEXCOORD0): COLOR { pos=float4(objPos,0,1); opos=objPos; return pos; } fixed4 frag(in float2 opos:TEXCOORD0,in fixed4 col:COLOR):COLOR { float arr[]={0.5,0.5}; col.y=Func2(arr); return col; } 结构体 在实际编写过程中，着色器通常需要输入输出多个参数。结构体的作用在于可以同时将顶点坐标、法线向量和第一套UV等传入到顶点着色器，然后再同时输出裁切空间的顶点坐标、世界空间顶点坐标、世界空间法线向量和纹理坐标到片段着色器。 由于函数有多个输入输出，结构体可以让代码编写更加方便，且美观。\n结构体的语法 结构体允许存储多个不同类型的变量，并且将多个变量包装成为一个整体进行输入或者输出。 结构体语法如下：\nstruct Type { //变量 }; 例如：\nstruct v2f{ float4 pos:POSITION; float2 objPos:TEXCOORD0; }; 在vert与frag函数中传入此结构体\nstruct v2f{ float4 pos:POSITION; float2 objPos:TEXCOORD0; }; v2f vert(in float2 objPos:POSITION) { v2f v; v.pos=float4(objPos,0,1); v.objPos=objPos; return v; } fixed4 frag(in float4 pos: POSITION,in float2 opos:TEXCOORD0):COLOR { return float4(opos,0,1); } 💡 要注意，结构体必须要声明在使用的函数前面，否则将出现如下报错\n别名 在声明struct的时候，也可以通过别名的方式，进行声明 给结构体起一个别名，如：\ntypedef ![struct](https://so.csdn.net/so/search?q=struct\u0026amp;spm=1001.2101.3001.7020) ABC{ ... }S; 这就为结构体ABC定义了一个别名S。以后写S x；就等价于写struct ABC x 。 例如：\ntypedef struct { float4 pos:POSITION; float2 objPos:TEXCOORD0; }v2f; 💡 但要注意CG语言当中不像C语言，是不支持指针，所以在别名时，也不能使用*p指针\n完整代码 Shader \u0026#34;Learning/CGPROGRAM/vf3\u0026#34; { SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag float Func2(float arr[2]) { float sum=0; for (int i=0;i💡 这样的组织方式，可以保证以后要编写的着色器都可以引用cginc文件，不用重复编写结构体 Shader \u0026ldquo;Learning/CGPROGRAM/vf3\u0026rdquo; { SubShader { pass{ CGPROGRAM #pragma vertex vert #pragma fragment frag //引入sbin.cginc #include \u0026ldquo;sbin.cginc\u0026rdquo; typedef struct { float4 pos:POSITION; float2 objPos:TEXCOORD0; fixed4 col:COLOR; }v2f; v2f vert(appdata_base v) { v2f o; o.pos=float4(v.pos,0,1); o.objPos=float2(1,0); o.col=v.col; return o; } fixed4 frag(v2f IN):COLOR { return IN.col; } ENDCG } } }\n## UnityShaderLab中Build in的结构体 包含在UnityCG.cginc当中 struct appdata_base { float4 vertex : POSITION;//顶点，(采用4维向量) float3 normal : NORMAL;//法向量 float4 texcoord : TEXCOORD0;//纹理坐标 UNITY_VERTEX_INPUT_INSTANCE_ID }; //正切， struct appdata_tan { float4 vertex : POSITION; float4 tangent : TANGENT;//切线数据 float3 normal : NORMAL; float4 texcoord : TEXCOORD0; UNITY_VERTEX_INPUT_INSTANCE_ID }; //能够为顶点着色器，提供的所有数据 struct appdata_full { float4 vertex : POSITION; float4 tangent : TANGENT; float3 normal : NORMAL; float4 texcoord : TEXCOORD0; float4 texcoord1 : TEXCOORD1; float4 texcoord2 : TEXCOORD2; float4 texcoord3 : TEXCOORD3; fixed4 color : COLOR; UNITY_VERTEX_INPUT_INSTANCE_ID }; ``` 💡 在着色器当中，顶点程序，需要从应用程序中接受它要使用的参数， 其主要内容，就是顶点当中应当包括的信息，为了能够结构话组织数据的输入， 可以利用结构体对数据进行包装，经过结构体对包装之后，就可以在结构体的成员当中使用提供给顶点程序的数据 💡 由于顶点程序向片元程序输出的数据，由于需求目的不同，所以无法在每一个着色器当中去确定哪些是需要用到的数据，于是无法做一个统一的方式写在cginc当中 当然如果在某些特殊的需求下，固定传入的数据的情况下，可以写在自定义的cginc当中\n","permalink":"https://EitanWong.github.io/en/posts/shader/vertex%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","summary":"案例 在mesh网格中立方体的范围从-0.5到+0.5，当传入POSITION数据时才用了float2类型， 实际上只传入了xy两个分量，输出的pos经过float4重置组合，将w分量设为1，为了保证矩阵相乘时结果不出错， 把这样的pos传给片元着色器时，片元程序默认pos已经经过矩阵","title":"Vertex数据的输入与输出"},{"content":"概述 计算机显示器是一个2D平面。OpenGL渲染时必须将一个3D的场景投影在屏幕上成为一个2D的图片。GL_PROJECTION矩阵的就是用作这种投影变换。首先，其将所有的顶点数据从视觉坐标系（眼坐标系）转化到裁剪空间。然后，通过除以裁剪坐标系中的w分量，将转化后的裁剪坐标变换成标准设备坐标系（NDC）。 因此，我们必须记住GL_PROJECTION集成了裁剪和转化成标准设备坐标系的功能。下面的模块讲述了，如何从以下6个参数建立投影矩阵：left、right、bottom、top、near和far等边界值。 需要注意的是，裁剪空间中的平头截体的裁剪过程发生在，除以wc分量之前。将裁剪坐标 xc, yc和zc和wc进行比较，如果其中任意一个值小于wc或者大于wc，那么这个顶点将会被裁剪掉，渲染时会丢弃这个顶点。\nwc \u0026lt; xc,yc,zc \u0026lt; wc 当裁剪发生时，OpenGL会重新构建裁剪的边界和边线。\n透视投影 在透视投影时，裁剪截体是一个锥形的，然后被映射到标准设备坐标系中（一个立方体），NDC的x、y和z轴的范围都是从-1至+1。 注意，视觉坐标系是右手坐标系，而NDC使用的是左手坐标系，它们的z值方向是相反的，在视觉坐标系中，摄像机在原点，观察方向为z轴的负值方向，但是在NDC中，摄像机的观察方向却是z轴的正值方向。因此，glFrustum()的near和far参数必须大于0，所以在构建GL_PROJECTION矩阵时，我们必须对它们取反。\n在openGL中，视觉空间中一个3D的点会被投影在近平面上（投影面）。下面的示意图展示了视觉坐标系中的点(xe, ye, ze)是如何投影到近平面上的(xp, yp, zp)的。\n从上向下看向锥形截体，视觉坐标系的x坐标，xe会被映射到xp，可以通过相似三角形比例特性计算出xp：\n从侧面看向锥形截体，可以通过同样的方法，计算出yp:\n可以看到，xp和yp都依赖于ze,并且和-ze成反比的关系。换句话说，它们都被-ze除。这是构建GLPROJECTION矩阵的第一个线索。当视觉坐标系的坐标通过乘以GLPROJECTION矩阵转化成裁剪坐标，转化后的裁剪坐标任然是一个 。最后通过除以w分量，转化成标准设备坐标系（NDC）。（可以在 中了解更多细节。）\n因此，我们可以将裁剪坐标的第四个分量设置为-ze. 因此GL_PROJECTION矩阵的第四行变成了(0, 0, -1, 0).\n接下来，我们将xp和yp映射到标准设备坐标系中的xn和yn, 可以使用如下线性关系进行映射：[l, r] =\u0026gt; [-1, 1] 和[b, t] =\u0026gt; [-1, 1]。\n然后，我们把上面等式中的xp和yp替换掉。\n注意，上面的等式中，最后都转化为除以-ze，这正好与透视除法（xc/wc, yc/ wc）对应。在此之前，我们已经将wc设置为-ze了，因此等式括号中的部分，变成了xc和yc。 通过这些等式，我们可以得出GL_PROJECTION矩阵的第一行和第二行。\n现在，我们只需要再计算GLPROJECTION矩阵的第三行了。计算zn和计算xn、yn有点不同，因为视觉坐标系中的ze总是被投影到近平面（-n）上。但是我们需要一个独特的z值进行裁剪和深度测试。而且，我们还能够对其逆投影（逆转换）。因为z与x和y无关，我们可以借助w分量来寻找zn和ze的关系。因此我们可以指定GLPROJECTION矩阵的第三行如下：\n在视觉坐标系中we等于1，所以等式变成了：\n为了计算出系数A和B, 可以利用(ze, zn)的关系；(-n, -1)和(-f, 1), 将他们放进上面的等式中：\n计算出A和B的值：\n我们得到了A和B的值，所以ze和zn的关系变成：\n最后我们得到了完整的GL_PROJECTION矩阵：\n上面的投影矩阵是一个通用锥形截体的矩阵，如果视觉空间是对称的，满足r=-l并且t=-b，我们可以将上面的矩阵简化如下：\n在讨论正射投影之前，我们在重新看一下ze和zn的关系。通过等式3，你注意到这是一个关系函数，但是ze和zn并不是线性关系。这意味着，离近平面越近精度越高，离近平面越远精度越低。如果[-n, -f]的范围越大，它会导致精度问题（z-fighting）；在远平面附近的点的ze值发生很小的变化并不会影响zn的值。所以n和f的差值尽量小，这样可以减少深度缓冲的精度问题。\n正射投影 正射投影矩阵的建立比透视投影矩阵的建立会简单很多。 视觉空间坐标系中的xe，ye和ze分量，都会被线性的映射到标准设备坐标系（NDC）中。仅需要缩放视觉空间到标准设备空间（范围是-1~+1）中，然后将其移动到原点位置。接下来通过线性关系，计算GL_PROJECTION正射投影矩阵的各个值。\n因为正射投影不需要w分量，所以矩阵的第四行仍然为(0, 0, 0, 1)。因此完整的GL_PROJECTION正射投影矩阵如下：\n如果截体区域是对称的r=-l并且t=-b, 矩阵可以简化如下：\n","permalink":"https://EitanWong.github.io/en/posts/shader/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%B8%89/","summary":"概述 计算机显示器是一个2D平面。OpenGL渲染时必须将一个3D的场景投影在屏幕上成为一个2D的图片。GL_PROJECTION矩阵的就是用作这种投影变换。首先，其将所有的顶点数据从视觉坐标系（眼坐标系）转化到裁剪空间。然后，通过除以裁剪坐标系中的w分量，将转化后的裁剪坐标变换成","title":"3D图形学中的矩阵变换（三）"},{"content":"一. 摄像机 这里涉及到三维图形学中的摄像机的概念。大家肯定都玩过游戏，现在游戏发展速度都特别快，很多游戏世界都是3D的，例如国外的荒野大镖客、巫师以及国内最近比较火的原神。游戏世界中所有的物体，例如桌子、树木、动物以及交通工具等等，它们在游戏世界中都有一个特定的位置，这个位置就是它们在游戏世界中的坐标，我们把它们在游戏世界中的位置称为世界坐标。假如同时有两个玩家A和B在游戏世界中漫游，那么这两个玩家的屏幕肯定显示的是不一样的，因为玩家在世界坐标系中的位置（世界坐标）不一样，并且视线的方向也不同，所以他们看到的屏幕肯定是不一样的。这里的A和B玩家，其实就是摄像机。假设我们以摄像机（玩家）为原点创建一个新的坐标系，可以称它为摄像机坐标系（观察空间坐标系）。那么同样的物体在世界坐标系中坐标为（300，200），那么它用摄像机坐标系如何表示呢？我用二维图形描述下这个问题。\n假设平面中有一点A，此时点A的坐标为(1, 1)，表示A点在如图所示的坐标系中在原点右侧1个单位，上方1个单位。如果将这个坐标系旋转45度，变成另一个坐标系X2Y2，那么在新的坐标系X2Y2中如何表示A点呢？\n旋转45度，很容易计算出来A点在X2Y2坐标系中的坐标为(√2, 0)。那么有没有一个矩阵A可以使得A·P1 = P2，也就是经过矩阵A的变换，P1坐标变成了P2。这里P1表示在原来的坐标系中的坐标，P2表示在新的坐标系中同一个点的坐标表示。其实这里的A就是本篇文章要讨论的lookAt矩阵。 LookAt矩阵的作用就是，将世界坐标系中的物体坐标转换为用摄像机坐标系统描述，说白了就是在不同坐标系中描述同一个位置。 下面是learnopengl_cn官网给出的解释：\n当我们讨论摄像机/观察空间(Camera/View Space)的时候，是在讨论以摄像机的视角作为场景原点时场景中所有的顶点坐标：观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标。\n二. 深入线性变换矩阵 首先我给大家讲述一个很重要的事实，在我上篇文章中说的几个变换矩阵，线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示，即i帽、j帽和k帽。请牢牢记住这一重要特性，因为这一个特性真的很重要，它会直接影响你的线性代数的思维。你可能现在还没有认识到这一特征，没关系，请继续阅读。\n还是以之前的A点的例子为例，来说明这一思想。A点坐标是(1, 1), 向量OA也是(1, 1)，用i帽和j帽表示的话OA = 1 i + 1 j。\n此时，我们将坐标系旋转45度，变成下图所示。这里我顺便小小的提一下，线性变换就是保证我画的网格线平行且等距分布，这也是为什么我会画一些网格在图中，上一篇文章讲解的几个变换矩阵都是线性变换。\n正是因为是线性变换，所以变换后的A点满足如下公式：OA = 1 i2 + 1 j2。因为旋转45度，所以我们计算出i2和j2分别为(√2 / 2, √2 / 2)和(-√2 / 2, √2 / 2)。所以OA = (0, √2 )。\n请仔细阅读我上图中的计算步骤，请保证你能看懂整个计算过程。 上图中我写了一个变换矩 阵，这个变换矩阵其实就是我们旋转45度的旋转矩阵。细心的朋友已经发现了，矩阵的第一列就是变换后的i帽，第二列就是变换后的j帽。所以还记得我之前说的那个真理吗？ 线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示。\n三.逆矩阵 还是用之前的例子，我们将变换前的坐标系称为xyo, 变换后的坐标系称为x2y2o。xyo-\u0026gt; x2y2o的变换矩阵如下（后面我将其称为MatA），每一列表示的是x2y2o坐标系的x和y方向的单位向量在xyo坐标系中的表示。所以将这个矩阵乘以一个坐标，其实得到的是一个在xyo坐标系中表示的坐标。\n例如，例如点A(1, 1)，计算MatA · A = B,得到的点B是经过线性变换后A的坐标，但是这个坐标还是用xyo坐标系表示的， 点A的坐标却是在x2y2o坐标系中的表示。所以这里MatA的作用就是将x2y2o坐标系的表示转化为xyo坐标系表示。那么反过来呢，xyo -\u0026gt; x2y2o如何转换？ 这里引入逆矩阵的思想，逆矩阵表示相反的线性变换， 由MatA · A = B得到 A = （MatA^-1) · B ， MatA^-1 表示的是MatA的逆矩阵。所以有MatA · A = B和A = （MatA^-1) · B这两个公式，就可以得到同一点在xyo和x2y2o中的表示方法。 这不正是lookAt矩阵的作用吗？lookAt矩阵就是在不同坐标系下如何表示同一点。\n四.lookAt矩阵 其实这部分类容已经不重要了，因为通过上面的学习，你已经知道如何去转换坐标系了。但是我还是简单的介绍下learnOpengl_cn官网的lookAt矩阵吧。 LookAt矩阵如下， (Rx, Ry, Rz)表示摄像机的X轴方向向量，(Ux, Uy, Uz)表示摄像机坐标系的Y轴方向，(Dx, Dy, Dz)表示摄像机的视线方向及Z轴。 (Px, Py, Pz)表示摄像机位置的世界坐标。\n通过上面的阅读，现在看这个矩阵，你能否自己给出证明呢? 矩阵的第二部分，是一个平移矩阵，目的是平移到(px, py, pz)，矩阵中px,py,pz都加上了负号，是因为这里移动的不是摄像机而是整个场景，将场景向相反方向移动等价于移动摄像机。矩阵的第一部分就是一个线性变换的逆矩阵。计算逆矩阵通常需要计算非逆矩阵，那么非逆矩阵是什么呢？我在第二节内容说到，线性变换矩阵的每一列表示的都是变换后的坐标系的x、y、z轴的单位向量的表示。所以由 (Rx, Ry, Rz), (Ux, Uy, Uz), (Dx, Dy, Dz), 我们很容易写出线性变换矩阵。\n这个线性变换矩阵我用Mat1表示，平移矩阵用Mat2表示，所以lookAt矩阵如下： LookAt = (Mat1^-1) · Mat2。 逆矩阵的计算并不重要，写代码时，一般可以直接用函数去求解逆矩阵，重要的是你要理解我在本篇文章介绍的思想。本篇文章可能不是很好理解，我已经把我理解的尽可能详细的去描述讲解出来了，你可以多读几遍，带入思考去阅读。\n","permalink":"https://EitanWong.github.io/en/posts/shader/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%BA%8C/","summary":"一. 摄像机 这里涉及到三维图形学中的摄像机的概念。大家肯定都玩过游戏，现在游戏发展速度都特别快，很多游戏世界都是3D的，例如国外的荒野大镖客、巫师以及国内最近比较火的原神。游戏世界中所有的物体，例如桌子、树木、动物以及交通工具等等，它们在游戏世界中都有一个特定的位置，这个位置就是它","title":"3D图形学中的矩阵变换（二）"},{"content":"一. 点和向量 平面中任意一个点可以用一个二元数列表示，在笛卡尔坐标系中(0, 0)点表示原点，(1, 1)表示原点往x轴方向移动1步，往y轴方向移动1步得到的点，而向量就形象的表示了这一过程，(0, 0)至(1, 1)点的向量就是(1 - 0, 1 - 0)，即(1, 1)。向量是一个表示方向和大小的概念，在物理中可以用来表示力和速度。在三维中，点和向量用三元数列表示(x, y, z)，任意一组xyz值可以唯一确定一个点和一个向量。\n二. 变换矩阵 在图形学中，在做平移，旋转和缩放时，经常会用到矩阵，有缩放矩阵、平移矩阵和旋转矩阵。在三维空间中，变换矩阵都是一个四维矩阵，每一行分别表示x, y, z, w。为什么是四维的而不是三维的呢？请继续往下阅读。\n1. 缩放矩阵（scale） 上面的公式，左边的第一个操作数（四维矩阵）就是一个缩放矩阵，s1表示x轴的缩放倍数，s2表示y轴的缩放倍数，s3表示z轴的缩放倍数。第二个操作数表示空间中(x, y, z)点， w分量在缩放矩阵中没有用到，我们将其设为1。由右边的结果，可以看出(x, y, z)点经过缩放矩阵变换后，x、y、z分量都各自缩放了s(s1、s2、s3)倍。需要注意的是矩阵的乘法不具有交换律，这里点是用一维列矩阵表示的，作为矩阵乘法的右操作数。如果将其转换到乘法的左边，那么点应该用一维行矩阵表示：\n缩放矩阵比较简单，不需要证明，只需要会简单的乘法，就可以看出x,y,z经过缩放矩阵的变换确实被缩放了。\n2.平移矩阵（translation） 平移矩阵也称位移矩阵，平移矩阵用到了第四列（w列），这也是为什么三维空间变换矩阵为什么是四维的。平移矩阵也比较容易理解，因为可以通过结果看出想x 、y、z确实各自平移了T步。\n3. 旋转矩阵 旋转矩阵，相对难一些，也不是那么容易理解，我们先看最基础的绕x、y、z轴旋转的旋转矩阵。 沿x轴：\n沿y轴：\n沿z轴：\n引入了三角函数，我们无法从结果看出旋转矩阵是否正确，所以我们需要证明。下面我给出沿z轴旋转的变换矩阵证明过程，其他轴同理可证。\n假设有如图的点p1，因为绕z轴旋转，点的z值是不变的，我们将其设为0，这样可以将其模拟成二维平面xy中旋转。假设p1绕原点旋转b角度，初始角度为a。整个证明过程如下：\n// 经过旋转后向量的长度不变为L(原点到p1和p2的距离相同) // 由三角函数得到sin(a + b), cos(a + b)的值 cos(a + b) = x2 / L; sin(a + b) = y2 / L; // 展开sin(a + b)和cos(a + b) cos(a) cos(b) - sin(a) sin(b) = x2 / L; sin(a) cos(b) + cos(a) sin(b) = y2 / L; // 用x和y表示cos(a)和sin(a) x / L cos(b) - y / L sin(b) = x2 / L; y / L cos(b) + x / L sin(b) = y2 / L; // 等式两边同时乘以L x cos(b) - y sin(b) = x2; y cos(b) + x sin(b) = y2; 将x2和y2的结果与上面z轴旋转矩阵结果比较，发现是完全一样的。 按照上面的方法同理可证绕x轴旋转和绕z轴旋转的矩阵。 那么绕任意轴旋转的矩阵呢？ 直接给出了绕任意轴旋转的矩阵，(Rx, Ry, Rz)表示任意轴，θ表示旋转的矩阵。这个矩阵证明比较复杂。\n我就不去给大家证明了，我给出证明的思路，大家可以自己尝试去证明。 first，我们可以将绕任意轴旋转转换成绕x，y，z轴旋转。所以先将轴(Rx, Ry, Rz)转换成某一个轴，例如转换成z轴。如图将轴绕Y轴旋转θ角度至yz平面。\n在将轴绕x轴旋转a角度至z轴重合。\n现在物体绕该轴旋转，就是绕z轴旋转了。旋转完成后，我们还需要将旋转轴恢复至最初的位置，即将上面的步骤逆操作一遍，先绕x轴旋转-a角度，再按照y轴旋转-θ角度。这一系列变换最后得到的矩阵就是绕任意轴旋转的矩阵。\n","permalink":"https://EitanWong.github.io/en/posts/shader/3d%E5%9B%BE%E5%BD%A2%E5%AD%A6%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E5%8F%98%E6%8D%A2%E4%B8%80/","summary":"一. 点和向量 平面中任意一个点可以用一个二元数列表示，在笛卡尔坐标系中(0, 0)点表示原点，(1, 1)表示原点往x轴方向移动1步，往y轴方向移动1步得到的点，而向量就形象的表示了这一过程，(0, 0)至(1, 1)点的向量就是(1 - 0, 1 - 0)，即(1, 1)。向量是一个表示方向和大小的概","title":"3D图形学中的矩阵变换（一）"},{"content":"逆的定义 $$ 矩阵的逆可以理解为 如果有一个矩阵M，它与它的逆M^{-1}相乘能够得到单位矩阵I $$ $$ 那么矩阵M^{-1}和矩阵M互为逆的关系 $$\n矩阵的逆满足于不管是左乘还是右乘它的逆，都能够得到单位矩阵 矩阵的求逆是一个重要的矩阵运算，这个运算只能用于方阵。 相乘时，结果时单位矩阵。用公式表示：\n$$ 方阵M的逆，记作M^{-1}，也是一个矩阵，当M与M^{-1} $$\n并非所有矩阵都有逆。一个明显的例子是若矩阵的某一行或列上的元素都为零，用任何矩阵乘以该矩阵，结果都是一个零矩阵。 如果一个矩阵有逆矩阵，那么称它为可逆的或非奇异的。如果一个矩阵没有逆矩阵，则称它为不可逆的或奇异矩阵。 奇异矩阵的行列式为零，非奇异矩阵的行列式不为零，所以检测行列式的值式判断矩阵是否可逆的有效方法。 $$ 此外，对于任意可逆矩阵M，当且仅当v = 0 v=0v=0时，v M = 0 vM=0vM=0 $$\n计算矩阵的逆 💡 要计算一个矩阵的逆，前提是，它得是一个方阵 💡 如果一个方阵它的行列式为0，那么这个矩阵被称为奇异矩阵，它就没有逆 要求矩阵的逆，必须要保证其行列式不为0\n1.计算M的代数余子式矩阵 2.标准伴随矩阵 当得到M矩阵的代数余子式矩阵过后，需要把这个代数余子式矩阵进行一个转置 转置过后的代数余子式矩阵就叫做原矩阵的标准伴随矩阵\n3.矩阵求逆 💡 用伴随矩阵去除以M矩阵的行列式，M矩阵的行列式的结果是一个标量值 伴随矩阵和原矩阵阶数相同，用adjM除以行列式的结果，即可得出M的逆\n定义检验 矩阵逆的性质 矩阵逆的重要性质：\n如果M时非奇异矩阵，则该矩阵的逆的逆等于原矩阵$(m^{-1})^{-1}=M$ 单位矩阵的逆是它本身：$I^{-1}=I$ 矩阵转置的逆等于它的逆的转置：$（M^T）^{-1}=(M^{-1})^T$ 矩阵乘积的逆等于矩阵的逆的相反顺序的乘积：$(AB)^{-1}=B^{-1}A^{-1}$。这可扩展到多个矩阵的情况：$(M_1M_2…M_{m-1}M_m)^{-1}=M_m^{-1}M_{m-1}^{-1}…M_2^{-1}M_1^{-1}$ 正交矩阵和逆 💡 若方阵M是正交的，则当且仅当$M$与它转置$M^T$的乘积等于单位矩阵 当$M$与它转置$M^T$的乘积等于单位矩阵，则M是正交 $M正交⇔MM^T=I$\n💡 如果我们能够预先知道某些矩阵是正交的，那么我们就能避免计算这个矩阵的逆 💡 仅拥有旋转或仅拥有镜像的矩阵，它们的行列式为1，如果要撤销其变换，就不用求其逆，应为它是正交的所以将其转置直接可以得到它的逆 💡 正交矩阵满足一些条件 每一行每一列都是一个单位向量，向量长度都为1 (一行或一列中每个分量平方的和再开平方结果为1)\n","permalink":"https://EitanWong.github.io/en/posts/shader/%E7%9F%A9%E9%98%B5%E7%9A%84%E9%80%86/","summary":"逆的定义 $$ 矩阵的逆可以理解为 如果有一个矩阵M，它与它的逆M^{-1}相乘能够得到单位矩阵I $$ $$ 那么矩阵M^{-1}和矩阵M互为逆的关系 $$ 矩阵的逆满足于不管是左乘还是右乘它的逆，都能够得到单位矩阵 矩阵的求逆是一个重要的矩阵运算，这个运算只能用于方阵。 相乘时，结果时单位矩阵。用公式表","title":"矩阵的逆"},{"content":"矩阵的行列式 方形矩阵M的行列式表示为M。 2 x 2矩阵的行列式如下：\n更容易记住的方式，沿对角线和反对角线分别让元素相乘，然后使用对角线元素相乘的结果减去反对角线元素相乘的结果即可。\n3 x 3矩阵的行列式如下：\n使用容易记录的方式：先并排编写矩阵M的两个副本，然后沿对角线和反对角线分别让元素相乘，最后使用对角线元素相乘的结果的和减去反对角线元素相乘的结果即可。 如下：\n如果将3 x 3矩阵的行解释为3个矢量，那么该矩阵的行列式就等价于3个矢量的所谓三重积，如下：\n余子式 假设M是具有r行和c列的矩阵。考虑通过从M中删除行i和列j而获得的矩阵。该矩阵显然具有r - 1行和c-1列。这个子矩阵的行列式表示为\n被称为M的子矩阵行列式。 例如，子矩阵行列式\n是2 x 2矩阵的行列式，它是从3 x 3矩阵M中删除行1和列2的结果。\n代数余子式 针对矩阵当中某一个元素所在位置的有符号的余子式矩阵的行列式 也就是说代数余子式是求余子式矩阵的行列式\n💡 既然是行列式，最后将会得到一个标量值 它存在正负号问题 符号的决定由这个元素所在的（行+列），去决定行列式的正负值 也就是(-1)^i+j，如果i+j是偶数为正，i+j是奇数为负 给定行和列的方形矩阵M的余子式与相应的子矩阵行列式相同，但子矩阵行列式会交替变负，具体如下：\n任意 n x n方阵的行列式 对于任意维数 n x n矩阵的行列式存在若干等价定义。\n首先，从矩阵中任意选择一行或一列。 现在对于行或列中的每个元素，将此元素乘以相应的余子式。 对这些乘积求和可得出矩阵的行列式。\n例 行列式和代数余子式求和 💡 当某一个变换当中的矩阵，行列式结果为0，可以确定它包含的就是投影 这个变换将不可逆\n行列式的性质 ","permalink":"https://EitanWong.github.io/en/posts/shader/%E7%9F%A9%E9%98%B5%E8%A1%8C%E5%88%97%E5%BC%8F%E4%B8%8E%E4%BD%99%E5%AD%90%E5%BC%8F/","summary":"矩阵的行列式 方形矩阵M的行列式表示为M。 2 x 2矩阵的行列式如下： 更容易记住的方式，沿对角线和反对角线分别让元素相乘，然后使用对角线元素相乘的结果减去反对角线元素相乘的结果即可。 3 x 3矩阵的行列式如下： 使用容易记录的方式：先并排编写矩阵M的两个副本，然后沿对角线和反对角线分别让元素","title":"矩阵行列式与余子式"},{"content":"矩阵 矩阵的维度和记法 矩阵类似于一个二维数组一样的东西，在计算机当中有些时候可以把二维数组当作矩阵来使用 只不过在数学的概念上是完全不同的 一般的用 NXC 表示一个N行C列的矩阵 矩阵的元素从1开始，每个元素分别用i和j表示它的行数和列数 m[i][j]\n矩阵的转置 💡 矩阵的转置，就是将矩阵的行变成矩阵的列，矩阵的列变成矩阵的行 如果将转置过的矩阵，再做一次转置，就变成原来的矩阵 M^TT=M\n向量也是一种矩阵 可以将其看作是1行3列的行矩阵，其转置是3行1列的列矩阵\n所以有些时候在讨论行向量与列向量，就是以下两种不同的矩阵形式的向量（按照矩阵的概念在描述它）\n矩阵和标量的乘法 💡 将矩阵的每一个元素和标量相乘即可 标量无论放在矩阵的前面还是后面，都是同一个结果\n矩阵和矩阵的乘法 设A为mp的矩阵，B为pn的矩阵，那么称mn的矩阵C为矩阵A与B的乘积，记作C=AB ，其中矩阵C中的第i行第j列元素可以表示为：\n如下图所示\n💡 矩阵的乘法是有顺序的AxB与BxA的结果是不一样的 💡 1、当矩阵A的列数（column）等于矩阵B的行数（row）时，A与B可以相乘。 2、矩阵C的行数等于矩阵A的行数，C的列数等于B的列数。 3、乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。\n基本性质 乘法结合律： (AB)C=A(BC)． 乘法左分配律：(A+B)C=AC+BC 乘法右分配律：C(A+B)=CA+CB 对数乘的结合性k(AB）=(kA)B=A(kB）． 转置 (AB)T=BTAT． 矩阵乘法在以下两种情况下满足交换律。 - AA=AA，A和伴随矩阵相乘满足交换律。 - AE=EA，A和单位矩阵或数量矩阵满足交换律。\n通常在3D游戏开发当中，经常会用到向量与矩阵的相乘 当把列向量变为一个行向量，行向量必须放在矩阵的坐标相乘，否则相乘的结果是不一致的，为了保证一致性，列向量处于右边相乘的时候，将左边的矩阵进行一个转置操作过后，才能够得到一个不变分量的一个结果向量\n在CG当中有一个函数mul，相乘的函数 💡 这个函数有两种重载方式mul(M,V);和mul(V,M); 为了保证mul的分量结果一致，在函数内部的处理当中，当V在后面的时候，会对M进行一个转置操作，保证其结果与第一种重载的函数的分量一致\n单位矩阵 在矩阵的乘法中，有一种矩阵起着特殊的作用，如同数的乘法中的1，这种矩阵被称为单位矩阵。 它是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为1。 除此以外全都为0。 根据单位矩阵的特点，任何矩阵与单位矩阵相乘都等于本身\n二、 逆矩阵 方形矩阵M的逆矩阵，表示为\n，当在任意一侧将M乘以\n时，其结果都是单位矩阵。\n并不是所有矩阵都有逆矩阵。一个明显的例子就是一个行或列填充0的矩阵\u0026ndash;无论这个矩阵乘以什么，结果中相应的行或列也将满0。如果某个矩阵具有逆矩阵，则称其为可逆矩阵或非奇异矩阵。不具有逆矩阵的被称为是不可逆矩阵或奇异矩阵。 奇异矩阵的行列式为零，非奇异矩阵的行列式为非零。检查行列式的大小是最常用的可逆性测试，因为这样最简单和最快的。基于经典伴随矩阵，可以计算矩阵的逆矩阵。 2.1 经典伴随矩阵 M的经典伴随是以下余子式的矩阵的转置：\n2.2 逆矩阵——正式线性代数规则 为了计算矩阵的逆矩阵，可以将以下经典伴随矩阵除以行列式：\n如果行列式为零，则除法是未定义的。 矩阵求逆的重要特性：\n矩阵的逆矩阵的逆是原始矩阵： 单位矩阵是他自己的逆： 任何反射矩阵，或围绕任何轴旋转180度的矩阵是他们自己的逆矩阵。\n矩阵转置的逆矩阵是逆矩阵逆的转置： 矩阵乘积的逆等于矩阵的逆的乘积，注意，逆矩阵的乘法要采用相反的顺序： 逆矩阵的行列式是原始局好着呢的行列式的倒数： 三、正交矩阵 3.1 正交矩阵——正式线性代数规则 当且仅当矩阵及其转置的乘积是单位矩阵时，方形矩阵M是正交的，定义如下：\n如果矩阵是正交的，则其转置矩阵和逆矩阵是相等的。\n四、关于4 x 4其次矩阵 4.1 关于4 x 4平移矩阵 假设w始终为1。标准三维矢量[x,y,z]将始终在四维中表示为[x, y, z, 1]。任何3 x 3变换矩阵都可以通过以下转换公式实现在四维中的表示：\n当将[x,y,z,1]形式的四维矢量乘以这种形式的4 x 4 矩阵时，得到与标准3 x 3情况相同的结果，唯一的区别是附加坐标 w = 1，具体如下：\n在四维中，可以用矩阵乘法表示平移：\n这种矩阵乘法仍然是线性变换。矩阵乘法不能表示四维中的“平移”，四维零矢量将始终变换回四维零矢量。 设R是一个旋转矩阵，设T是平移矩阵，这两个矩阵分别如下：\n然后先旋转再平移点v来计算新点\n，公式如下:\n这里变换的顺序很重要，因为选择使用的是行矢量，所以变换的顺序与矩阵从左到右相乘的顺序一致。 4.2 一般仿射变换 包含平移的仿射变换：\n围绕不穿过原点的轴旋转 围绕不穿过原点的平面进行缩放 围绕不穿过原点的平面反射 在不穿过原点的平面上进行正交投影 五、关于4 x 4矩阵和透视投影 5.1 针孔相机 针孔相机是一个盒子，一端有一个小孔。光纤进入针孔(因此会聚在一点)，然后撞击盒子的另一端，即投影平面。\n如果将点投影到z = d平面上，得到公式如下：\n5.2 透视投影矩阵 从四维到三维空间的转换意味着除法，所以可以在 4 x 4矩阵中编码透视投影。 假设原始点有 w = 1。 通过点投影的公式，可以得到以下一个公分母：\n所以需要4 x 4矩阵，将乘以一个齐次矢量[x, y, z, 1]产生[x, y, z, z/d]。执行此操作的矩阵是：\n","permalink":"https://EitanWong.github.io/en/posts/shader/3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E7%9F%A9%E9%98%B5/","summary":"矩阵 矩阵的维度和记法 矩阵类似于一个二维数组一样的东西，在计算机当中有些时候可以把二维数组当作矩阵来使用 只不过在数学的概念上是完全不同的 一般的用 NXC 表示一个N行C列的矩阵 矩阵的元素从1开始，每个元素分别用i和j表示它的行数和列数 m[i][j] 矩阵的转置 💡 矩阵的转置，就是将矩阵的行变成矩阵的列，矩","title":"3D数学基础-矩阵"},{"content":"向量的基本定义 💡 向量(vector)描述了方向和大小。向量也有自己的运算规则\n向量的加减法与数乘的意义见下图\n在Unity中有三类向量，如下图所示 向量的加法 💡 将向量的对应分量进行相加即可\n向量的减法 💡 将向量对应的分量相减，谁是被减数，结果向量就指向谁\n向量和标量的乘法 💡 将标量与向量当中的每个分量相乘 如上图所示，得到的结果方向没有改变，长度变为原来的2倍\n向量的规范化(归一化) 用向量的每一个分量，取除以其模长\n“在计算两个向量的点积之前应用归一化。归一化一个向量包括两个步骤\u0026quot;\nRSL: Edge Effects\n1 计算它的长度，然后,\n2 然后将它的每个（xy 或 xyz）分量除以它的长度.\nGiven vector **a** its xyz components are calculated as follows\nx = ax/|a| y = ay/|a| z = az/|a| As a \u0026ldquo;worked example\u0026rdquo; the vector shown in figure 1 has the xyz components of 3, 1, 2 and a length of 3.742. Therefore, a normalized copy of the vector will have components,\nx = 3.0 / 3.742 =0.802 y = 1.0 / 3.742 =0.267 z = 2.0 / 3.742 =0.534 💡 计算向量的长度，|v| = sqrt(x^2+ y^2+…)\n向量的点积Dot 💡 点积的结果是一个标量值\n向量点积的几何意义 💡 两个向量形成的夹角大于等于0并且小于90度，点积的结果大于0 形成的夹角大于90度，点积的结果小于0 形成的夹角为90度，点积结果为0\n向量的叉积Cross 💡 两个向量的叉积，其结果仍是一个向量，其结果向量的方向垂直于原来的两个向量 叉积相乘的顺序不同，其结果也不同\n对于向量a和向量b\na和b的叉积公式\n叉积的几何意义 💡 在三维几何中，向量a和向量b的叉乘结果是一个向量，更为熟知的叫法是法向量，该向量垂直于a和b向量构成的平面。\nusing UnityEngine; [ExecuteInEditMode] public class VectorTest1 : MonoBehaviour { MeshRenderer \\_renderer; MeshFilter \\_filter; Mesh \\_mesh; void Awake() { if (!TryGetComponent(out \\_renderer)) \\_renderer = gameObject.AddComponent(); if (!TryGetComponent(out \\_filter)) \\_filter = gameObject.AddComponent(); } [ContextMenu(\u0026#34;Generate\u0026#34;)] private void Generate() { GenerateTriangle(); \\_renderer.sharedMaterial = new Material(Shader.Find(\u0026#34;Standard\u0026#34;)); \\_filter.sharedMesh = \\_mesh; } private void GenerateTriangle() { \\_mesh = new Mesh(); Vector3[] vertices = new Vector3[3]; vertices[0] = new Vector3(0, 1, 0); vertices[1] = new Vector3(1, -1, 0); vertices[2] = new Vector3(-1, -1, 0); \\_mesh.vertices = vertices; \\_mesh.triangles = new[] { 0,1,2//遍历的顺序会影响三角面的朝向 }; Vector3[] normals = new Vector3[3]; var V\\_BA = GetDir(vertices[1], vertices[0]); var V\\_CA = GetDir(vertices[2], vertices[0]); normals[0] = Vector3.Cross(V\\_BA, V\\_CA); var V\\_CB = GetDir(vertices[2], vertices[1]); var V\\_AB = GetDir(vertices[0], vertices[1]); normals[1] = Vector3.Cross(V\\_CB, V\\_AB); var V\\_AC = GetDir(vertices[0], vertices[2]); var V\\_BC = GetDir(vertices[1], vertices[2]); normals[2] = Vector3.Cross(V\\_AC, V\\_BC); \\_mesh.normals = normals; } private Vector3 GetDir(Vector3 v1, Vector3 v2) { return v1 - v2; } } 在3D图像学中，叉乘的概念非常有用，可以通过两个向量的叉乘，生成第三个垂直于a，b的法向量，从而构建X、Y、Z坐标系。如下图所示\n在二维空间中，叉乘还有另外一个几何意义就是：aXb等于由向量a和向量b构成的平行四边形的面积\n","permalink":"https://EitanWong.github.io/en/posts/shader/3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%90%91%E9%87%8F/","summary":"向量的基本定义 💡 向量(vector)描述了方向和大小。向量也有自己的运算规则 向量的加减法与数乘的意义见下图 在Unity中有三类向量，如下图所示 向量的加法 💡 将向量的对应分量进行相加即可 向量的减法 💡 将向量对应的分量相减，谁是被减数，结果向量就指向谁 向量和标量的乘法 💡 将标量与向量当中的","title":"3D数学基础-向量"},{"content":"模型坐标系 2D中的模型坐标系 3D当中的模型坐标系 世界坐标系 2D中的世界坐标系 3D中的世界坐标系 摄像机坐标系 屏幕投影坐标系 ","permalink":"https://EitanWong.github.io/en/posts/shader/3d%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80-%E5%9D%90%E6%A0%87%E7%B3%BB/","summary":"模型坐标系 2D中的模型坐标系 3D当中的模型坐标系 世界坐标系 2D中的世界坐标系 3D中的世界坐标系 摄像机坐标系 屏幕投影坐标系","title":"3D数学基础-坐标系"},{"content":"自定义函数 在ShaderLabCG中函数的定义与C语言类似\nvoid func () { } 定义函数的格式如下\n返回值类型 函数名 (参数1,参数2,参数3,......) { //函数体 return//返回值 } 函数的前项声明 💡 在Cg语言当中函数的定义要写在后面调用它的方法之前 如果一定要写在后面可以使用前项声明\n如果函数写在调用它之前，并且没有进行前项声明，则会报错\n前项声明示例子如下：\nfixed4 func(fixed4 col); void frag(inout fixed4 col:COLOR) { col=func(col); } fixed4 func (fixed4 col) { col.x=1; return col; } Cg include 内置着色器 include 文件 Unity 提供了若干文件供 用于引入预定义的变量和 helper 函数。这可以通过标准 #include 指令来完成，例如：\nCGPROGRAM // ... #include\u0026#34;UnityCG.cginc\u0026#34; // ... ENDCG Unity 中的着色器 include 文件采用 .cginc 扩展名，内置的着色器 include 文件包括：\nHLSLSupport.cginc -_（自动包含）_用于跨平台着色器编译的 helper 宏和定义。 UnityShaderVariables.cginc -_（自动包含）_常用的全局变量。 UnityCG.cginc - 常用的 。 AutoLight.cginc - 光照和阴影功能，例如 在内部使用此文件。 Lighting.cginc - 标准 光照模型；当您编写表面着色器时会自动包含。 TerrainEngine.cginc - 地形和植被着色器的 helper 函数。 如果您要查看任何 helper 代码具体执行的操作，可在 Unity 应用程序中找到这些文件（Windows 上位于 {unity 安装路径}/Data/CGIncludes/UnityCG.cginc__，Mac 上位于 /Applications/Unity/Unity.app/Contents/CGIncludes/UnityCG.cginc__）。\nHLSLSupport.cginc 编译 CGPROGRAM 着色器时会自动包含此文件（但不会对 HLSLPROGRAM 着色器包含此文件）。此文件声明各种 以帮助进行多平台着色器开发。\nUnityShaderVariables.cginc 编译 CGPROGRAM 着色器时会自动包含此文件（但不会对 HLSLPROGRAM 着色器包含此文件）。此文件声明着色器中常用的各种 。\nUnityCG.cginc Shader 对象中通常会包含此文件。此文件声明大量 和数据结构。\nUnityCG.cginc 中的数据结构 struct appdata_base：顶点着色器输入，包含位置、法线和一个纹理坐标。 struct appdata_tan：顶点着色器输入，包含位置、法线、切线和一个纹理坐标。 struct appdata_full：顶点着色器输入，包含位置、法线、切线、顶点颜色和两个纹理坐标。 struct appdata_img: 顶点着色器输入，包含位置和一个纹理坐标。 Cg数学函数Mathematical Functions 几何函数 Geometric Functions 函数\n功能描述\ndistance(pt1, pt2)\n两点之间的欧几里德距离（Euclidean distance）\nfaceforward(N,I,Ng)\n如果dot( Ng , I ) \u0026lt; 0,返回N；否则返回-N。\nlength(v)\n返回一个向量的模,即sqrt(dot(v,v))\nnormalize(v)\n返回v向量的单位向量\nreflect(I, N)\n根据入射光线方向I和表面法向量N计算反射向量,仅对三元向量有效\nrefract(I,N,eta)\n根据入射光线方向I,表面法向量N和折射相对系数eta,计算折射向量。如果对给定的eta,I和N之间的角度太大,返回(0,0,0)。只对三元向量有效\n贴图函数 Texture Map Functions 函数\n功能描述\ntex1D(sampler1D tex, float s)\n一维纹理查询\ntex1D(sampler1D tex, float s, float dsdx, float dsdy)\n使用导数值（derivatives）查询一维纹理\nTex1D(sampler1D tex, float2 sz)\n一维纹理查询,并进行深度值比较\nTex1D(sampler1D tex, float2 sz, float dsdx,float dsdy)\n使用导数值（derivatives）查询一维纹理, 并进行深度值比较\nTex1Dproj(sampler1D tex, float2 sq)\n一维投影纹理查询\nTex1Dproj(sampler1D tex, float3 szq)\n一维投影纹理查询,并比较深度值\nTex2D(sampler2D tex, float2 s)\n二维纹理查询\nTex2D(sampler2D tex, float2 s, float2 dsdx, float2 dsdy)\n使用导数值（derivatives）查询二维纹理\nTex2D(sampler2D tex, float3 sz)\n二维纹理查询,并进行深度值比较\nTex2D(sampler2D tex, float3 sz, float2 dsdx,float2 dsdy)\n使用导数值（derivatives）查询二维纹理,并进行深度值比较\nTex2Dproj(sampler2D tex, float3 sq)\n二维投影纹理查询\nTex2Dproj(sampler2D tex, float4 szq)\n二维投影纹理查询,并进行深度值比较\ntexRECT(samplerRECT tex, float2 s)\n二维非投影矩形纹理查询（OpenGL独有）\ntexRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy)\n二维非投影使用导数的矩形纹理查询（OpenGL独有）\ntexRECT (samplerRECT tex, float3 sz)\n二维非投影深度比较矩形纹理查询（OpenGL独有）\ntexRECT (samplerRECT tex, float3 sz, float2 dsdx,float2 dsdy)\n二维非投影深度比较并使用导数的矩形纹理查询（OpenGL独有）\ntexRECT proj(samplerRECT tex, float3 sq)\n二维投影矩形纹理查询（OpenGL独有）\ntexRECT proj(samplerRECT tex, float3 szq)\n二维投影矩形纹理深度比较查询（OpenGL独有）\nTex3D(sampler3D tex, float s)\n三维纹理查询\nTex3D(sampler3D tex, float3 s, float3 dsdx, float3 dsdy)\n结合导数值（derivatives）查询三维纹理\nTex3Dproj(sampler3D tex, float4 szq)\n查询三维投影纹理,并进行深度值比较\ntexCUBE(samplerCUBE tex, float3 s)\n查询立方体纹理\ntexCUBE (samplerCUBE tex, float3 s, float3 dsdx, float3 dsdy)\n结合导数值（derivatives）查询立方体纹理\ntexCUBEproj (samplerCUBE tex, float4 sq)\n查询投影立方体纹理\n导数函数 Derivative Functions 函数\n功能描述\nddx(a)\n近似a关于屏幕空间x轴的偏导数\nddy(a)\n近似a关于屏幕空间y轴的偏导数\n调试函数 Debugging Function 函数\n功能描述\nvoid debug(float4 x)\n如果在编译时设置了DEBUG,片段着 色程序中调用该函数可以将值x作为COLOR语义的最终输出；否则该函数什么也不做。\n","permalink":"https://EitanWong.github.io/en/posts/shader/cg%E8%AF%AD%E8%A8%80-%E5%87%BD%E6%95%B0/","summary":"自定义函数 在ShaderLabCG中函数的定义与C语言类似 void func () { } 定义函数的格式如下 返回值类型 函数名 (参数1,参数2,参数3,......) { //函数体 return//返回值 } 函数的前项声明 💡 在Cg语言当中函数的定义要写在后面调用它的方法之前 如果一定要写在后面可以使用前项声明 如","title":"CG语言-函数"},{"content":"switch…case 💡 需要注意的是早期版本Cg不支持switch…case语句，但是保留了这些关键字！\nswitch(条件变量) { case 条件1: [语句块] break; case 条件2: [语句块] break; ... default: [语句块] break; } 示例如下：\nShader \u0026#34;lxt610/NewSurfaceShaderTest2\u0026#34; { SubShader { Pass { CGPROGRAM #pragma fragment frag #pragma vertex vert void vert(in float2 objPos:POSITION,out float4 pos:POSITION,out float4 col:COLOR0) { pos = float4(objPos,0,1); col = pos; } void frag(inout float4 col:COLOR0) { col = float4(1,1,0,1); //关于switch case验证 int i = 3; switch(i) { case 0: col = float4(1,0,0,1);//红色 break; case 1: col = float4(0,1,0,1);//绿色 break; case 2: col = float4(0,0,1,1);//蓝色 break; case 3: col = float4(1,0,0.5,1); break; case 4: col = float4(1,0.5,1,1); break; default: col = float4(1,1,1,1);//白色 break; } } ENDCG } } } 这里修改i的值使其进入相应的条件，发现颜色发生了相应的变化并没有进入default条件中，这说明现在的Cg支持了这个语句！或者说至少我这里是支持的，我这里使用的是unity2017.4.27f1，shader model 3.0是支持的！\nif…else条件语句 if…else条件语句的语法为:\nif(条件语句) { //语句块1 } elseif(条件语句) { //语句块2 } ... else { //语句块 } 示例如下：\nShader \u0026#34;lxt610/NewSurfaceShaderTest2\u0026#34; { SubShader { Pass { CGPROGRAM #pragma fragment frag #pragma vertex vert void vert(in float2 objPos:POSITION,out float4 col:COLOR0,out float4 pos:POSITION) { pos = float4(objPos,0,1); if(pos.x \u0026lt; 0) { col = float4(1,0,0,1);//红色 } else { col = float4(0,1,0,1);//绿色 } //col = pos; } void frag(inout float4 col:COLOR0) { } ENDCG } } } 💡 回到unity中编译通过我们我们发现，左边变成了红色，右边成了绿色，中间是一个过渡区域。这是因为在摄像机的剪裁空间cvv中坐标范围是（-1，1），而物体的模型坐标处于（-0.5，0.5）之间（左下角（-0.5,-0.5），右上角（0.5,0.5）），所以物体的左边就变成了红色，右边就成了绿色。而中间的部分我们发现是一个缓慢的融合过程区域！这是由于顶点的颜色处理过后，还有大量的像素没有处理这时在光栅化阶段就是片元函数处理的过程中做了一个差值的运算。\nwhile循环语句 while语句的语法格式 while(条件语句)//满足条件执行，否则退出循坏（先判断，再执行)） { 语句块； } 下面是一个示例，代码和效果如下\nShader \u0026#34;lxt610/NewSurfaceShaderTest2\u0026#34; { SubShader { Pass { CGPROGRAM #pragma fragment frag #pragma vertex vert void vert(in float2 objPos:POSITION,out float4 col:COLOR0,out float4 pos:POSITION) { pos = float4(objPos,0,1); if(pos.x \u0026lt; 0 \u0026amp;\u0026amp; pos.y \u0026lt; 0) { col = float4(1,0,0,1);//红色 } else if(pos.x \u0026lt; 0) { col = float4(0,1,0,1);//绿色 } else if(pos.y \u0026gt; 0) { col = float4(1,1,0,1);//黄色 } else { col = float4(0,0,1,1);//蓝色 } //col = pos; } void frag(inout float4 col:COLOR0) { int i = 0; while(i \u0026lt; 10) { i++; } if(i == 10) col = float4(0,0,0,1); } ENDCG } } } 这里为了方便演示我们只是循环了十次，由于没有控制台输出这里为了方便观察，结束循环后颜色设为黑色（float4(0,0,0,1)）！这说明循环执行了10次！\ndo…while循环语句 do…while语句的语法格式 { 语句块； } while(条件语句);//满足条件执行，否则退出循坏(先执行一次，再判断) 下面是一个示例，代码和效果如下： Shader \u0026#34;lxt610/NewSurfaceShaderTest2\u0026#34; { SubShader { Pass { CGPROGRAM #pragma fragment frag #pragma vertex vert void vert(in float2 objPos:POSITION,out float4 col:COLOR0,out float4 pos:POSITION) { pos = float4(objPos,0,1); if(pos.x \u0026lt; 0 \u0026amp;\u0026amp; pos.y \u0026lt; 0) { col = float4(1,0,0,1);//红色 } else if(pos.x \u0026lt; 0) { col = float4(0,1,0,1);//绿色 } else if(pos.y \u0026gt; 0) { col = float4(1,1,0,1);//黄色 } else { col = float4(0,0,1,1);//蓝色 } //col = pos; } void frag(inout float4 col:COLOR0) { int i = 0; while(i \u0026lt; 10) { i++; } if(i == 10) col = float4(0,0,0,1); i = 0; do{ i++; } while(i \u0026lt; 10); if(i == 10) col = float4(1,1,1,1); } ENDCG } } } 这里为了方便演示我们只是循环了十次，由于没有控制台输出这里为了方便观察，结束循环后颜色设为白色（float4(1,1,1,1)）！这说明循环执行了10次退出，然后设为了白色！\nfor循环 for循环的语法 for(int i = 0; i \u0026lt; 10; i++)（初始值，条件1，语句2） { 语句块； } 下面是一个示例，代码和效果如下：\nShader \u0026#34;lxt610/NewSurfaceShaderTest2\u0026#34; { SubShader { Pass { CGPROGRAM #pragma fragment frag #pragma vertex vert void vert(in float2 objPos:POSITION,out float4 col:COLOR0,out float4 pos:POSITION) { pos = float4(objPos,0,1); if(pos.x \u0026lt; 0 \u0026amp;\u0026amp; pos.y \u0026lt; 0) { col = float4(1,0,0,1);//红色 } else if(pos.x \u0026lt; 0) { col = float4(0,1,0,1);//绿色 } else if(pos.y \u0026gt; 0) { col = float4(1,1,0,1);//黄色 } else { col = float4(0,0,1,1);//蓝色 } //col = pos; } void frag(inout float4 col:COLOR0) { for(int i = 0; i \u0026lt; 10; i++) { } if(i == 10) col = float4(0.5,0.5,0,1); } ENDCG } } } 💡 观察发现变为暗黄色，说明执行了条件语句中的内容，说明了能够正常跳出循环！ 💡 值得注意的是for循环的次数有些版本是有限制的，超过了1024就会报运行异常，有的则不会根据实际情况测试！\n","permalink":"https://EitanWong.github.io/en/posts/shader/cg%E8%AF%AD%E8%A8%80-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","summary":"switch…case 💡 需要注意的是早期版本Cg不支持switch…case语句，但是保留了这些关键字！ switch(条件变量) { case 条件1: [语句块] break; case 条件2: [语句块] break; ... default: [语句块] break; } 示例如下： Shader \u0026#34;lxt610/NewSurfaceShaderTest2\u0026#34; { SubShader { Pass { CGPROGRAM #pragma fragment frag #pragma vertex vert void vert(in float2 objPos:POSITION,out float4 pos:POSITION,out float4 col:COLOR0) { pos = float4(objPos,0,1); col = pos; } void frag(inout float4 col:COLOR0) { col = float4(1,1,0,1); /","title":"CG语言-流程控制"},{"content":"Shader targets ‘#pragma target’ 值列表 这是 Unity 使用的着色器模型列表 注意：Unity 的着色器模型与 DirectX 着色器模型和 OpenGL 版本要求类似，但并不完全对应。 仔细阅读说明以确保您了解其中的差异。\n值\n描述\n支持\nEquivalent #pragma require values\n2.0\n相当于 DirectX 着色器模型 2.0。有限数量的算术和纹理指令； 8个内插器； 没有顶点纹理采样； 片段着色器中没有导数； 没有明确的 LOD 纹理采样。\n适用于 Unity 支持的所有平台。\nN/A\n2.5\n几乎与 3.0 相同，但只有 8 个插值器，并且没有显式 LOD 纹理采样。\nDirectX 11 功能等级 9+OpenGL 3.2+OpenGL ES 2.0VulkanMetal\nderivatives\n3.0\n相当于 DirectX 着色器模型 3.0..\nDirectX 11 功能级别 10 +OpenGL 3.2+OpenGL ES 3.0+VulkanMetal 可能适用于某些 OpenGL ES 2.0 设备，具体取决于驱动程序扩展和功能。\nEverything in 2.5, plus:interpolators10 samplelod fragcoord\n3.5\n相当于 OpenGL ES 3.0。\nDirectX 11 功能等级 10+OpenGL 3.2+OpenGL ES 3+VulkanMetal\nEverything in 3.0, plus:interpolators15 mrt4 integers 2darray instancing\n4.0\n相当于 DirectX 着色器模型 4.0，但不需要支持 8 个 MRT。\nDirectX 11 功能级别 10+OpenGL 3.2+OpenGL ES 3.1+AEPVulkanMetal（如果未定义几何阶段）\nEverything in 3.5, plus:geometry\n4.5\n相当于 OpenGL ES 3.1。\nDirectX 11 功能级别 11+OpenGL 4.3+OpenGL ES 3.1VulkanMetal\nEverything in 3.5, plus:compute randomwrite msaatex\n4.6\n相当于 OpenGL 4.1。这是 Mac 支持的最高 OpenGL 级别。\nDirectX 11 功能级别 11+OpenGL 4.1+OpenGL ES 3.1+AEPVulkanMetal（如果没有定义几何阶段，也没有定义外壳或域阶段）\nEverything in 4.0, plus:cubearray tesshw tessellation msaatex\n5.0\n相当于 DirectX 着色器模型 5.0，但不需要支持 32 个插值器或立方体贴图数组。\nDirectX 11 功能级别 11+OpenGL 4.3+OpenGL ES 3.1+AEPVulkanMetal（如果没有定义几何阶段，也没有定义外壳或域阶段）\nEverything in 4.0, plus:compute randomwrite msaatex tesshw tessellation\n有关控制台平台的着色器模型支持的信息，请参阅特定于平台的文档。 笔记：\n在 DirectX 定义中，着色器模型 4.0 包括“mrt8”，着色器模型 5.0 包括“interpolators32”和“cubearray”。 Unity 不包括这些，以实现更广泛的兼容性。 要要求这些功能，请使用明确的#pragma require 指令。 如果您使用需要 geometry 的目标，但您的着色器未定义几何阶段，Unity 会在编译时从要求列表中删除 geometry。 如果您使用需要“曲面细分”的目标，但您的着色器未定义外壳或域阶段，Unity 会在编译时从要求列表中删除“曲面细分”。 💡 一般来说默认不写shader target默认采用2.0\n数据类型 布尔类型 在c语言中非0即为真0即为假，在Cg中有关键字bool可以声明bool变量\nbool bl=true; 同时在Cg中也可以支持三目表达式\ncol=bl?col:fixed4(0,1,0,1); 在Cg中可以由基础的数据类型构建出向量 例如float可以构建出二阶的向量float2 💡 Cg当中最多可以支持4阶的向量\nfloat2 fl2=(1,0); float3 fl3=(1,0,1); float4 fl4=(1,0,0,1); 甚至bool类型也可以按照这样的方式去凑成一个向量 bool2 bl2=(true,false); bool3 bl3=(true,false,true); bool4 bl4=(true,false,false,true); Swizzle操作 可以使用Cg语言中的swizzle操作符（.）将一个向量的成员取出组成一个新的向量。 swizzle操作符被GPU硬件高效支持。 💡 swizzle操作符后接x、y、z、w，分别表示原始向量的第一个、第二个、第三个、第四个元素；swizzle操作符后接 r、g、b和a的含义与前者等同。\n不过为了程序的易读性，建议对于表示颜色值的向量，使用swizzle操作符后接r、g、b和a的方式。\n举例如下：\nfloat4(a, b, c, d).xyz 等价于 float3(a, b, c) float4(a, b, c, d).xyy 等价于 float3(a, b, b) float4(a, b, c, d).wzyx 等价于 float4(d, c, b, a) float4(a, b, c, d).w 等价于 float d 值得注意的是，Cg语言中**float a 和float1 a是基本等价的**，两者可以进行类型转换；float、bool、half等基本类型声明的变量也可以使用swizzle操作符。例如：\nfloat a = 1.0; float4 b = a.xxxx; 注意：swizzle操作符只能对结构体和向量使用，不能对数组使用，如果对数组使用swizzle操作符则会出现错误信息：error C1010: expression left of .”x” is not a struct or array（其实个人觉得，提示的错误信息中array换成vector更加合适）。 要从数组中取值必须使用[]符号。例如：\nfloat a[3] = {1.0,1.0,0.0}; float b = a[0];//正确 float c = a.x;//编译会提示错误信息 矩阵 在Cg语言当中，声明一个矩阵的格式采用：[数据类型][行数]x[列数]\n矩阵声明 矩阵的初始化 float2x2 M2x2;//声明一个2行2列的矩阵 float2x4 M2x4;//声明一个2行4列的矩阵 //fl2 是一个float类型的2维数组 float2x4 M2x4={fl2,fl2,(1,1,0,0)}; //fl4 是一个float类型的4维数组 float2x4 M2x4={fl4,(1,1,0,0)}; /*声明一个2行2列的矩阵，并初始化 *[0,1] *[0,1] */ float2x2 M2x2={0,1,0,1}; /*声明一个2行4列的矩阵,并初始化 *[0,1,0,1] *[1,1,0,0] */ float2x4 M2x4={(0,1,0,1),(1,1,0,0)}; 矩阵取值 矩阵赋值 col=M2x4[0];//(0,1,0,1) col=M2x4[1];//(1,1,0,0) M2x4[0]=fl4; M2x4[1]=(1,1,1,1); M2x4[1]=(fl3,0); 数组 声明数组 初始化赋值 float arr[4]; float arr[4]={1,0.5,0.5,1}; 数组取值 数组赋值 arr[0];//1 arr[1];//0.5 col=float4(arr[0],arr[1],arr[2],arr[3]); float fl=3; arr[0]=1; arr[1]=2; arr[2]=fl; 结构体 结构体的声明 struct v2f { float4 pos; float2 uv; }; 结构体的使用 v2f o; o.pos=float4(0,1,0,1); o.uv=float2(1,0); #define与typedef #define 💡 ****#define预处理语句**** #define语句通常有以下两种写法：\n#define 标识符 字符串 #define 标识符 //例子 #define NUM 0 #define AddNUM (NUM + 0.5) #define Add(x, y) (x+y) #define语句为我们的常量（字符串）分配一个有意义的名称的预处理器指令。可以简单理解为：在前两个例子中，我们用NUM去替代0这个数字，并可以通过NUM来直接使用，而 AddNUM会被定义成（NUM + 0.5），也就是（0.5 + 0.5）。注意这个括号很重要，会导致运算顺序的不同。来看下面这个片元着色器的输出：\nfixed4 frag(v2f i) : SV_Target { **return** fixed4(NUM, AddNum, 1, 1); //实际上输出的是fixed4(0, 1, 1, 1); } 而相对与上面两种写法，第三种写法可以定义一个函数。Add(x, y)表示将输入进来的两个数值进行相加并返回最终结果。\nfixed4 frag(v2f i) : SV_Target { **return** fixed4(NUM, AddNum, Add(0.5, 0.5), 1); //实际上输出的是fixed4(0, 1, (0.5+0.5)=1 , 1); } 例 #define ONEFL4 float4(1,1,1,1);//定义ONEFL4 值为float4(1,1,1,1); col=ONEFL4//由于ONEFL4中包含了;分号，所以这里可以不写分号 typeof 💡 可以为某一个类型指定类型别名\ntypedef float4 FL4;//为float4类型指定别名FL4 使用类型别名 FL4 typeofFl4=FL4(0,1,3,2); float4 buildinFl4=FL4(1,2,3,4); FL4 typeFl4=float4(4,3,2,1); ","permalink":"https://EitanWong.github.io/en/posts/shader/cg%E8%AF%AD%E8%A8%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8Cswizzle%E6%93%8D%E4%BD%9C/","summary":"Shader targets ‘#pragma target’ 值列表 这是 Unity 使用的着色器模型列表 注意：Unity 的着色器模型与 DirectX 着色器模型和 OpenGL 版本要求类似，但并不完全对应。 仔细阅读说明以确保您了解其中的差异。 值 描述 支持 Equivalent #pragma require values 2.0 相当于 DirectX 着色器模型 2.0。有限数量的算术和纹理指令； 8个内插器； 没有顶点纹理采样；","title":"CG语言-数据类型和swizzle操作"},{"content":"Profile 一个 Cg Profile定义了一个“被特定图形硬件或API所支持的Cg语言子集” 任意一种shader language都是基于可编程图形硬件的寄存器、指令集等\n这也就意味着：不同的图形硬件对应着不同的功能子集。这些可选的语言功能包括某些控制结构和标准函数库。\nprofile还定义了数据类型的精度，并且指定数据类型是否全部或仅部分支持。\nprofile按住功能可以划分为顶点profile和片段profile，而顶点profile和片段profile又基于opengl和directx的不同版本或扩展，划分为各种版本。\n从某种意义上而言，opengl和dirextx的发展历程成就了cg语言。\n数组在Cg语言中是第一数据类型，那是因为Cg不支持指针。\n函数参数是使用值传递。\n绝大部分Cg compiler 所支持的 Profiles *附：*截止到 2009 年 10 月，出现的 profile 已经不止上面这些种类了，尤其是现在 DirectX 已经出到了 12的版本。上面的 profile 是可以在当前大多数机器上使用的。\n* OpenGL ARB vertex programs Runtime profile: CG_PROFILE_ARBVP1 Compiler option: -profile arbvp1 * OpenGL ARB fragment programs Runtime profile: CG_PROFILE_ARBFP1 Compiler option: -profile arbfp1 * OpenGL NV40 vertex programs Runtime profile: CG_PROFILE_VP40 Compiler option: _profile vp40 * OpenGL NV40 fragment programs Runtime profile: CG_PROFILE_FP40 Compiler option: _profile fp40 * OpenGL NV30 vertex programs Runtime profile: CG_PROFILE_VP30 Compiler option: _profile vp30 * OpenGL NV30 fragment programs Runtime profile: CG_PROFILE_FP30 Compiler option: _profile fp30 * OpenGL NV2X vertex programs Runtime profile: CG_PROFILE_VP20 Compiler option: _profile vp20 * OpenGL NV2X fragment programs Runtime profile: CG_PROFILE_FP20 Compiler option: _profile fp20 * DirectX 9 vertex shaders Runtime profiles: CG_PROFILE_VS_2_X 、CG_PROFILE_VS_2_0 Compiler options:-profile vs_2_x 、 -profile vs_2_0 * DirectX 9 pixel shaders Runtime profiles: CG_PROFILE_PS_2_X 、CG_PROFILE_PS_2_0 Compiler options: -profile ps_2_x 、-profile ps_2_0 * DirectX 8 vertex shaders Runtime profiles: CG_PROFILE_VS_1_1 Compiler options:-profile vs_1_1 * DirectX 8 pixel shaders Runtime profiles: CG_PROFILE_PS_1_3 、CG_PROFILE_PS_1_2 CG_PROFILE_PS_1_1 Compiler options: -profile ps_1_3 、-profile ps_1_2 、-profile ps_1_2 、-profile ps_1_1 例：NVIDIA官网给出的Cg Profiles fp20（OpenGL片段程序的Profile）的文档 Cg语言说明文档 Cg_language\n基本数据类型 Cg语言中预定义的内置（built in）的、或称为基本（primitive）的数据类型\nCg 支持 7 种基本的数据类型：\nfloat，32 位浮点数据，一个符号位。浮点数据类型被所有的 profile 支持（但是 DirectX8 pixel profiles 在一些操作中降低了浮点数的精度和范围）； ![Untitled][img-INDSKRJYEVAUMJKBIQSUKOBFIE4CKOBQFUSTEMCQOJXWM2LMMUSUKNJFHEZCKOCDEVCTKJJZIYSUEQJFIU3CKOKDEVAUGJKFGYSTSNJFIIYCKRJWEU4EIJKBIUSUKNZFIIYSKQSCEVCTKJJZIUSTQQRFGIYGMZJTMJTGMZLEGA4TAOJUGJQTQOLCGUZDKZBSGE4GIZJVHFRTSOBPKVXHI2LUNRSWILTQNZTQ====]\nhalf，16 为浮点数据； int，32 位整形数据，有些 profile 会将 int 类型作为 float 类型使用；\nfixed，12 位定点数，被所有的 fragment profiles 所支持；\nfiexed，在Cg中还有一个数据类型fixed，在Profile fp20当中它是一个9位定点数，符号为占一位，有效数值8位，有符号(-255,+255)，在处理过程当中，会被标量化为（-1,1）之间的值， 所以Shader中使用COLOR颜色时，使用fixed4，已经满足了真彩色256256256=16777216\nbool，布尔数据，通常用于 if 和条件操作符（?:），布尔数据类型被所有的 profiles 支持； sampler，纹理对象的句柄（the handle to a texture object），分为 6 类： sampler，sampler1D，sampler2D，sampler3D，samplerCUBE和 samplerRECT。 DirectX profiles 不支持 samplerRECT 类型，除此之外这些类型被所有的 pixel profiles 和 NV40 vertex program profile 所支持（CgUsersManual 30 页）。由此可见，在不远的未来，顶点程序也将广泛支持纹理操作； string，字符类型，该类型不被当前存在的 profile 所支持，实际上也没有必要在 Cg 程序中用到字符类型，但是你可以通过 Cg runtime API 声明该类型变量，并赋值；因此，该类型变量可以保存 Cg 文件的信息。 Cg 还提供了内置的向量数据类型(built-in vector data types) 💡 内置的向量数据类型基于基础数据类型。例如：float4，表示 float 类型的 4 元向量；bool4，表示 bool 类型 4 元向量\n注意： 向量长不能超过 4 元，即在 Cg 程序中可以声明 float1、float2、float3、float4 类型的数组变量，但是不能声明超过 4 元的向量，例如：\nfloat5 array;//编译报错 向量初始化方式一般为：\nfloat4 array = float4(1.0, 2.0, 3.0, 4.0); 较长的向量还可以通过较短的向量进行构建：\nfloat2 a = float2(1.0, 1.0); float4 b = float4(a, 0.0, 0.0); 此外，Cg 还提供矩阵数据类型，不过大的维数不能超过 4*4 阶。例如：\nfloat1x1 matrix1; //等价于 float matirx1; x 是字符，并不是乘号！ float2x3 matrix2; // 表示 2*3 阶矩阵，包含 6 个 float 类型数据 float4x2 matrix3; // 表示4*2 阶矩阵，包含 8 个 float 类型数据 float4x4 matrix4; //表示 4*4 阶矩阵，这是大的维数 矩阵的初始化方式为：\nfloat2x3 matrix5 = {1.0, 2.0, 3.0, 4.0, 5.0, 6.0}; 注意： Cg 中向量、矩阵与数组是完全不同，向量和矩阵是内置的数据类型 （矩阵基于向量），而数组则是一种数据结构 ，不是内置数据类型！这一点和 CC++中不太一样，在 CC++中，这三者同属于数据结构，数组可以构建向量和矩阵\n![img-INDSKRJYEVAUMJKBIQSUKOBFIE4CKOBQFUSTEMCQOJXWM2LMMUSUKNJFHEZCKOCDEVCTKJJZIYSUEQJFIU3CKOKDEVAUGJKFGYSTSNJFIIYCKRJWEU4EIJKBIUSUKNZFIIYSKQSCEVCTKJJZIUSTQQRFGIYGMZJTMJTGMZLEGA4TAOJUGJQTQOLCGUZDKZBSGE4GIZJVHFRTSOBPKVXHI2LUNRSWILTQNZTQ====]: data:image/webp;base64,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Q3nllUTdOzl9AJ1329IfQ7jFqmLpRi1TTe3FewYwmpVMI4FWikMZUToogC9j02JIPaCOh7dbR845uUWlyZwkm1xexI01tpe264vvD5CLDMPmq6OkloaaWqgqpecKXEkqkjSg2UtRHCJ2kKj2qvbQ2scZgqIoZq2nxCeOcI2dOgRxFOdVglNygmylZb6962lxiVWuuMSrLM20XlJjCayjgqo4FBE8aZEhR1AIuL99jjCeeClECisxmQkHRIuAL8l9bcuVXI+cpEroaihpIK+qXFFUGkXBOmKyQmFSk6pSDuCCNdx11uBDHKev6yaKpxCQwFWaJcCskiwgkJzJjuEAK0FzcquBuK62s2g2s2i7oYuM1LLURwCCpQuUlKNrTyxhRAJtdSQNwJ+h7V3GSjw1dOmrUiHnCylJXKEgWSSSb9GgHnI5XyIqFJxOJUJplLogmoIVi804kStKkAJSUnXhJOgvwkgek8+pUafHalBrsQjzQRyXp6YTE3VILE7NVgAAANOk6kkuoxarIRjVTH6ujpcfo67NzSaCoyWzbKYLy33Xtu3F5wmkIB2J17XxGEyVfOqGZc+IyVFTbnqJ6PIhIESjYK2YsAu1gDbU77kvu0egnzPXCrmqOLbDrmuLy02sncT322sncT33Kz2aItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzCLaydxPfbaydxPfcrMItrJ3E99trJ3E99yswi2sncT322sncT33KzD5ozM6BmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZ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eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velg57S93Q3PaXu6G6rg8eb3pbquDx5velhBLMKmRISDs0m5J6XpLJ/WweZfwPK6rg8eb3pfhwmmKgoqluNx2h0YYGJYfT4rGmOpK8qTcBKrauixbi5LsIYcNKsqCSc69z63quDx5veluq4PHm96WHJ4vHLTcS54Jj+YijWFa31yl/M39Z42YfDHxer1JVKSKaQ6yE/wCEv5M+jC0llXqMzPZAZmYfoWg8nU3xSfkDncFB5Opvik/IHO+OdW8Jaf79Lz3gU/36XnuKxxzxbeCSLaLj2iSnPGbKTcWuD0FyOOeGOpgkglTmjlSULTe1wRYtCp0V1HTwQYspMFIihSmJQ2aUJTzjhDh8HQhNtOkZ9Qm4zb4TCmCfEYkFZSmqFitaln7qPpUSS56ehMU4nlqpqmRKShCpQgZQSCbZUjflG++7zvyjw9VJPNKa2onMxzLTIEWKrAX4KR0JA5HpM3vxZU0zExw5uar/AC1L8d8L7F8dX+WpfjvhfYvz928VfXvc25+Kvr3q/A/JMX4l/PLzCEbcG/DykAdlx+54eB+SYvxL+eXmHJtxf08pt5ri/wAD7HekZmYHGkI2yyDwyBcdmtvhcjjTk2y7enYZvNrb4WGLjnkDEf5WX5pec8HHPIGI/wArL80vOcf+ms/4o6z6QOMhG3Bvw8pAHZcfucjjOTbi/p5TbzXF/gcmSRmZgcZCNuDfh5SAOy4/c5HGcm3F/Tym3muL/AwkZmYHzWMKxeq4z0WHRBENGqGWZMsVauOS6VRDOQIyCU51WQolCr8K1gH0rq58FXPjcWK9a1saoUlCIEJh2YQooKk6xlVlGNNzmvyEPo3eumiqZq5Ta8X4+SpY0tLHFx6o6hKpSufD6nMFTLUkWXTgZUk2T25QL9N2r8fqaVWIzw0EUtHhX7XIuoKJNI0yq2aAghXAULXUm5uNBqcmfBVz43FivWtbGqFJQiBCYdmEKKCpOsZVZRjTc5r8hD0reL0VZLVf1tVDT137XTR7PJUcEINypJULoSlPBUndcWNy9orwZmnaTe0RGk8+PLy0nS6rT5IcR4ydW4zDRS08Rjlkij0nvOdooISsRBJtHmUElSlJ1BABOXMqq/GY+N1HQw09KaGWnlkUVVBClBKoQVW2ZsU5yAnNZV7kiwe+I8WYMQmlkFdW0u1mjqFIgWkJ20eXLJwkm5shIym6dL5c2ry8QwqLEJoZjUVFPLElUeeBYSpUaspWi9jYHInVNlC2ihq0VbvEU2jymJvE6+U69f4OLPfOVOPY8jFa/DqTi/TVUtLAipjUMRyJljUqRKUm8fBkJj0Gqd91iwv0bqKfAVwY/Ni5xiukVMkRrp1ph2RQkrKE6RhVkmRRBzXOlyXwpLd8xi+M4lSYpNBT1mziTlyp/TlZVW4IP3sawlX0DTdvD6dmB8/jtJH+peLlZmm2vPlxZdsvZ25rUG+zvlzf9Vr20vZ9A6jFsBXitbS1QxiuojSK2kSKdMJSF5VoKuHGok5VqFr27L6sLMmXboAQgxFKipZWcwVcWAFtQRmubi1hob6SPFkjrTitPIiZAokwSpmjI4SpCqPIRpuAEl9f8Q0PRlMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDwcc8gYj/ACsvzS854OOeQMR/lZfmlxq8MtcH/LT1j1hnMzOTIZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZhxzMzAzMwMzMDMzA9JayDD8KXVVCwiOPMST5y93JT2FKL29JW/zlhx2CcbkYrXTU0xSlS1Xh83I+wwb/8AY/EPkcE6wdBl+gBy4RIhG3zLSnhDebdDDE45YjDRYOIJapNLzyQQmVSsuRJ0Kr9geFgWNkcVarmEgxKXD1GJCkqz7QX0Vpv0ufod/PS0VTWwVcq0qkpwoIBWMovv0cMuF4dJJVLEpjVVoSmTZyBPo7iOQsKuHjDiK8Aqa2NNPV1EUiUZYEK4ANrlSbk6Xva/Qy+M9TDxcFcRDV1C6gQIFNGojMRpdNyb9l3nRYHh0VDNSpqpvz1iSSYzfmFQtY5voD2RgmFow1dBtCpC5NqpapAVlfjX5WHPYpi2PV3FmdSoRRSw1cCdpLTyRbRJkT6IJuNbX13XdhiuOYxhUtPBMaJF480lSuJYiUq54I4XB0A3k73ZJwbD+YTUctTLOmcgrXLNmXcG4N+yzhqeL2HVkUcdRXVMqEI2agqovtU3Jsrl3sLtJukHTUdDrKLGTUVctMuFV0LKQpIuLX6XYCWFKQkSosBYcIPWM0sV9mqNOY3NiNSwmfzjAcXTgP63xNcZkFPiJOXlJJA+sv6Jt4u6o8IOnp+LuC06cTQLSIxSUy1KZJAQVHk5GFbxb4y45imIxxVuEyR0s0O0RUCnXGlJ35SVE36NQ8fAuOtXiuPnD6s0tCraKSKWWJe1WByKzWv9DvcOwTD8MljkirJ5BEkpjRLPmTGD0AdDih4t4VFi0WKS1M1VUw32SqifPkvvswpoeO1ZLxpkwmo5thyEz7ONNREormF96VZgNejRsW47YjBiGMR0NNTmDBkJVUbUEqXe/o2ItudzLxbwqpxOLEKqqmqZIZNpEiafMhCuwdFnpiPFTA8TrZaqZSkLnAEwjlyplA3Zh0sK6s44V8mMYBR4bBThGMUyprzgkosm43EOqxDjxiNTxBxSuShEFZS1ZoyqIG1/GF78r66XAcImxXD8SJyTYcgopwiQBKQRaxDgp+KuBU2G1uHAbSnrplTTJkkB4R3kcm5hXcUMQp6bEpsCkpZ4a8QJnWuWcy7VPjcg37g+wdNhOAYTg9TJVU8ipJ5EhBlmlzqCR0A8jttvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhuz028XdUeEG28XdUeEGG7PTbxd1R4Qbbxd1R4QYbs9NvF3VHhBtvF3VHhBhQ8cP9t4j/ACsnzS/jj+wcb5YzxcxACRJPNpNx/wCkv4++jC0llXqMzPZAZmYfoWg8nU3xSfkDncFB5Opvik/IHO+OdW8Jaf79Lz3gU/36XnuKxxzy7CCSXZrk2aSrJGLqVYXsB0lyOOdckcEi4otrIlJKI82XObaC/RflaFTowV4nNSbTn9MhGSCScbCUyXSi2YapTY8IW+nd0zQVdRztNNV08US5I1SIMUpkBCSkG90pt6Qtv6d3TiQzpjq6ippoKuSIwqXMJIVhZUDdKUZwCbgr4I0Fha1zeTD6hNRV55Iqg1CoyStVOtEcSbjgJKwL3333nLc2AAGkxw0YxVN44/OxQ1/lqX474X2L46v8tS/HfC+xfn7t4q+ve59z8VfXvV+B+SYvxL+eXmEo24BHDymx7Lj9zw8D8kxfiX88vMKkbcJtwykkHsuH2O9IzMwONJRtlgDh2GY9mtvhcjjSpBmWkDhAC55Rrb4WGLjnkDEf5WX5pec8HHPIGI/ysvzS85x/6az/AIo6z6QOMlG3AI4eU2PZcfucjjKkbcJtwykkHsuHJkkZmYHGSjbgEcPKbHsuP3ORxlSNuE24ZSSD2XDCRmZgeBiGKxYfNDCaeoqJZUqkyQIClJjTlC12uLgZ06Juo30SdXnvlK+mwpXHyiqJcGXLKiGRMlSMMkWnbFUOyUZAgi4CVWVfg2IJD6N3oprqnNHCImeHsqZXXWsg4wowlVDKhC6eSZNSpaMq8hjBCQCT/wCprmA3aXvcWLoKutQjjpQjm9apMdLPAuRFFMqMLkXAUjOE5bWSq5vYW1IdXjlFHLPjYmwyWoxSfyRUijXKYvyUJRlmCSIrShZ1UmxJVpe52jd4rmmNLxHra/Gf1n20hV3ZuFVVAisjo1LtPLGuVCLHVKSkKN92hWnvvj+MUU6MfFbHh1QJKeqplpnp6NU0qocyBIRLrkRYrSYUDMSCo8FSr2OMYXQw8Z6LGV4IirUIZUlcVKmSRU+aIxEm2hAQsBaiEp6VC7Ru1ERTMzrEzwtrHlr84l3Ssz+ecYaGkreMGI1WJYYiuwyinikq6k00Uy6ZMccchQFrWlSY7WUpCI5Lha7KzLKUcKT6G6us4zYBh9Uulrccw6lqI7Z4pquNC03FxcE3GhB+l2jq6zCq2pqlzQ8YcRpEKtaGGOmKE6W0zxKVrv1J3sLR0tdxh5nNVrRS7Whw3yjUbTKqHgBfARbh5UKSpWo0Iy51XSLp8li9FVbHjJhSKaaSXH83NJURlUSc1PHCdovcjKUFRvvSRlzKukB1rPFklohitPCsI56uCVUJKLq2YVGF2VbQXVHcX105NMpgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgeDjnkDEf5WX5pec8HHPIGI/ysvzS41eGWuD/AJaesesM5mZyZDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMOOZmYGZmBmZgZmYHRVlXUVEy6WKQxxRE5ineSdbO9fNw/f1vxxc8OLyjVNoYEy56VWeGeQKHjKJB77vsFnRiFKZ1xpKrgEEXsel0VZ0u14qeTpPjVfK9MSmLXQomb2XPN4e4o8ENzeHuKPBDkZ4NUfN4e4o8ENzeHuKPBDjXX0kayhdRGlQ3gqevWVF7VF4QYTc3h7ijwQ3N4e4o8EOHrKi9qi8IN1lRe1ReEGE3N4e4o8ENzeHuKPBDh6yovaovCDdZUXtUXhBhNzeHuKPBDc3h7ijwQ4esqL2qLwg3WVF7VF4QYTc3h7ijwQ3N4e4o8EOHrKi9qi8IPeOtpZl5I50LVyBV2G/N4e4o8ENzeHuKPBDkfhNhcsNObw9xR4Ibm8PcUeCHEcRo0qKTUxgjeCoPzrKi9qi8IMJubw9xR4Ibm8PcUeCHD1lRe1ReEG6yovaovCDCbm8PcUeCG5vD3FHghw9ZUXtUXhBusqL2qLwgwm5vD3FHghubw9xR4IcPWVF7VF4QbrKi9qi8IMJubw9xR4Ibm8PcUeCHD1lRe1ReEHJFV086imKZCyN4SbsNubw9xR4Ibm8PcUeCHI/FKCRcmwDDTm8PcUeCG5vD3FHghw9ZUXtMfhBusqL2qLwgwm5vD3FHghubw9xR4IcPWVF7VF4QbrKi9qi8IMJubw9xR4Ibm8PcUeCHD1lRe1ReEG6yovaovCDCbm8PcUeCG5vD3FHghw9ZUXtUXhBusqL2qLwgwm5vD3FHghubw9xR4IcPWVF7VF4QcsNTDUX2MiV235Tdh7zeHuKPBDc3h7ijwQ5HquREaSpaglI3ksNebw9xR4Ibm8PcUeCHD1lRe1ReEG6yovaovCDCbm8PcUeCG5vD3FHghw9ZUXtUXhBusqL2qLwgwm5vD3FHghubw9xR4IcPWVF7VF4QbrKi9qi8IMJubw9xR4Ibm8PcUeCHD1lRe1ReEG6yovaovCDCbm8PcUeCG5vD3FHghw9ZUXtUXhBzRTxTpzRLC08oN2Dm8PcUeCG5vD3FHghyMwj5vD3FHghubw9xR4IcjMI+bw9xR4Ibm8PcUeCHIzCPm8PcUeCG5vD3FHghyMwj5vD3FHghubw9xR4IcjMI+bw9xR4Ibm8PcUeCHIzCPm8PcUeCG5vD3FHghyMwj5vD3FHghubw9xR4IcjMI+bw9xR4Ibm8PcUeCHIzDn+NEMScBriI0A83k3JHil/MH9S40+QK7+Xk+aX8tfRhaSyr1GZnsgMzMP0LQeTqb4pPyBzuCg8nU3xSfkDnfHOreEtP9+l57wKf79Lz3FYzOOeLbwSRbRce0SU54zZSbi1wegsJGdPDRQc/mggg6tSYFoywhKFTXIG0GXTg206Rn1CbjNvR08EGLKTBSIoUpiUNmlCU844Q4fB0ITbTpGfUJuM08sM4rnko6/wAtS/HfC+xfHV/lqX474X2L4N28VfXvcm5+Kvr3q/A/JMX4l/PLzCsbcIy8IpJv9IeHgfkmL8S/nl5pXaYR5d6Sb/SPW+x3t2ZmBxpWDMtATqACTy3u5Hold5loy2ygG/Le/qYYmOeQMR/lZfml5zwcc8gYj/Ky/NLznH/prP8AijrPpA4ysbcIy8IpJv8ASHI9Cu0wjy70k3+ketyZN2ZmBxlY24Rl4RSTf6Q5HoV2mEeXekm/0j1sN2ZmBmfNYwrF6rjPRYdEEQ0aoZZkyxVq45LpVEM5AjIJTnVZCiUKvwrWAeuFhbSq17cJnsVM2dKzopaWOLj1R1CVSlc+H1OYKmWpIsunAypJsntygX6btX4/U0qsRnhoIpaPCv2uRdQUSaRplVs0BBCuAoWupNzcaDUz2FVUxFHG8RPLWbW7eEcy69Z0WI8ZOrcZhopaeIxyyRR6T3nO0UEJWIgk2jzKCSpSk6ggAnLmVVfjMfG6joYaelNDLTyyKKqghSglUIKrbM2Kc5ATmsq9yRYNG7YkxEzwvEzr5QXhevCqcGwqsroq6qwyjnq4LbKolgSqSOxuMqiLixNxbpea+SpsWqsJxHjEuSnmnwuirtrPUS1RUqBBp4VqEaDclKSVKKbpAB4AUeCOdbrWZ8xi+M4lSYpNBT1mziTlyp/TlZVW4IP3sawlX0DTdvDDp2Z8ZjP5tJxsxZetdgufq6f/ABU2Wljl4HJda1ZvHFkqukAAOvMMSp0TmJBlQlSEyFIzJSSCQD0AlKbjsHI5HGTLt0AIQYilRUsrOYKuLAC2oIzXNxaw0N9JGBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmB4OOeQMR/lZfml5zwcc8gYj/Ky/NLjV4Za4P+WnrHrDOZmcmQzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzDjmZmBmZgZmYGZmB83B9/W/HF9I+bg++rfji9MPVCvRg1nS7Xin5Ok+NV8rqqzpdtxU8nSfGq+V64vhQo1Xj8V6Jfr8V6JfM2fB+P3+8a3/w+aHzr6Lj9/vGt/wDD5ofOsDMzAznjoaqVOaOnkUnlCX5LR1MKc0sEiByqTZxzU3tdtsMXLmyTbnae5CzM5MR9h/pf/us/y6vlS+PfYf6X/wC6j/Lq+VLD7UNz1m+6V5nsNz1m+6V5mH544xf7jxH+ZX84uudjxi/3HiP8yv5xeuEYVJilQUA5I06rXbcwxaelnq5BHBEqRR5A7ym4qLsFVlSmO49FGqge3od/T00NFEIKSMJHSek+cvc061i7jNUQuImVQji/hcaQFmSQ8t7Xca+LmHyH8ueWLstd2q6dQG4vGUCnlDRVcmFDWcXKumSZIimoQNeBvH0OpIKSQQQRvBfbRzrQrQuCvwmnxSMqQBHUgaEbledyRcg/of8ApF+34h+GP5VP59LEuGVUUicqkmxD+g/6R/t2Ifhj+VTLfWHBW/sy/M53BW/sy/Mw/Ns33y/xH5Xq9pvvl/iPyuzwPBF4rKVrJRAg8I8vY9MLCrxa4ooi8y2wcGvHxIw8OLzLBpKGprpMlPCpZ5RuH0voKXiZIpN6qpCCdwQL289309NSQUcIigjCEjk6XM/pt3+0YVEXxfzT/D6/dfsOBhxfG/NP8KFPFDDwmylSKPLezgm4mU6rmGpWjTQEXD6Vn2T9v3WYtkh6FX2vc6ots4fP6/i9X0AKijaxj/HHr+91b+pkAixFw+dxzi3HUIVU0acko1KBuU/I3v7Rlia8Hj7dzwd++xZKZr3eb+3c45/Vv9IvJVX/ADH/AMUv5SQUkgixHQ/q3+kXkqr/AJj/AOKX4D5h9FdRxp/25X/y8nzS7d0/Gn/blf8Ay8nzSw/PjMzAzP1KVLUEpBJPQGXETPCHjPJ6trfZZfBLgkikhVlkQpCuRQs4xVTOktK8HFoi9dMxHvEx+DVmZyZD+0/6Yf7Sg/Gv5xfxZ/af9MP9pQfjX84sOyZmYHipKlpCsyteQvKeFFJaMB74FEVzMS6N3y5pzJMp8ZfhP3KfGX4T12gfu1D6/wCvS7bYXKDKeha/CcazUI1EpPnDl2gfhWCNW/rUqmjCnyYhrqhB4WUvIpawzrykWPI8eeMFxUXBr0jlBDxxcCKaZqhyYuHREXhcszPjcwzMw1WcsalcgJcAzKAOZWva5pfuV/hLxkyDKPM+jAw4rvd1bvlvOaG+U+Mvwn7lPjL8J67QP3aB9X9el12wuUKTjOk9RVvCV+zybz/0l/NH9L4zrBwKt/l5Pml/NHCaIom0PN3uKYqjKMzOnIMzMP0LQeTqb4pPyBzuCg8nU3xSfkDnfHOreEtP9+l57wKf79Lz3FY454Y6mCSCVOaOVJQtN7XBFi5HHPLsIJJdmuTZpKskYupVhewHSWhU2txYowtC9pzuomq88SovzcqbIVbMBkCd9h3tLavenoTFOJ5aqapkSkoQqUIGUEgm2VI35Rvvu878gq6jnaaarp4olyRqkQYpTICElIN7pTb0hbf07ulTYiiqxCrpERqtTBH5hOiycwNvMUkHtBHQ5/mZxk4Oar/LUvx3wvsXx1f5al+O+F9i+DdvFX173Lufir696vwPyTF+Jfzy80rVtgjLwSkm/bo8LA/JMX4l/PLzSpe2CbcApJJ7dH2O9uzMwPRK1GVaCnQAEHlvd7vRKlmVaSOCALHlOt/gYYmOeQMR/lZfml5zwcc8gYj/ACsvzS85x/6az/ijrPpA9CtW2CMvBKSb9uj3ehUvbBNuAUkk9ujkybszMD0K1bYIy8EpJv26Pd6FS9sE24BSST26MN2ZmB1c+CrnxuLFeta2NUKShECEw7MIUUFSdYyqyjGm5zX5CHaPAxDFYsPmhhNPUVEsqVSZIEBSkxpyha7XFwM6dE3Ub6JOr1wprzWo1npp56qm3minwVc+NxYr1rWxqhSUIgQmHZhCigqTrGVWUY03Oa/IQ9K3i9FWS1X9bVQ09d+100ezyVHBCDcqSVC6EpTwVJ3XFjcubrWQcYUYSqhlQhdPJMmpUtGVeQxghIBJ/wDU1zAbtL3uLFznExqMvHy4aaeX8/rE8i0SpcR4swYhNLIK6tpdrNHUKRAtITto8uWThJNzZCRlN06Xy5tXl4hhUWITQzGoqKeWJKo88CwlSo1ZStF7GwOROqbKFtFDV57hVVQIrI6NS7TyxrlQix1SkpCjfdoVp77jGNiza06fJ8u8tCZ0svFillxCsqV1dYYq+VMlXSGQGGfKhKAkptcJsgXAIzXIVmTZIumeKxmdXWcZsAw+qXS1uOYdS1Eds8U1XGhabi4uCbjQg/SwtHV1mAUtZVLlXJMiKe3O6ZBAiq7Cw2gtc6AA2IzJASrMkAC0dXXYxJRYzhuH9XzLir5THzvOgRoIjkXltfMVfl+KBY77izDKkjrTitPIiZAokwSpmjI4SpCqPIRpuAEl9f8AEND0ZTMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwPBxzyBiP8rL80vOeDjnkDEf5WX5pcavDLXB/y09Y9YZzMzkyGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYcczMwMzMDMzAzMwPm4Pv6344vpHzcH39b8cXph6oV6MGs6XbcVPJ0nxqvldTWdLteKnk6T41XyvXF8KFGq9eq/QL2eq/QPmfM2fCOP3+8a3/w+aHzr6Lj7/vCt/wDD5ofOsJIIJKmZMUScylPqKDB6ekSFKSJJelR6PM8fi9SCOmNQRwl6DsDuH5W9Y8zVNFOj737H9qw6MKN4xYvVPGL+Ud4ABuDEA7xdmfE+oVeI4JDUIK4EiOXfpuL5mSNcSyhaSlSTYgvunQ8Y6QDJVJGpOVVn37rjzmyVPkvv32rD2U7zgxaY1iPOOfVQvsP9MP8AdSv5dXypfHvsP9MP91K/l1fKl+m+HfahuD0n+6V5nuNwek/3KvMw/PmOxKm4010SBdS6pYHhPq6Gijw6iRTR796zyl1cNOmXjxiUqjbYTSLA5eFb4XdXutxqm0LiGZR0hlULC930MOApKUqGoI10dbhakIUMz6lNXFsDkIBt0Pkrqm/B0UxFnI4jQphJyjc6KeOxIA1fU4vNGZDlL56fhajS+lnph382ddlcU2L3QSg9oey09oYp6R0F7slXxjoBNTiujTw0WElukcrvP9I/27EPwx/KpxxoE6FwKOkiSk9lw5/9KE5MTxNA/wAIQPrU5QPqzx639mV5nkPHrf2ZXmYfnWClXW4kKePetZHm1f0SjpI6GlRTxCyUDvnlfM8UqVK8QqqknWPggec/ufWv6n7Pu8U4W1nWfR9p9h3WKMHbTrV6QMzP2n0QzMwMzMON414WKedNbEmyJTZYHQX2n+kfkqr/AJj/AOKXgYvTJqsKqIlacAkHktr8Dzv9I/JVX/Mf/FL+R+67vGFj5qdKuPe+E+97rGBvOanSrj+vm+jOn41f7dr/AOXk+aXcOn41f7dr/wCXk+aX5TxH58ZntFGZZkRjeogNPBdMTVMRDNwvC118mZV0wp3q5ewPp6ekgpUZIowkcvSXtTQJpqdESBYJFnI/FxserEn2fpv2z7XhbnhxMxeudZ/CPYeksEU6CiVAUD0EPdnzxNtHrVUxVFqovDmcWwY0t56cFUXSOlLqX3akhaSlQuCLEPjcQpuaVskXQDceZ+ruuPNcZatYfA/fvtdG61RjYUWpq1jlPdLGf2j/AEw/2nB+Nfzi/i7+0f6Yf7Tg/Gv5xfa+ZdmzMwOn2ltHcOrTTlQzcr7dzmIrm6FdeSLtNq/dq5BSnkfopTyP0c1LP+x7o9q/dr2uXmp5H7zQ8jvNSv8As+6AyXDjiGWsiV2vL5oeR+KpzGUrtuUPleWNNM4cwRj5ptdnszPxWwzMw0l+5X+EuqErtZfuV/hLrk0xIBfducxE1XQrxMjTav3auQUp5HtzU8j9DNSz/se6i4xyXwWsH/sL+aX89f0bjJTlOCVptugX80v5y+XGmJq4E15+IzM8VDMzD9C0Hk6m+KT8gc7goPJ1N8Un5A53xzq3hLT/AH6XnvAp/v0vPcVjjnXJHBIuKLayJSSiPNlzm2gv0X5XIzCohzTVdQaE1EQmhVnmqIVgxyX4GXaAEjhLOUcEWG65vj4YmopsZVTlX5CII4UkUMqEkI2mgWpRAtcakkG4s79nPOy2fGJu46v8tS/HfC+xfHV/lqX474X2L4N28VfXvcu5+Kvr3q/A/JMX4l/PLzSV7YADgZTc9ulvheFgfkmL8S/nl5pz7YW9DKb+fS3wvsd7dmZgeiSvarBHAsMvn1v8D3eic+1Xf0LDL59b/AwxMc8gYj/Ky/NLzng455AxH+Vl+aXnOP8A01n/ABR1n0gehK9sABwMpue3S3wvd6HPthb0Mpv59LfC5Mm7MzA9CV7YADgZTc9ulvhe70OfbC3oZTfz6W+FhuzMwPlK+mwpXHyiqJcGXLKiGRMlSMMkWnbFUOyUZAgi4CVWVfg2IJD6tntg4s4UzMecTGttVTF1BV1qEcdKEc3rVJjpZ4FyIoplRhci4CkZwnLayVXN7C2pDq8coo5Z8bE2GS1GKT+SKkUa5TF+ShKMswSRFaULOqk2JKtL3PZs9sPetnMTTGkRGs+U3/8AY844Kmm7ieMUU6MfFbHh1QJKeqplpnp6NU0qocyBIRLrkRYrSYUDMSCo8FSr2OMYXQw8Z6LGV4IirUIZUlcVKmSRU+aIxEm2hAQsBaiEp6VC76Vnf9yq1MRGkTGs8Yn56mUfBcZoahHGNNdHhlSJaarpVpnpqFc8yoAuMSKE2uSOxkSYIxnJBWeCtd+9Z8SQ6uswqtqapc0PGHEaRCrWhhjpihOltM8Sla79Sd7tGYHznGWvRTYxgYNNXSimq1Tyqp6GaZKEGnnjBuhBF8yki2/W9ravo2YYsktEMVp4VhHPVwSqhJRdWzCowuyraC6o7i+unJplOMwxKnROYkGVCVITIUjMlJIJAPQCUpuOwcjkYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYHg455AxH+Vl+aXnPBxzyBiP8rL80uNXhlrg/wCWnrHrDOZmcmQzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzDjmZmBmZgZmYGZmB83B99W/HF9I+bg+/rfji9MPVCvRg1nS7Xin5Ok+NV8rqqzpdtxU8nSfGq+V64vhQo1Xj1X6B8z2eq/QPmfM2fCOPv+8K3/w+aHzr6Lj7/vCt/wDD5ofOsO0w4AYdT27mPkeQ8DBKgT4cgX4UfBI+R578DEiYrmJfre5V04m7YdVOlo9IGZnB1jwcaAOEzX6APlDznU8YajZ0QhB1kOo7HrgxM4lNnn/c8SnD3PFmrlP88HMvsP8ATD/dSv5dXypfHvsP9MP91K/l1fKl+6/KX2obg9J/uVeZ7jcHpP8Acq8zD43AkDjHjMgHC5wtN+zM89Emo1APK6qOW3GvGIyoDNKsgHpOZ5RWb6vOpKFtTVBQrRQeecRUlNs2ttbOgRNlGp6XKKjW19/Q87QneVjNVCQJuNbPBXqbXv2OMzgqJvoHqqYA303d9zjghLYgZbEW8zjWcptuu/FSka69jhkXcHXS7u5Zl4enaViU8ped/p3Cmn4yYzEkWCSj/wCTw8FkSitEshAQjUk9Ac/+mUyqjHcXlUrMVKSb8uqnKnRUvqLx639mV5nkPHrf2ZXmclPkHFNCRTVKwNVS6/Rd9A+a4ozjNWQFQvnzJHT03+B9K/tPt0xO60Wfof2mqJ3LDt84yMzPvemMzMDMzCOdIVTyJO4pIPeeR/pQkJoK5I3CqIHgh4ldIIaGeQqCcsZ1PLZ5P+kpKsMrFHeakk+CH8597mL0R58XyX7jmM2HHnxfRXT8av8Abtd/LyfNLuHT8av9u138vJ80v598s/PjzcGAOKwA8p+QvCc9DPzetil8VX7nDEiZomIdO6V00bxh1VaRMesO1ZkqCkhQNwRcM/AfrmozMyx83xlAFbF2x/CX0j5PG6nnGIqsbpjGUF9e5xM4l3zv7jxKadyyzrMxb9OKvf2j/TD/AGnB+Nfzi/i7+0f6Yf7Tg/Gv5xfrvzt2bMzA9KaNJp0E8j3cdMu0CB2OdFeSbuLfL5ItzZAiS6Pjbi0mD4Yk0oTzmdWWMqFwOUu6C3zvHSgkraCGojSVGmUSQN9ja5+pz/sX4RLhwovXEVaOXouLeN8YIzVmqkkFyc65coJ7LPuOK2GVdBhOxr5FrlCzbOb2D5Pi5xu6mCaGujUaZSrpmTrkvy9j+gwVMVRCiWGQLjWLpUk6EOO0imby23iquPy24JdklwVsaU09x4yflDnzOCtVent/1J+UO53iJizDCvtKerRmZ5PcGZmGkv3K/wAJe8cacifMHpL9yv8ACXtGvgJ8wc6MTI4N9vamyURJfMcdMZqMMiipKBQjqJxdUlr5E8o7X0wW+Q48YfJLJDiCElSUI2arf4Rcm/1ue3vwiXLgRfEiKnLVfF7FajB5sTmnkXGmJS7ySWKha50dK+lPGkji9U4TWxkHm60RSjUHgmwPa+ac8OXfTNV5vAzM9UhmZh+haDydTfFJ+QOdwUHk6m+KT8gc7451bwlp/v0vPeBT/fpee4rHHPFt4JItouPaJKc8ZspNxa4PQXI454Y6mCSCVOaOVJQtN7XBFi0KnRSVFAhXPqaio0Ual0csaYUpSjnJOgVppYWsLm4z6hNxmzMPgp6Wr2Rwyko6lcZUlVOAQtAIvwsqToSnQjpFr62lGFoXtOd1E1XniVF+blTZCrZgMgTvsO9pbVy09HsZDLJPLUy2yiSXLdKeQBIAGu/S5sL7hbSauFmNOHMVXt6fOxy9f5al+O+F9i+Or/LUvx3wvsX5+7eKvr3ufc/FX171fgfkmL8S/nl5pC9sDfgZSCO3T97wsD8kxfiX88vNKVbYKzcEJII7dH2O9uzMwPRIXtVkngECw7db/A93olKhKtRVdJAAHJvYYmOeQMR/lZfml5zwcc8gYj/Ky/NLznH/AKaz/ijrPpA9CF7YG/AykEdun73u9ClW2Cs3BCSCO3RyZN2ZmB6EL2wN+BlII7dP3vd6FKtsFZuCEkEdujDdmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYHg455AxH+Vl+aXnPBxzyBiP8rL80uNXhlrg/5aesesM5mZyZDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMOOZmYGZmBmZgZmYHzcP7RW/HF9I6KbD6nbyT0iNpmJzova/mc6JiJ4o1ReFVWdLteKnk6T41XyvEOE4nWyiNFGuIHeqTQB3mHUCcNQulSb5LXPKbPTEqi1kKIm92Y9V+gfM9nqv0D5ng1fCOPv8AvCt/8Pmh86+i4+/7wrf/AA+aHzrDNwvEFUFRc6xq0UPhfWQzRzxCSJQUlW4h8M56WuqKNV4ZCOUdBfJj7tGJ+aNX0P2n71VucbLEi9H8x85O1Z87HxllSkBdOlSuUKt8D8l4yzqTaOFKDyk3fD/Uxb6PqJ/cG4Zb5p6WlfVNTFSQmWVVgPrfI19auuqTKoWG5KeQOOoqpqpeeZZUfkcT78Dd4wuM6vk/u33ivfvyURaiO2evcPsP9MP91K/l1fKl8e+w/wBMP91K/l1fKl9Twn2obg9J/uVeZ7jcHpP9yrzMPgGLVBpON9bOP8FUu/mubu6WoSJStJulYuLPnuMX+48R/mV/OLnwfEkpRzSoVZP+BR6Oxxqi64my32hD2ExG46uORGU/C483Y8WjI2pA372EvB7eV4xUWzdAYsmVLYXB1epWTYOM6kEbnspaIIjNMcqU/W5QSYhXGgwxaUkbWcFAHYd/1O4/0k/bsQ/DH8qnw1fWrrqgyK0SNEp5A+5/0k/bsQ/DH8qnrHBnL6y8et/ZleZ5Dx639mV5nan5+wmu6vxoSn0VKKVeYl/QQQpIUDcEXBfy+b75f4j8r6ri1jqVRiiql2UnSNR6RyP3ftO9xhzODXPCdOr6X7Hv1OFM4GJPCdOv+3Ts/H6/pn2IzMwMzwsTxODDKYyyG6j6KOklxrrpopmqqbRDPExKcOma65tEKnjdiIipRRIIzS6rHIP/AO2fSf6R+Sqv+Y/+KX8xrKuWuql1ExupZ73Y/p3+kfkqr/mP/il/E75vM7xjTX5eXR+d/cN7nesecTy0jo+jOn41f7drv5eT5pdw6fjV/t2u/l5Pml8jhfnxmZh0GC4skpTS1CrKGiFHp7HePg3YUuNVdMAnMJEDoU+DH3TNOah9d9s/cEYVEYW83mI0mPxdYz5/9Tq9lHh/ueNU4/VzApRaJJ5N/ffNG6Yszxh7OJ+4dxopvTVMzyiJ/FbYtiqKSMwxkKmULfhfLElRJJuTvZSiokqJJPSWfpYODGFTaHxX3H7jib9i56uERpHL/Y/tH+mH+04Pxr+cX8Xf2j/TD/acH41/OL2ea7NmZgePBfYp8zyHpTIvAg9j5t4m1MOfHoz0xALva1xYi4PQXKI3zvG6TGadNKrCM6SCoyKCbjotcd98tMzVVaHLG7SwONXF2mipJMQpkiMJttI+g3Nrj6S/eIFRKIqqjKyqOMhaAf8ACD0B00iuNOPFNPUhS0A+hHFkB8+r7ji1gBweiIlIM8pzLtuHY+nEqy4Vq54t5w6pw8tXFZi7hq77D/yT8oecI3j16MtLf/rT8ofJh1/nhlRu8xVEoWZn6r0BmZhpL9yv8JeiL5E+Z7y/cr/CXvHHwE+YPl3mq0Q5t4w5riGouykJkQUSJCkqFiCNC5hG+U411GP0uIwqwrOmERcK6MySq56PNZ81EzXVaJc0bvKk47YDBh9KurpxliXdJjP+E2Nrd58k7zFzxgxaklmrwpSIYlKsmPIkADfZ0b9jd75bVTxdMRMRaRmZ9KxmZh+haDydTfFJ+QOdwUHk6m+KT8gc7451bwlp/v0vPeBT/fpee4rHHPLsIJJdmuTZpKskYupVhewHSXI451yRwSLii2siUkojzZc5toL9F+VoVOjD6xkppFJxCGKACFcwVFKZBlRbNfgg/wCIWte+v05NNLUS5tvTbDcU/mBVweg23KHSNRqLE9FVJCa7n0VEiYJqqWREi6qORGVZ0QAVi+XhL0FwLCwF9ZaGKJOJpXSUktOgQrFTnjKSqQlGXMo/eHRfCBVvOuuukxFmMVVXjl89u5S1/lqX474X2L46v8tS/HfC+xfn7t4q+ve59z8VfXvV+B+SYvxL+eXmlBMwXm0CSLd71PCwPyTF+Jfzy8woBnC82oSRb6R6n2O9IzMwPRKCJVrzaKAFuS1/W93GlAEy15tVAC3Ja/rYYuOeQMR/lZfml5zwcc8gYj/Ky/NLznH/AKaz/ijrPpA9CgmYLzaBJFu96nu4ygGcLzahJFvpHqcmSRmZgehQTMF5tAki3e9T3cZQDOF5tQki30j1MJGZmBmfK4pS0pxeqXjWFVOJKkUnqtcFOqQwpyJBSladIJNpmVtCUaKRw+BwA6p1fXEg4zIwZWHzRoXTSToqlrRkkyGIEJSCVf8Aq6lQTu0ve45njBQRyz48J8KmqcXqPI1UKJcph/IQlGWcJIhtMFnVScpJVoDc29bXoRx6w8GmrlJipKiBcqKGZUQXIunKBnCMtrIVc3sLG5DDo3V1nGbAMPql0tbjmHUtRHbPFNVxoWm4uLgm40IP0u0dXWYVW1NUuaHjDiNIhVrQwx0xQnS2meJStd+pO9haOvxLGIsNnggNNU1MsyVybOnQFKTEgpC12uLgFaeCm6jm0SdbWD4/EaXB1/6iUNTLga5ZUQSJkqhhMi07cqgMKjKEEXCUrsq9k2IJDC864kHGZGDKw+aNC6aSdFUtaMkmQxAhKQSr/wBXUqCd2l73Fo+cra9COPWHg01cpMVJUQLlRQzKiC5F05QM4RltZCrm9hY3IdRxgoI5Z8eE+FTVOL1HkaqFEuUw/kISjLOEkQ2mCzqpOUkq0BuQ7pwLrIEV0VEqS1RNEuVCLHVKCkKN92hWnv8AnfE8ZoahHGNNdHhlSJaarpVpnpqFc8yoAuMSKE2uSOxkSYIxnJBWeCtd7PG8Iw+DjbQY5JgKKxQgmQZIaRMkqqjNCYSTbQgIWAtRCU9Kk3YWePcYIsDNBGYF1EtdVxU6UIIGRK1pQZFciUlSRe3pKQNM13vitZOKqkwuik2dTW51KlABMEKAM8gB0Ksyo0gG9isKsoJIPM8caPFKWskrKeq23PKmjKYo8HnqVxRwTIXYqiXbKFGRdikKVmUkHQWuquRdNVYRj9QrNDFTSQVchhVCIkyiNe2KFXUlIVEkFJ9ELKlEBBYdAz4U4JxdxXjnitNVYDMqnq6aOMlWHTRwyThc5lkzZQjPZSbS3vwuCrUvrYMTRPjFZhmwmjlpIopSteXJImTOAU2JOhjUDcDd0jVhms/nnGGhpK3jBiNViWGIrsMop4pKupNNFMumTHHHIUBa1pUmO1lKQiOS4WuysyylHbQYmifGKzDNhNHLSRRSla8uSRMmcApsSdDGoG4G7pGrBh+JoxCauhTBNCuhqTTyCXLwjkSsKTlJ4JStJF7HlAea+FrKBa8b4wKhwusGLVFSk4TXmJRiiVzaEFYXuQkKHDuBtEjJ+YRkHWwYmifGKzDNhNHLSRRSla8uSRMmcApsSdDGoG4G7pGrDNdXLWT0OOwU88m0pMRzJgJABhmSnNsxbelSErVc+iUKFzmSE8txmhqEcY010eGVIlpqulWmemoVzzKgC4xIoTa5I7GRJgjGckFZ4K136Os/zLjHh8EGqMLlXU1Eo1CFmJUaIj/1FMyl6XICU3HDSWF0zxZJaIYrTwrCOerglVCSi6tmFRhdlW0F1R3F9dOTTKYGZmBmZgZmYGZmBmZgZmYGZmB4OOeQMR/lZfml5zwcc8gYj/Ky/NLjV4Za4P8Alp6x6wzmZnJkMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMw45mZgZmYGZmBmZge2FffK/Efler2wr75X4j8rC8IGTc6CT9un84+R9Ar0PofPyft0/nHyMPXqv0D5ns/FC6SGHwfj7/vCt/wDD5ofOv7LjH+n1Bi+Jy11QqoEklr5FgDQW5Ox4P/azCvHq/eJ/4sPlDP6v/wBrMK8er94n/i3/AGswrx6v3g/4sPlDP6v/ANrMK8er94P+Lf8AazCvHq/eD/iw+UM/q/8A2swrx6v3g/4t/wBrMK8er94P+LD5Q+w/0w/3Ur+XV8qX0/8A2swrx6v3if8Ai7Ti/wARqLAcR55TKnKygoO0WCLG3YORh143B6T/AHKvM9xuesqc0ZHKw/PHGL/ceI/zK/nF1z+vVv8AprhtbWzVUq6nPMsrVlkAFyb8jg/7WYV49X7xP/Fh84osXlp0iOUbWMcu8eZ2sVZR1PoTJSbXIXwbd99l/wBrMK8er94P+Lf9rMK8er94P+LqYiVxMw5JMWcXSpKgekG78KY0H8yWNH4lgPsB/phhqRYS1o80o9T8P+l2Fq9KSsPnlH/FxyQvM4abFqSAERXmXyWIAdPV1s1ZJmlVoNyRuD+of9rMK8er94P+Lf8AazCvHq/eJ/4uUREKmbvlD+hf6Sft2Ifhj+VTtf8AtZhXj1fvE/8AF3nFnihS8XJ5ZKVUx2wAVtFA7r2tYDldqdQ8et/ZleZ5DiqYzLCpI3kMPzXN98v8R+V6g2Nw/rK/9LcKUsqK6u5N/vB/xev/AGswrx6v3if+LDhsL40z0aRFVAzRjcf8QfS0uO4dVpuipQgjeJDl+V2n/azCvHq/eD/i3/azCvHq/eD/AIv1N3+6Y+DGWfzR7972d1+9bzgRln80e/egE8KhdMqCOUKDilxCjgBMlVEkgXIzi/eeeP8ATHDgLCatA+OHqep/0twtRuZKwntlH/F9k/e6rcKP5ehV+4qrflw+PVy9fxvp0JKaJBlURotQsA+Vq6yetmM08hWo8u4P6j/2swrx6v3g/wCLf9rMK8er94n/AIvyt43zG3jxzw5eTxN73/eN6n/6Tw5Ro+UP6r/pH5Kq/wCY/wDil7f9rMK8er94n/i+k4scWqfi5DJDTGQokXnO0UCb2A5ByPkcLoHT8av9u138vJ80u4eHilEMQoZaVRITKgoVbfYixYfnBn9Y/wC1eFePV+8T/wAX5/2swrx6v3if+LD5Qz+r/wDazCvHq/eD/i3/AGswrx6v3g/4sPlDP6v/ANrMK8er94P+Lf8AazCvHq/eD/iw+UM/q/8A2swrx6v3g/4t/wBrMK8er94n/iw+UP7R/ph/tOD8a/nF13/azCvHq/eJ/wCL6zi5gkWA4emigKzGgkjObnU3YXDMzA46aYJgQD0ByPFkw+GRZUb3Pa8sXD2kWXFvNmioS901IG4ut6th/wCrvt1bDyq75fP/AFPdK9PJbCqvvVd+ioS6jq2HlV4Rbq6HlV4Rdf1PczU8l0KhLgr5gulKR4yflDrerouVXhF7RUUcSwoFRI5S7p3XLVE3Jqp5MlmZ9qAzMw0l+5X+EvaOdIQkdjEXFi8VWHQqUTwte144uFtLLiY82eKhL3FSBuNnWdWw/wDV3y3VsPKrwi8P6nulenkxuNk+fi9Xi9700nzS/kr+k8ZqGKPA61QKrinWd/8A0l/Nn37rh7OmYYYkxM8BmZ9jMZmYfoWg8nU3xSfkDncFB5Opvik/IHO+OdW8Jaf79Lz3gU/36XnuKxmcc8W3gki2i49okpzxmyk3Frg9BYSM6eGgpFV81MmjRRwrgXGuFKQjnKSQM3B0sALDW4z6hNxm3w2hpE19RWUtLDAhN6ePZRhOax4ZNrf4hlsd2S49JzmmGcVzMxwUdf5al+O+F9i+Or/LUvx3wvsXwbt4q+ve5Nz8VfXvVWCR1IooiZ0GIKXwNnr6R6b8vY7EpTtwrNwgkgDsuHiYL5Lj/Gv56nlkI24N+HlIA7Lj9z7HekZmYHGlKRMtQVdRABHJvcjjSEbZZB4ZAuOzW3wsMXHPIGI/ysvzS854OOeQMR/lZfml5zj/ANNZ/wAUdZ9IHGUp24Vm4QSQB2XDkcZCNuDfh5SAOy4/c5MkjMzA8OlraWtrJ0QrWJqUmOSOSJUagCdFAKAJSSk2ULpNjYmxeY6Wn4PHivtwtphtNmt/6eWSe17+NmNrX9BV7cHMF0zMwMzMDMzAzMwMzMDMzAzMwMzMDjjhiiXIuOJCFTKzyKSkArVYJueU2SBfkA5HIzDCqcGwqsroq6qwyjnq4LbKolgSqSOxuMqiLixNxbpeTHDFEuRccSEKmVnkUlIBWqwTc8pskC/IByORmBxxwxRLkXHEhCplZ5FJSAVqsE3PKbJAvyAcjkZgZmYRmGJU6JzEgyoSpCZCkZkpJBIB6ASlNx2DkcjMwMzMDMzAzMwMzMDMzAzMwMzMDwcc8gYj/Ky/NLzng455AxH+Vl+aXGrwy1wf8tPWPWGczM5MhmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmHHMzMDMzAzMwMzMD2wr75X4j8r1e2FffK/EflYXqvQ+h8/J+3T+cfI+gV6H0Pn5P26fzj5GHrMzChg4yKkwiurF06USU23MaM2kgjKhv8A/F5y8boacQJqpxFJMhKgmxNr8pA0+l4R4tCTi/UYZLPw5VzLTKgWy7RSlW//ACsXj4lxSFbXQ1QVFJlhREtExWEkJ3EZVDl6bsLxeI0kck0a50pVALrBvcaX+nQX0cOK4nzDAanE4UiUQwGZCToFaXDxcQwE1uJGsTMEXRlykf4t1/BuPpeVimGmvwGpwyNYjM0BiSoi4TcWYVNXxtVBg1PVopQqpkWEywFX3eoCj9BI77u6nE6OkqYqeol2ck2iLoNjrbfawdZWcV4J46tUMmSapCBdWqU2UCbDtsL+YOHF+LVTieLR1YrEiJE0UoQvNwchBIABtrbpB3sMyi4z4ZXTVMSFyINMtSVGSJSQQLXN7W6d29zoxzDZKNdWmpGxjUErUUKGUk2GhF9SQ8KbAaiZOJUvOIxR4gVLUMp2iVkAaG9raB49NxWXFhFRRFVOhc0sSytG0VmCFA65lHktowuKbEYqquVDFIhSRCJALKC/SUm9iLW4LzXXSYfOnFZ8Qp5IgtdImGNK0kgKClG5t0cJ5MQrdv8AmqgMXC0SkhXRl6fPf6GGQzMwOCrrKegpzPUyCOMaXsTr5g53hYtRrr6BUEaYVKJBG2CikeCQb/Swq8W4ywx09GKOoXGusn2SZFU6zlFjc2I83f7Hkx8ZsJQnZLr9pJHdC1CFfCUk2VYAcoO56QYFUIpqGOaqC1UtXzgnUi2VQyi5v09N3rR8XVU0tGtUsa+b1VROrg+kJCqw+jN9TC5gniqYUzQrC41i6VDpePXYrRYcpCaucRmT0RlJ+QaDtdfS1KeL1FBhstPW1Ko0k7SnpVrSbqJ3jpcdbQTY7kraRSqUqiXTyIqoFJVkJ1IB1B00LCwqscw2jnTDUVQQtaBIBlURlJsDcCwGhe9Ti9BSVCKeeoCJJPRGUnzXIFh9Lra7i0qqiqo0TpSJsNTRIKk3KSCrhfW4sS4q89xVFaFRL4CELRKZAODuIyqH13YdIzMwMzMDxa7EaTDY0yVcuzSo2TZJUSewAEvKdbjeHS4lTxohFPnQq+abPwfMUkEFhgYjxgSrEKCho6pUBqkqkMqqdSrJFrCxHTr5rPKj41YJMhK4626VAEHZL1B6d27tfkeCzpXQLkqtoqkgmjUpQ1WV2sfos8Wl4sKp6SCEzRqMWGKoicm9RtwvqYdClSVoC0kFKhcEdIdUnjLhxxaow1SpUzQWuTCrKbgnfbot0/Q9EYrHhcUVAujxCZVPGlBkhpFqQqyRqCA/YqOomxFeI06kxwVsSEzxTxqEgCQbW5DwjvYZ0eI0cpgEc6VGoF4wAdeDm+jTXV6U2L0FZVLpqeoC5Ub05SO8SLH6HhYVgCsOqEyrnEuUqI05bhPeTYfQ9MLwCahropZKhC4aZK0wJSmyrLNzmPTuYXrMzAzMwgrK2noIDPVSbOMG17E3PJYal0mLcZIkCghop1RqrptmmVVOs5AATfKRygD6bu0xeiXX0JgjTCVZgRtgrKO3gkG/0vBhwGoSjDNrViRVFUqmVcE3BQpOUX10zdN9zCRHGbCEoCFV2dabpURCvhEGxsLcoO52sM0dRCmaFYXGsXSobiHTUfF80q8PUqWNfNFzqVwfT2hJHeu/KSpTxeoKbDJaatqVwRgGSnpVrQfpDDIn4xUFPjQwmUyicoCgREop1NgLgdu/c8pGK0MiI1oqEkSrCEWBuSSQNOjUHvPBTDUVuIQYvRXgvHsZIquFSVZM1zYaEHzvWk4uilrjUGYKBlzhNtwHoj6CVH6WGejF6CSvNCmoBqBcFGU7+S9rX7HFj+Jy4PgtTiEVMqpVAgqyAgacpv0B4UXF6VGMJqlVCDTx1K6lCAnh51Aggnk4Redj1BUYpgtVQU0kcS6iMxlciSQAdDu6WGdGvaRIXa2ZIL2cNIiaOkiRUKQqVKQFGMEJJ7LuZgcVTUw0lOuoqFiOJAupR6HK8bEaZVZQS06UxKUsCwlBKd/TYgsIosZoJoEzomUI1ypiSVRqTdajYCxHa/ZMXoIklS6gACc054J+8Avl3cgdZHxeq04WaddYkzJqUVEWiiiMpIITqSbXHL0van4v1CY4ucVMUkicRNaspQQCCkjL9bDWgx4YnjNWIKpSaSiQCqM06gZAU3vci4sTu6bOyTjOHroVVoqRsEqylRSoEHkta9/oeJVYLPMcTVDV7JVauNSSAeDlSBY9ht0crw6TitPTYTLS85j2xrOdRqsopBAAAOYkkacrC3OM4emhFaqcpgUcoKo1Ak/htf6nk09RDVwIngWFxrF0qHS6fFsDqsaw2CKslgFRBLtAYwtMZ0IsbHNuPQXvBUR8XqKnoFUVRIUpJ/o6eSRAuonebm/nLDPrsUosNyCqmKDJfKkIUon6ACXX1OPw0eNxQzzZKSWjEqSY1E5iq2ulxpyvSvpZeMEEM1LEKcoKk5quKSORO70bEfXo96jAZKjOVVIUpWGmjzLTc5j/AI2F0lQWkKSbgi4PK/XhRw10CIoo5KcxxoQnhJVmNtFdPmt9LyYNsIEc4KDLlGcxghN+m1+hhI8esrqbD4NvVSbNF7XsSSeQAal5DwMYoZMQotjEmAqCwobYKsN+oykG/wBLCSLFKOYU5RKf6lSkxBSFJKiASdCNNAd7iXjmGohilNTwJgsx2QolQToqwAvo8IYFWopKHJWpVVUci1pXIklPCBBHLYA6av3DsAlo+qzLOiQ0KJgqyfSKyDcclrMI8Jx5Nca+vXVKFHTSKiEQp1XFjYK3XN+TodlJjOHxUUdYqpGxl0QoJUSrzAC/1OuqOL9TJQT08VYEKlrJKg7wFJUScpsQenoI3OOn4t1VHhdBDBUw85oZJFpUtJKFZ1E2IvfceVhHxpxKk/T06jKRzinWIgUEFV0notcfS/m773jnhEtbhaayeSPb0kEmYJzBBuLm2t+jp0fBPowtJZV6jMz2QGZmH6FoPJ1N8Un5A53BQeTqb4pPyBzvjnVvCWn+/S894FP9+l57iscc8MdTBJBKnNHKkoWm9rgixcjjnl2EEkuzXJs0lWSMXUqwvYDpLQqbW4oKehMU4nlqpqmRKShCpQgZQSCbZUjflG++7zuWmp0UsRjQVEGRcnC5VKKj9ZLw14nNSbTn9MhGSCScbCUyXSi2YapTY8IW+nd0zQVdRztNNV08US5I1SIMUpkBCSkG90pt6Qtv6d3TOYqQiaIng5qv8tS/HfC+xfHV/lqX474X2L4N28VfXvcm5+Kvr3sDBfJcf41/PU8s5NuL+nlNvNcX+B4mC+S4/wAa/nqeWSjbgEcPKbHsuP3Psd6RmZgcacm2Xb07DN5tbfC5HGko2ywBw7DMezW3wsNK6m57QVFLnybeJUea18twRe30uDY4v7dRfY1/3XnM6mLtKcSaYtw7GDscX9uovsa/7rjMOKbcXrqLPlNv6Ne64v8A+p5nZOMlG3AI4eU2PZcfudZV7WeUdkMXY4v7dRfY1/3W2OL+3UX2Nf8AdeczZTazyjshg7HF/bqL7Gv+68WPCsSjxWoxEYhS7WogigUk0isoTGqRQI/M33kVfzD6bhmym1nlHZDB2OL+3UX2Nf8AdbY4v7dRfY1/3XnM2U2s8o7IYOxxf26i+xr/ALrbHF/bqL7Gv+685mym1nlHZDB2OL+3UX2Nf91tji/t1F9jX/deczZTazyjshg7HF/bqL7Gv+62xxf26i+xr/uvOZsptZ5R2Qwdji/t1F9jX/dbY4v7dRfY1/3XnM2U2s8o7IYOxxf26i+xr/utscX9uovsa/7rzmbKbWeUdkMHY4v7dRfY1/3W2OL+3UX2Nf8AdeczZTazyjshg7HF/bqL7Gv+62xxf26i+xr/ALrzmbKbWeUdkMHY4v7dRfY1/wB1tji/t1F9jX/deczZTazyjshg7HF/bqL7Gv8AutscX9uovsa/7rzmbKbWeUdkMHY4v7dRfY1/3W2OL+3UX2Nf915zNlNrPKOyGDscX9uovsa/7rbHF/bqL7Gv+685mym1nlHZDB2OL+3UX2Nf91tji/t1F9jX/deczZTazyjshg7HF/bqL7Gv+62xxf26i+xr/uvOZsptZ5R2Qwdji/t1F9jX/dbY4v7dRfY1/wB15zNlNrPKOyGDscX9uovsa/7rbHF/bqL7Gv8AuvOZsptZ5R2Qwdji/t1F9jX/AHW2OL+3UX2Nf915zNlNrPKOyGDscX9uovsa/wC62xxf26i+xr/uvOZsptZ5R2Qwdji/t1F9jX/dbY4v7dRfY1/3XnM2U2s8o7IYOxxf26i+xr/utscX9uovsa/7rzmbKbWeUdkMHY4v7dRfY1/3XDVUOKVlHNSyV9IETRqjUU0irgEWNvzHaM2WFxjVRN4iOyBmZyYjMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMOOZmYGZmBmZgZmYHthX3yvxH5Xq9sK++V+I/KwvVeh9D5+T9un84+R9Ar0PofPyft0/nHyMPWZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYUXGnyBXfy8nzS/lr+pcafIFd/LyfNL+WvowtJZV6jMz2QGZmH6FoPJ1N8Un5A53BQeTqb4pPyBzvjnVvCWn+/S894FP8Afpee4rHHOuSOCRcUW1kSklEebLnNtBfovyuRmFOiSXb1U2GwTLUuBajzqNafzQbxpBXY5TdWgNhYejc39wtCIqvLSIqNhsbSqqIVIIUCMgTmA0sV8FPBFhYJvrbs55uDOMPjE3cdX+WpfjvhfYvjq/y1L8d8L7F8G7eKvr3uTc/FX172BgvkuP8AGv56nllSNuE24ZSSD2XDxMF8lx/jX89TyysbcIy8IpJv9IfY70jMzA40qQZlpA4QAueUa2+FyONKwZloCdQASeW92EjMzA4ypG3CbcMpJB7LhyOMrG3CMvCKSb/SGEjMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMOOZmYGZmBmZgZmYHthX3yvxH5Xq9sK++V+I/KwvVeh9D5+T9un84+R9Ar0PofPyft0/nHyMPWZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYUXGnyBXfy8nzS/lr+pcafIFd/LyfNL+WvowtJZV6jMz2QGZmH6FoPJ1N8Un5A53BQeTqb4pPyBzvjnVvCWn+/S894FP9+l57iscc8W3gki2i49okpzxmyk3Frg9BcjjnhjqYJIJU5o5UlC03tcEWLQqdFLLSZJKyLDqVNBLzSVMccYTGZ1H0Vgp04JGlzcZ9QnTNNQyU8eLRwUNKump5IJFrSYDElS0qQAQkgG4Cjc21uNTbTNp6ExTieWqmqZEpKEKlCBlBIJtlSN+Ub77vO9qeiRTyGQyyzLtlQqVWYoT4oPeuTcmwuTYPSaosxjDm8T8+dHL1/lqX474X2L46v8tS/HfC+xfn7t4q+ve59z8VfXvYGC+S4/xr+ep5hXaYR5d6Sb/SPW63BKymVRxwCdBlKl2Rm19In5HZFatsEZeCUk37dH2O9uzMwPRK7zLRltlAN+W9/U93olajKtBToACDy3uw3ZmYHoV2mEeXekm/0j1vd6FatsEZeCUk37dGG7MzA/ngwKKo471uTAaFVKvGbT1iIxziO9ClehCLxjaFKtolYVnPbc/Q3z8vFJM82IbTGsRVTYnKV1dJaARyAoSgovs84TkSlOigbC976sOP4wwxUKeOiDEhdFiSp4jTlIKY6lFCioRKlO4E2lKlakqEXIS7CfBsKwqg45Ylh2GUdHWYZKuWjnggShcBTRwrASQNE5iSU7lZlAggkHoKzidRYlQ41RV9XWVNPjMollQpSE7FSQkJKClIOgRH6Wb0Be91X3HFaNVbWzT4pXT01fPtqmiXsRDIcqUhJtGF5QlCRlzWUBZWYFVwr4eLuFcbMPxOoxijhqKiqqaqmTMqJKl0yI1qhSIlKBKNEZ+TOpR6bPFmhwSopZMfx6FaqnrkxwVEVIqeSAwVOzijRlSpSUqMQuNxVIu1ioB9BUcXaeprZ5lVNSmmq1BdXRAo2NSoJCbrunPbKhAKQoJITYggqun4u08+IrqjU1KYpZ46makSUbKWaPLkWSU5wRs49EqAOQXBuq4W7MzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMw45ng9b03JJ3m63puSTvMM5ng9b03JJ3m63puSTvMM5ng9b03JJ3m63puSTvMM5ng9b03JJ3m63puSTvMM57YV98r8R+V1/W9NySd55+DqC1lY3KNwwvleh9D5+T9un84+R9Ar0PofPyft0/nHyMPWZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYUXGnyBXfy8nzS/lr+pcafIFd/LyfNL+WvowtJZV6jMz2QGZmH6FoPJ1N8Un5A53BQeTqb4pPyBzvjnVvCWn+/S894FP9+l57isZnHOiSSCREUuykUkhEmXNkNtDbptyMMNGLwKqa+NSVIioY0rXMdQr0s1rb7ZSD2gjoctPVyLnEFTBsJFpMkac+a6QQDe25QuLjUaixOtqJNLVrnrMOQtIjXRClQeYzIRwRIAM5JAtca63uLau4hK6vE4qkQyxIghkjWJU5TmUUGw5bZDcjTUWJ1trVTEOeiuqdfnH8HPV/lqX474X2L46v8tS/HfC+xfnbt4q+vew3PxV9e9hYR5OT8ZJ89Tyipe2CbcApJJ7dHi4R5OT8ZJ89TyiV7YADgZTc9ulvhfY727MzA9EqWZVpI4IAseU63+B7vRJXtVgjgWGXz63+BhuzMwOooKiqRxjxLDpqldRFHBDVRqkSkKj2i5klAygXSBEm17q1NydLW7oqCaKu444lPTyomipqSGnMkSgUiXaTGSNRG9SQI+Cq5RmNrZzcL1mZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmHyVmZgZmYGZmBmZgfT4F6CfM+YfT4F6CfMw6FXofQ+fk/bp/OPkfQK9D6Hz8n7dP5x8jD1mZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmFFxp8gV38vJ80v5a/qXGnyBXfy8nzS/lr6MLSWVeozM9kBmZh+haDydTfFJ+QOdwUHk6m+KT8gc7451bwlp/v0vPeBT/fpee4rGZxzzR00Ek8qsscSStarXsALlhIzoMGroJ8ZqVqrYVz1UEKtkmdKwgjaXQmxN7CxNukk6Xs83CYUwT4jEgrKU1QsVrUs/dR9KiSXOabMqcTNa3uoK/y1L8d8L7F8dX+WpfjvhfYvg3bxV9e9y7n4q+verMIiqU06SqoQYhJICjZWJ4Sum/Lrudgc+2FvQym/n0t8LxsL/Yv/qyfPU8khe2BvwMpBHbp+99jvbszMDwqPEYaysqoI1rCqYhK45IlRqGqhmAUASk2NlC6TlNibF5rpafg8eK+3C2mG02a3/p5ZJ7Xv42Y2tf0FXtwcwXTMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMw4fmdN3BHgtzOm7gjwXOzCDmdN3BHgtzOm7gjwXOzCDmdN3BHgtzOm7gjwXOzCDmdN3BHgtzOm7gjwXOzCDmdN3BHgvIwkBMqgBYAmwfj2wr75X4j8rC9V6H0Pn5P26fzj5H0CvQ+h8/J+3T+cfIw9ZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZhRcafIFd/LyfNL+Wv6lxp8gV38vJ80v5a+jC0llXqMzPZAZmYfoWg8nU3xSfkDncFB5Opvik/IHO+OdW8Jaf79Lz3gU/36XnuKxmZhhx4eqPEF1nPahRWAlUagjLlGYgaJvpmPTflu1Hh6qSeaU1tROZjmWmQIsVWAvwUjoSByOE4zCJcRBiWY6CISKWLHaelcJ82UjfvuOhzQVdRztNNV08US5I1SIMUpkBCSkG90pt6Qtv6d3TOczKJovw/FzVf5al+O+F9i+Or/AC1L8d8L7F8G7eKvr3uXc/FX172Hhf7F/wDVk+ep5JSrbBWbghJBHbo8bC/2L/6snz1PJKCZgvNoEkW73qfY727MzA6+iw2WDFa3EamoRLLUpRChMcRQlESFLUgG6jdV5FXVoDpZIsb2D5hfGbFU4rUUYwijWiGuNIi1eraznYifgpMWUK2Z3KWkZgRm3Eh07M6vriQcZkYMrD5o0LppJ0VS1oySZDECEpBKv/V1Kgndpe9wFozq+uJBxmRgysPmjQumknRVLWjJJkMQISkEq/8AV1Kgndpe9xgfqXEI8RrEVGF0yaKkxCKhVNHWKVKVS7PZqEZjAt+ci/C04Vs1hcOjZmYGeFh+JoxCauhTBNCuhqTTyCXLwjkSsKTlJ4JStJF7HlAeawM6us62kqlopfyYTkiQvgG1zeSTW+5ICUC3pE5klNiIDjlZFPiC56CBNFh8pRNMipKlhORK84RkAICVgkZr6G2Y2vV2kYczou2eLt6vrXm/Mv6PYZ+dbUfeZrZMm/drfd0PWtxKOiliiMM88kiVLyQpzFKE2Cl2vqBmToLqN9AWujlmZtDMZ4dbiUdFLFEYZ55JEqXkhTmKUJsFLtfUDMnQXUb6AvMdqmJiLjMzKGdXWdbSVS0Uv5MJyRIXwDa5vJJrfckBKBb0icySmxFo6ulNNojiMzO0RmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZhxzMzAzMwMzMDMzA9sK++V+I/K9XthX3yvxH5WF6r0PofPyft0/nHyPoFeh9D5+T9un84+Rh6zMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzCi40+QK7+Xk+aX8tf1LjT5Arv5eT5pfy19GFpLKvUZmeyAzMw/QtB5Opvik/IHO4KDydTfFJ+QOd8c6t4S0/wB+l57wKf79Lz3FY450SSQSIil2UikkIky5shtobdNuRyMw5yiXUUGJTJKVyQQ0qI0piw+UZxHtOClSlEX1GpJCrgDldhh9Qmoq88kVQahUZJWqnWiOJNxwElYF7777zlubAACzZzmq/kypw5p83HV/lqX474X2L46v8tS/HfC+xfBu3ir697l3PxV9e9h4X+xf/Vk+ep5BQDOF5tQki30j1PGo6SqpbIVVRyRhSlFIhsSSSd+blL9pa2lraydEK1ialJjkjkiVGoAnRQCgCUkpNlC6TY2JsX2O9mMzMD5LCsIoK/jfiuKy0M0VZR4kJIKmSkVGZUc1TCUhak8NGbaGyTa4SdxF+tZhwXGaGoRxjTXR4ZUiWmq6VaZ6ahXPMqALjEihNrkjsZEmCMZyQVngrXe6ra9COPWHg01cpMVJUQLlRQzKiC5F05QM4RltZCrm9hY3IfRsw5ytr0I49YeDTVykxUlRAuVFDMqILkXTlAzhGW1kKub2Fjch0s1NDU4xxgXS4TUpx2arAw2vVh0iNmU08SAvblASIwtK7i5CkhQAXmAV3rMOC4zQ1COMaa6PDKkS01XSrTPTUK55lQBcYkUJtckdjIkwRjOSCs8Fa72eKUtKcXql41hVTiSpFJ6rXBTqkMKciQUpWnSCTaZlbQlGikcPgcDqmYfPK2JE3GLE6nFMLqcRwlGKIIolYTNIVLNPHFzgHKRIlGSROW1rEquo7MH6GzMD5aoWurRxiwyKlq9viEqo4FLpZExkGCOMqKynLlBSrpuQNAbgHqWdTF2lFeTy+RN3PzKpYOOcE8dDOmRdNJDPUR0MhC1KVDkzSBNiLJVrewsb2cdbT4arjnSTyYUqSRMSwuoGHrUNqVQ7MmQItcAK4V+DrqH0jOsqUYtuy2rm62nw1XHOknkwpUkiYlhdQMPWobUqh2ZMgRa4AVwr8HXUPFxinTBh3GTD04XPOuvUuenjhpStCyYUDNmAyhQWlSrE5iRcAki/XM6ypRjzEx7W858pu4zGKenxCuqlnDVVipUpyRVmEyqUsGNNkRz6CFJvbhC6VlZLY1h9TPiuIZ407WZSeZTdVyVEsY2aQDHMFBMRCwogKIsbqOhu+zZsi43iYtaNBmZzcwzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMOOZmYGZmBmZgZmYHthX3yvxH5Xq/cK+/V+I/Kwvleh9D5+T9un84+R9Ar0PofPyft0/nHyMPWZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYUXGnyBXfy8nzS/lr+pcafIFd/LyfNL+WvowtJZV6jMz2QGZmH6FoPJ1N8Un5A53BQeTqb4pPyBzvjnVvCWn+/S894FP9+l57iscc80dNBJPKrLHEkrWq17AC5cjMOcw2pgrcSrUqxFAnrqWLgw1CSYj+ZdKCCdUixJHSSdL2edR08EGLKTBSIoUpiUNmlCU844Q4fB0ITbTpGfUJuM0q8JTLUzyzVdRKioj2UkKsgSUcKydEhWmc63v2ly09CYpxPLVTVMiUlCFShAygkE2ypG/KN993nes1R5OemiqLXjzczX+WpfjvhfYvjq/wAtS/HfC+xfnbt4q+vew3PxV9e8dLT8HjxX24W0w2mzW/8ATyyT2vfxsxta/oKvbg5rp19FhssGK1uI1NQiWWpSiFCY4ihKIkKWpAN1G6ryKurQHSyRY37HesGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmHHMzMDMzAzMwMzMD9wr79X4j8r8bCyBOq/jFhfq9D6Hz6/22fzj5HfqI2f0Pn1EGtntyj5GGzMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMDMzAzMwMzMKLjT5Arv5eT5pfy1/UuNPkCu/l5Pml/LX0YWksq9RmZ7IDMzD9C0Hk6m+KT8gc7goPJ1N8Un5A53xzq3hLT/fpee8Cn+/S89xWMzjnRJJBIiKXZSKSQiTLmyG2ht025GGPTYiiqxCrpERqtTBH5hOiycwNvMUkHtBHQ1NiKKrEKukRGq1MEfmE6LJzA28xSQe0EdDqKKOsixKakim2SRSop45Bh8oSko2lrKUojS4NySFXADkwxNRTYyqnKvyEQRwpIoZUJIRtNAtSiBa41JINxZ6zTHFzRiVcL81bX+WpfjvhfYvjq/y1L8d8L7F+du3ir697Hc/FX17xmZ9jvGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmBmZgZmYGZmHHMzMDMzAzMwMzMDgjRNCdvGMySTcDzud+Gqgo8OM9TKmKJJN1qNgNWG0mKymPKmNV+14dNKkSSmWRIUSDqbPGTj2E1k4hpsQglkVuSldyXa4TGhe3zoSqyhvF+hhFt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EPckeCGFTt4e6o8INt4e6o8IO22EPckeCG2EI3xR+CGFTt4e6o8INt4e6o8IO12VP4kfeD82VP4kfeDDj+NE0RwGuAkQTzeTcoeKX8wf1/jfHCOLmIFKIwebSWsB4pfyB9GFpLKvUZmeyAzMw/Q2FQSzYXTLEiEjZgAFBO7TleXzObuyPdn1uuQiZfE083rJqSVMClJlhCCoWuf8AEkjXzd51nO6qqwHilRLqp0jFNmmpmRKpMqwIFSEZwcwJKRcg3tfV8c6zHzz7m/k6ZFLOhYUJo7jljPrctqrusPuz/wAnxKqurTjJ4sCtquaHFRDtecL24iNMZ8m1vn9IWve9tLu94uSyx12MYWqaWaGgqUpgVNIqRYSuNK8pUokqsVGxJJs6ibrmLLm1V3WH3Z/5Naq7rD7s/wDJ8TDX4rh+LrqZkYhJOJqlFRHLtRTyAry0yYs35dzdAujW2Yqdxxax2KoMVBImsVNKmWVFVPbZ1JSu0hj4RKUhShYKA0ta4aJuTwX1qrusPuz/AMmtVd1h92f+TlZriolwHbVSqhVTZalZiAjS/feaameOZUazGqyQQQkjfft7HSV/GXGaPjPBg0XFzbx1GsdWKohGUekTwDYjkv0jldvUftivi0/Kpxpopp0jVnTRTTM5Y1S87k5E95udycie88GqmXEkZRv/AMT2pTenST2/K52aMzncnInvNzuTkT3nAzoT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYT87k5E95udycie84GYULPB6zHsy/DDdZj2Zfhh0M5ng9Zj2Zfhhusx7MvwwwzmeD1mPZl+GG6zHsy/DDDOZ4PWY9mX4YbrMezL8MMM57RxomoTHIkKQvMFJPSCS6/rMezL8MMjFlojy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\n","permalink":"https://EitanWong.github.io/en/posts/shader/cg%E8%AF%AD%E8%A8%80-profile%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"Profile 一个 Cg Profile定义了一个“被特定图形硬件或API所支持的Cg语言子集” 任意一种shader language都是基于可编程图形硬件的寄存器、指令集等 这也就意味着：不同的图形硬件对应着不同的功能子集。这些可选的语言功能包括某些控制结构和标准函数库。 profile还定义了数据类","title":"CG语言- Profile和基本数据类型"},{"content":" 和编写表面着色器不一样，在编写基于顶点和片元着色器当中，需要在SubShader中写上Pass通道，（至少要有一个Pass通道）\nSubShader { pass { } } 在ShaderLab中作为CG语言处理 在Pass通道中使用CGPROGRAM 和ENDCG 包裹住编写的CG代码片段 Shader \u0026#34;Leaning/CGPROGRAM/cg1\u0026#34; { SubShader { pass { CGPROGRAM //编写的代码 ENDCG } } } 💡 c语言的入口函数是main 顶点和片元程序也有入口函数\n定义顶点和片元的入口函数 #pragma vertex vert//声明顶点处理函数 名为vert #pragma fragment frag//声明片元处理函数 名为 frag 💡 在顶点片元着色器中，顶点函数和片元函数都必须编写 所以在CGPROGRAM中需要写上具体的函数\n//顶点处理程序 void vert() { } //片元处理程序 void frag() { } 但是光这样编写是不正确的\n顶点程序会对顶点做一系列的处理，包括几何变换，变换过后要把需要的数据，传入几何片元，所以顶点程序必须要对数据进行处理，然后输出\n片元程序拿到顶点传入的程序继续进行计算\n语义 顶点程序必须要处理顶点，就需要传入顶点数据\n//顶点处理程序 void vert(in float2 objPos:POSITION) { } 💡 所以在顶点处理程序中，填入变量in float2 objPos:POSITION\nin是输入数据 float2是个浮点值，带有2阶向量的浮点值 POSITION则是语义，代表顶点坐标位置\n在顶点程序中写上输出参数out float4 pos:POSITION 💡 顶点程序必须包含带有语义为POSITION的参数\nvoid vert(in float2 objPos:POSITION,out float4 pos:POSITION) { } 在顶点处理程序中修改输出的Pos pos=float4(objPos,0,1);\n//顶点处理程序 void vert(in float2 objPos:POSITION,out float4 pos:POSITION) { pos=float4(objPos,0,1); } 💡 利用float4将类型为float2的objPos与0和1组成一个4阶的向量\n在片元处理程序，也要做类似的修改 片元处理程序，必须要至少包含一个语义为COLOR0或者是COLOR的参数 COLOR0和COLOR是等价的，所以二者选一个即可\nvoid frag(out float4 col:COLOR) { } 为输出的COLOR附上红颜色的值 void frag(out float4 col:COLOR) { col=float4(1,0,0,1); } 在顶点处理程序当中也可以对COLOR进行处理 💡 在顶点处理程序中添加out float4 col:COLOR 对COLOR进行处理 在片元处理程序当中，将out改为inout，表示COLOR直接输入和输出 在frag片元处理程序当中也可以，继续进行COLOR颜色的处理，片元程序的计算会在顶点程序计算之后， 所以如果下段代码注释去掉，最终使用的颜色会是float4(1,0,0,1)\nShader \u0026#34;Leaning/CGPROGRAM/cg1\u0026#34; { SubShader { pass { CGPROGRAM #pragma vertex vert #pragma fragment frag //顶点处理程序 void vert(in float2 objPos:POSITION,out float4 pos:POSITION,out float4 col:COLOR) { pos=float4(objPos,0,1); col=float4(0,0,1,1); } //片元处理程序 void frag(inout float4 col:COLOR) { // col=float4(1,0,0,1); } ENDCG } } } 在计算机图形硬件当中需要对3D物体进行显示的时候，需要进行一系列的坐标系的转换 坐标系 💡 物体的坐标系是没有参考价值的，它只是在自己建模的坐标系当中 最终它要被放在世界当中，它与其他物体会有相对位置，同时它还被摄像机去拍摄 摆在不同的位置，摄像机取景的结果会不一样 💡 通过一系列的变换，会得到一个CVV的裁剪立方体 pos=float4(objPos,0,1); objPos在物体坐标系当中顶点x,y 最大可能是x=0.5，y=0.5 最小可能是x=-0.5，y=-0.5 当与后面的0和1组合过后，在CVV裁剪立方体后，得到的就是-0.5到+0.5 col=pos; 让顶点数据直接等于pos，应为数据类型都是float4，所以可以直接赋值 (x,y,z,w)对应的颜色分量即为(r,g,b,a),可以呈现如下图所示的效果\n","permalink":"https://EitanWong.github.io/en/posts/shader/cg%E8%AF%AD%E8%A8%80-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E8%AF%AD%E4%B9%89/","summary":"和编写表面着色器不一样，在编写基于顶点和片元着色器当中，需要在SubShader中写上Pass通道，（至少要有一个Pass通道） SubShader { pass { } } 在ShaderLab中作为CG语言处理 在Pass通道中使用CGPROGRAM 和ENDCG 包裹住编写的CG代码片段 Shader \u0026#34;Leaning/CGPROGRAM/cg1\u0026#34; { SubShader { pass { CGPROGRAM //编写的代","title":"CG语言-输入输出和语义"},{"content":" 完整案例代码 Shader \u0026#34;Learning/2.SurfaceShader/SurfaceShader1\u0026#34; { Properties { _Color (\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _MainTex (\u0026#34;Albedo (RGB)\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Glossiness (\u0026#34;Smoothness\u0026#34;, Range(0,1)) = 0.5 _Metallic (\u0026#34;Metallic\u0026#34;, Range(0,1)) = 0.0 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; } LOD 200 CGPROGRAM // Physically based Standard lighting model, and enable shadows on all light types #pragma surface surf Standard fullforwardshadows // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D _MainTex; struct Input { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; // Add instancing support for this shader. You need to check \u0026#39;Enable Instancing\u0026#39; on materials that use the shader. // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. // #pragma instancing_options assumeuniformscaling UNITY_INSTANCING_BUFFER_START(Props) // put more per-instance properties here UNITY_INSTANCING_BUFFER_END(Props) void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = c.a; } ENDCG } FallBack \u0026#34;Diffuse\u0026#34; } SubShader 💡 SurfaceShader是对Vertex与FragmentShader的一种包装 SubShader中没有Pass通道，如果一旦添加了Pass通道则会报错\nTags Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; }//渲染类型，Opaque表示这个渲染的是一个不透明的物体 CGPROGRAM是一个CG语言的代码块，一般以CGPROGRAM开头，ENDCG结尾\n#pragma 编译指令 💡 标准格式如下\n#pragma surface surfaceFunction lightModel [optionalparams] surface 表示声明这是一个surfaceShader，让Unity进行编译处理 surface Function 是声明表面着色器的处理方法（默认是surf）和下方生成的surf方法名称要一致 lightModel 声明光照模型，在默认创建的表面着色器当中使用的是Standard，（这里的光照模型实际上也是一个函数，可以在Unity编辑器路径中的DataCGIncludes文件夹中找到） （在自己编写光照函数的时候前面必须加上“Lighting”否则ShaderLab无法识别） optionalParams其他的选项参数 默认的fullforwardshadows，是生成支持前向渲染路径的阴影 默认的Shader在前向渲染中只支持一个directional light生成阴影 如果需要在前向渲染中支持PointLight或者SpotLight的阴影，需要使用directive #pragma target 3.0 💡 说明将使用硬件的Shader Model 3.0 版本越高Shader的功能越多 如果没有指定默认使用的是ShaderModel2.0 (使用ShaderModel3.0可以获得一个更好看的光照效果) 💡 sampler2D _MainTex;是对 _MainTex属性的一个变量声明 💡 这是一个结构体 用于对UV纹理坐标的输入 *编写的着色器uv纹理采样变量声明一定要以uv或者uv2开头，(否则)ShaderLab将无法识别处理\nstruct Input { float2 uv_MainTex; }; 如果声明了一个_MainTex (\u0026quot;Albedo (RGB)\u0026quot;, 2D) = \u0026quot;white\u0026quot; {}的纹理采样属性 那么结构体中命名uv纹理采样的变量名必须以uv开头，并且uv后面的名称要和属性名一样 例如：uv_MainTex\nhalf _Glossiness; half _Metallic; fixed4 _Color; 💡 对其他三个属性的变量声明，光泽度，金属度，颜色\n在CG程序中，需要对Shader中所有的Proprieties的属性，都进行变量的声明 Properties中的类型与CG当中的类型不是对应的 常用的对应类型可以查看下方表格\nProprieties\nCG\n2D\nsampler2D\nColor\nfixed4\nRange\nhalf\nInput表面着色器输入结构 输入结构 Input 通常具有着色器所需的所有纹理坐标。纹理坐标必须命名为“uv”后跟纹理名称的形式（如果要使用第二个纹理坐标集，则以“uv2”开头）。 可以放入输入结构的其他值：\nfloat3 viewDir - 包含视图方向，用于计算视差效果、边缘光照等等。 具有 COLOR 语义的 float4 - 包含插值的每顶点颜色。 float4 screenPos - 包含反射或屏幕空间效果的屏幕空间位置。请注意，这不适合 ；您需要使用 ComputeGrabScreenPos 函数自己计算自定义 UV。 float3 worldPos - 包含世界空间位置。 float3 worldRefl - 在_表面着色器不写入 o.Normal_ 的情况下，包含世界反射矢量。有关示例，请参阅反光漫射 (Reflect-Diffuse) 着色器。 float3 worldNormal - 在_表面着色器不写入 o.Normal_ 的情况下，包含世界法线矢量。 float3 worldRefl; INTERNAL_DATA - 在_表面着色器写入 o.Normal_ 的情况下，包含世界反射矢量。要获得基于每像素法线贴图的反射矢量，请使用 WorldReflectionVector (IN, o.Normal)。有关示例，请参阅反光凹凸 (Reflect-Bumped) 着色器。 float3 worldNormal; INTERNAL_DATA - 在_表面着色器写入 o.Normal_ 的情况下，包含世界法线矢量。要获得基于每像素法线贴图的法线矢量，请使用 WorldNormalVector (IN, o.Normal)。 surf函数 void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = c.a; } 参数中的inout 表示既是输入也是输出，也就是定义了后面的SurfaceOutputStandard结构是输入结构又是输出结构\n可以定义一个“表面函数”，它将您需要的所有 UV 或数据作为输入，并填充输出结构 SurfaceOutput。SurfaceOutput 基本上描述了_表面的属性_（反照率颜色、法线、发光、镜面反射等）。您需要使用 HLSL 编写此代码。 表面着色器编译器随后计算出需要的输入、填充的输出等等，并生成实际的 以及渲染通道来处理前向和延迟渲染。 以下是表面着色器的标准输出结构 (不是基于PBR的效果会差一点，但是性能会好一点，Unity5之前的版本使用)\nstruct SurfaceOutput { fixed3 Albedo; // 漫射颜色 fixed3 Normal; // 切线空间法线（如果已写入） fixed3 Emission; half Specular; // 0..1 范围内的镜面反射能力 fixed Gloss; // 镜面反射强度 fixed Alpha; // 透明度 Alpha }; 在 Unity 5 中，表面着色器还可以使用基于物理的光照模型。内置标准光照模型和标准镜面反射光照模型（见下文）分别使用以下输出结构：\nstruct SurfaceOutputStandard { fixed3 Albedo; // 基础（漫射或镜面反射）颜色 fixed3 Normal; // 切线空间法线（如果已写入） half3 Emission; half Metallic; // 0=非金属，1=金属 half Smoothness; // 0=粗糙，1=平滑 half Occlusion; // 遮挡（默认为 1） fixed Alpha; // 透明度 Alpha }; struct SurfaceOutputStandardSpecular { fixed3 Albedo; // 漫射颜色 fixed3 Specular; // 镜面反射颜色 fixed3 Normal; // 切线空间法线（如果已写入） half3 Emission; half Smoothness; // 0=粗糙，1=平滑 half Occlusion; // 遮挡（默认为 1） fixed Alpha; // 透明度 Alpha }; 从纹理当中采样颜色，使用Cg当中的tex2D方法，需要传入纹理和nv坐标，最后的*_Color是叠加的颜色 fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color; 颜色取rgb值赋给输出结构体中的Albedo基础颜色变量 o.Albedo = c.rgb; 其他的属性也同样对结构体中的变量进行赋值，输出结构体中的Alphao.Alpha赋值为采样出来的纹理颜色c的Alpha值c.a o.Metallic = _Metallic; o.Smoothness = _Glossiness; o.Alpha = c.a; Unity内置的光照模型 💡 Unity内置的光照模型在CGIncludes文件夹内的Lighting.cginc Unity内置的光照模型CG代码 ``` #ifndef LIGHTING_INCLUDED #define LIGHTING_INCLUDED #include \u0026ldquo;UnityLightingCommon.cginc\u0026rdquo; #include \u0026ldquo;UnityGBuffer.cginc\u0026rdquo; #include \u0026ldquo;UnityGlobalIllumination.cginc\u0026rdquo; struct SurfaceOutput { fixed3 Albedo; fixed3 Normal; fixed3 Emission; half Specular; fixed Gloss; fixed Alpha; }; #ifndef USING_DIRECTIONAL_LIGHT #if defined (DIRECTIONAL_COOKIE) defined (DIRECTIONAL) #define USING_DIRECTIONAL_LIGHT #endif #endif #if defined(UNITY_SHOULD_SAMPLE_SH) defined(LIGHTMAP_ON) defined(DYNAMICLIGHTMAP_ON) #define UNITY_LIGHT_FUNCTION_APPLY_INDIRECT #endif inline fixed4 UnityLambertLight (SurfaceOutput s, UnityLight light) { fixed diff = max (0, dot (s.Normal, light.dir)); fixed4 c; c.rgb = s.Albedo * light.color * diff; c.a = s.Alpha; return c; } inline fixed4 LightingLambert (SurfaceOutput s, UnityGI gi) { fixed4 c; c = UnityLambertLight (s, gi.light); #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT c.rgb += s.Albedo * gi.indirect.diffuse; #endif return c; } inline half4 LightingLambert_Deferred (SurfaceOutput s, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2) { UnityStandardData data; data.diffuseColor = s.Albedo; data.occlusion = 1; data.specularColor = 0; data.smoothness = 0; data.normalWorld = s.Normal; UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2); half4 emission = half4(s.Emission, 1); #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT emission.rgb += s.Albedo * gi.indirect.diffuse; #endif return emission; } inline void LightingLambert_GI ( SurfaceOutput s, UnityGIInput data, inout UnityGI gi) { gi = UnityGlobalIllumination (data, 1.0, s.Normal); } inline fixed4 LightingLambert_PrePass (SurfaceOutput s, half4 light) { fixed4 c; c.rgb = s.Albedo * light.rgb; c.a = s.Alpha; return c; } // NOTE: some intricacy in shader compiler on some GLES2.0 platforms (iOS) needs \u0026lsquo;viewDir\u0026rsquo; \u0026amp; \u0026lsquo;h\u0026rsquo; // to be mediump instead of lowp, otherwise specular highlight becomes too bright. inline fixed4 UnityBlinnPhongLight (SurfaceOutput s, half3 viewDir, UnityLight light) { half3 h = normalize (light.dir + viewDir); fixed diff = max (0, dot (s.Normal, light.dir)); float nh = max (0, dot (s.Normal, h)); float spec = pow (nh, s.Specular*128.0) * s.Gloss; fixed4 c; c.rgb = s.Albedo * light.color * diff + light.color * _SpecColor.rgb * spec; c.a = s.Alpha; return c; } inline fixed4 LightingBlinnPhong (SurfaceOutput s, half3 viewDir, UnityGI gi) { fixed4 c; c = UnityBlinnPhongLight (s, viewDir, gi.light); #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT c.rgb += s.Albedo * gi.indirect.diffuse; #endif return c; } inline half4 LightingBlinnPhong_Deferred (SurfaceOutput s, half3 viewDir, UnityGI gi, out half4 outGBuffer0, out half4 outGBuffer1, out half4 outGBuffer2) { UnityStandardData data; data.diffuseColor = s.Albedo; data.occlusion = 1; // PI factor come from StandardBDRF (UnityStandardBRDF.cginc:351 for explanation) data.specularColor = _SpecColor.rgb * s.Gloss * (1/UNITY_PI); data.smoothness = s.Specular; data.normalWorld = s.Normal; UnityStandardDataToGbuffer(data, outGBuffer0, outGBuffer1, outGBuffer2); half4 emission = half4(s.Emission, 1); #ifdef UNITY_LIGHT_FUNCTION_APPLY_INDIRECT emission.rgb += s.Albedo * gi.indirect.diffuse; #endif return emission; } inline void LightingBlinnPhong_GI ( SurfaceOutput s, UnityGIInput data, inout UnityGI gi) { gi = UnityGlobalIllumination (data, 1.0, s.Normal); } inline fixed4 LightingBlinnPhong_PrePass (SurfaceOutput s, half4 light) { fixed spec = light.a * s.Gloss; fixed4 c; c.rgb = (s.Albedo * light.rgb + light.rgb * _SpecColor.rgb * spec); c.a = s.Alpha; return c; } #ifdef UNITY_CAN_COMPILE_TESSELLATION struct UnityTessellationFactors { float edge[3] : SV_TessFactor; float inside : SV_InsideTessFactor; }; #endif // UNITY_CAN_COMPILE_TESSELLATION // Deprecated, kept around for existing user shaders. #define UNITY_DIRBASIS const half3x3 unity_DirBasis = half3x3( half3( 0.81649658, 0.0, 0.57735027), half3(-0.40824830, 0.70710678, 0.57735027), half3(-0.40824830, -0.70710678, 0.57735027) ); // Deprecated, kept around for existing user shaders. Only sampling the flat lightmap now. half3 DirLightmapDiffuse(in half3x3 dirBasis, fixed4 color, fixed4 scale, half3 normal, bool surfFuncWritesNormal, out half3 scalePerBasisVector) { scalePerBasisVector = 1; return DecodeLightmap (color); } #endif ```\nlightModel - 要使用的光照模型。 内置光照模型是基于物理的 Standard 和 StandardSpecular，以及简单的非基于物理的 Lambert（漫射）和 BlinnPhong（镜面反射）。请参阅 页面以了解如何编写自己的光照模型。 Standard 光照模型使用 SurfaceOutputStandard 输出结构，并与 Unity 中的标准（金属性工作流）着色器匹配。 StandardSpecular 光照模型使用 SurfaceOutputStandardSpecular 输出结构，并与 Unity 中的标准（镜面反射设置）着色器匹配。 Lambert 和 BlinnPhong 光照模型不是基于物理的（来自 Unity 4.x），但使用这两个光照模型的着色器在低端硬件上可以提高渲染速度。 实现SurfaceShader下的物体透明效果 在SurfaceShader中使用Alpha混合实现透明效果 **透明度和 Alpha 测试**由 `alpha` 和 `alphatest` 指令控制。透明度通常可以有两种：传统的 Alpha 混合（用于淡出对象）或更符合物理规律的“预乘混合”（允许半透明表面保留适当的镜面反射）。启用半透明度会使生成的表面着色器代码包含 命令；而启用 Alpha 镂空将根据给定的变量在生成的像素着色器中执行片元废弃。\nalpha 或 alpha:auto - 对于简单的光照函数，将选择淡化透明度（与 alpha:fade 相同）；对于基于物理的光照函数，将选择预乘透明度（与 alpha:premul 相同）。\nalpha:blend - 启用 Alpha 混合。\nalpha:fade - 启用传统淡化透明度。\nalpha:premul - 启用预乘 Alpha 透明度。\nalphatest:VariableName - 启用 Alpha 镂空透明度。剪切值位于具有 VariableName 的浮点变量中。您可能还想使用 addshadow 指令生成正确的阴影投射物通道。\nkeepalpha - 默认情况下，无论输出结构的 Alpha 输出是什么，或者光照函数返回什么，不透明表面着色器都将 1.0（白色）写入 Alpha 通道。使用此选项可以保持光照函数的 Alpha 值，即使对于不透明的表面着色器也是如此。\ndecal:add - 附加贴花着色器（例如 terrain AddPass）。这适用于位于其他表面之上并使用附加混合的对象。请参阅 decal:blend - 半透明贴花着色器。这适用于位于其他表面之上并使用 Alpha 混合的对象。请参阅 材质的Alpha Source设置为FromGrayScale\n### 在Tags中指定渲染序列 `\u0026quot;queue\u0026quot;=\u0026quot;transparent\u0026quot;` 💡 对于透明物体来说可能不需要阴影，所以可以将fullforwardshadows 给去掉 💡 但此时阴影还会保留…..\n## 原因在于`FallBack` 中使用了`\u0026quot;Diffuse\u0026quot;` 它自带一个阴影投射器通道 💡 **解决方法：将FallBack注释掉即可 Tips：当Shader中没有指定阴影投射器时，FallBack中指定Shader的如果存在阴影投射器则会启用** \u0026gt; 如果没有`FallBack`，可以在`#pragma`中使用`addshadow`启用阴影投射通道 * Unity5.0以上完整代码 \\`\\`\\` Shader \u0026quot;Learning/2.SurfaceShader/SurfaceShader1\u0026quot; { Properties { \\_Color (\u0026quot;Color\u0026quot;, Color) = (1,1,1,1) \\_MainTex (\u0026quot;Albedo (RGB)\u0026quot;, 2D) = \u0026quot;white\u0026quot; {} \\_Glossiness (\u0026quot;Smoothness\u0026quot;, Range(0,1)) = 0.5 \\_Metallic (\u0026quot;Metallic\u0026quot;, Range(0,1)) = 0.0 } SubShader { Tags { \u0026quot;RenderType\u0026quot;=\u0026quot;Opaque\u0026quot; \u0026quot;queue\u0026quot;=\u0026quot;transparent\u0026quot; } LOD 200 \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;CGPROGRAM // Physically based Standard lighting model, and enable shadows on all light types //fullforwardshadows #pragma surface surf Standard alpha // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D \\_MainTex; struct Input { float2 uv\\_MainTex; }; half \\_Glossiness; half \\_Metallic; fixed4 \\_Color; // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader. // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. // #pragma instancing\\_options assumeuniformscaling UNITY\\_INSTANCING\\_BUFFER\\_START(Props) // put more per-instance properties here UNITY\\_INSTANCING\\_BUFFER\\_END(Props) void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (\\_MainTex, IN.uv\\_MainTex) \\* \\_Color; o.Albedo = c.rgb; // Metallic and smoothness come from slider variables o.Metallic = \\_Metallic; o.Smoothness = \\_Glossiness; o.Alpha = c.a; } ENDCG } //FallBack \u0026quot;Diffuse\u0026quot; } \\`\\`\\` * Unity5.0以下完整代码 \\`\\`\\` Shader \u0026quot;Learning/2.SurfaceShader/SurfaceShader1\u0026quot; { Properties { \\_MainTex (\u0026quot;Albedo (RGB)\u0026quot;, 2D) = \u0026quot;white\u0026quot; {} } SubShader { Tags { \u0026quot;RenderType\u0026quot;=\u0026quot;Opaque\u0026quot; \u0026quot;queue\u0026quot;=\u0026quot;transparent\u0026quot; } LOD 200 \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;CGPROGRAM // Physically based Standard lighting model, and enable shadows on all light types //fullforwardshadows #pragma surface surf Lambert fullforwardshadows alpha // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D \\_MainTex; struct Input { float2 uv\\_MainTex; }; void surf (Input IN, inout SurfaceOutput o) { // Albedo comes from a texture tinted by color fixed4 c = tex2D (\\_MainTex, IN.uv\\_MainTex); o.Albedo = c.rgb; o.Alpha = c.a; } ENDCG } //FallBack \u0026quot;Diffuse\u0026quot; } \\`\\`\\` # 光照多样化以及自定义光照 * 表面着色器示例 在内置渲染管线中，表面着色器是编写与光照交互的着色器的一种简化方式。\n## **渲染管线兼容性** 功能名称 内置渲染管线 通用渲染管线 (URP) 高清渲染管线 (HDRP) 自定义 SRP 表面着色器 是 否有关在 URP 中创建 Shader 对象的简化方法，请参阅 https://docs.unity3d.com/cn/current/Manual/shader-graph.html。 否有关在 HDRP 中创建 Shader 对象的简化方法，请参阅 https://docs.unity3d.com/cn/current/Manual/shader-graph.html。 否 \\## **简单的着色器示例** 我们将从一个非常简单的着色器 (Shader) 开始，并在此基础上加以丰富。下面的着色器将表面颜色设置为“白色”。它使用内置的兰伯特（漫射）光照模型。 \\`\\`\\` Shader \u0026quot;Example/Diffuse Simple\u0026quot; { SubShader { Tags { \u0026quot;RenderType\u0026quot; = \u0026quot;Opaque\u0026quot; } CGPROGRAM #pragma surface surf Lambert struct Input { float4 color : COLOR; }; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = 1; } ENDCG } Fallback \u0026quot;Diffuse\u0026quot; } \\`\\`\\` 以下是设置了两个 的模型：\n纹理 一个全白的对象很无聊，所以让我们添加一个纹理。我们将向着色器添加 代码块，这样我们将在材质中看到纹理选择器。 ``` Shader \u0026ldquo;Example/Diffuse Texture\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; }; sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ```\n法线贴图 我们来添加一些法线贴图： ``` Shader \u0026ldquo;Example/Diffuse Bump\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _BumpMap (\u0026ldquo;Bumpmap\u0026rdquo;, 2D) = \u0026ldquo;bump\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float2 uv_BumpMap; }; sampler2D _MainTex; sampler2D _BumpMap; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 边缘光照 现在，尝试添加一些边缘光照以突出游戏对象的边缘。我们将根据表面法线和视图方向之间的角度添加一些发射光照。为此，我们将使用内置的表面着色器变量 viewDir。 ``` Shader \u0026ldquo;Example/Rim\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _BumpMap (\u0026ldquo;Bumpmap\u0026rdquo;, 2D) = \u0026ldquo;bump\u0026rdquo; {} _RimColor (\u0026ldquo;Rim Color\u0026rdquo;, Color) = (0.26,0.19,0.16,0.0) _RimPower (\u0026ldquo;Rim Power\u0026rdquo;, Range(0.5,8.0)) = 3.0 } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float2 uv_BumpMap; float3 viewDir; }; sampler2D _MainTex; sampler2D _BumpMap; float4 _RimColor; float _RimPower; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); half rim = 1.0 - saturate(dot (normalize(IN.viewDir), o.Normal)); o.Emission = _RimColor.rgb * pow (rim, _RimPower); } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 细节纹理 为获得不同效果，让我们添加一个与基础纹理结合的细节纹理。细节纹理通常在材质中使用相同的 UV，但使用不同平铺，因此我们需要使用不同的输入 UV 坐标。 ``` Shader \u0026ldquo;Example/Detail\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _BumpMap (\u0026ldquo;Bumpmap\u0026rdquo;, 2D) = \u0026ldquo;bump\u0026rdquo; {} _Detail (\u0026ldquo;Detail\u0026rdquo;, 2D) = \u0026ldquo;gray\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float2 uv_BumpMap; float2 uv_Detail; }; sampler2D _MainTex; sampler2D _BumpMap; sampler2D _Detail; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; o.Albedo *= tex2D (_Detail, IN.uv_Detail).rgb * 2; o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 使用纹理棋盘格不一定有实际意义，但在此示例中可用于说明其作用 屏幕空间中的细节纹理 屏幕空间中的细节纹理对于士兵头部模型没有实际意义，但是在这里可用于说明如何使用内置的 screenPos 输入： ``` Shader \u0026ldquo;Example/ScreenPos\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _Detail (\u0026ldquo;Detail\u0026rdquo;, 2D) = \u0026ldquo;gray\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float4 screenPos; }; sampler2D _MainTex; sampler2D _Detail; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; float2 screenUV = IN.screenPos.xy / IN.screenPos.w; screenUV *= float2(8,6); o.Albedo *= tex2D (_Detail, screenUV).rgb * 2; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 从上面的着色器删除了法线贴图，只是为了缩短代码长度 立方体贴图反射 下面的着色器将使用内置 worldRefl 输入来进行立方体贴图反射。它与内置的反射/漫射着色器非常类似： ``` Shader \u0026ldquo;Example/WorldRefl\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _Cube (\u0026ldquo;Cubemap\u0026rdquo;, CUBE) = \u0026quot;\u0026quot; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float3 worldRefl; }; sampler2D _MainTex; samplerCUBE _Cube; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5; o.Emission = texCUBE (_Cube, IN.worldRefl).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 因为它将反射颜色指定为 Emission，所以我们得到了一个非常闪亮的士兵 如果您想做一些受法线贴图影响的反射，需要稍微复杂一些：需要将 INTERNAL_DATA 添加到 Input 结构，并使用 WorldReflectionVector 函数在写入法线输出后计算每像素反射矢量。 ``` Shader \u0026ldquo;Example/WorldRefl Normalmap\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _BumpMap (\u0026ldquo;Bumpmap\u0026rdquo;, 2D) = \u0026ldquo;bump\u0026rdquo; {} _Cube (\u0026ldquo;Cubemap\u0026rdquo;, CUBE) = \u0026quot;\u0026quot; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float2 uv_BumpMap; float3 worldRefl; INTERNAL_DATA }; sampler2D _MainTex; sampler2D _BumpMap; samplerCUBE _Cube; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb * 0.5; o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); o.Emission = texCUBE (_Cube, WorldReflectionVector (IN, o.Normal)).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 下面是一个进行了法线贴图的闪亮士兵：\n通过世界空间位置进行的切片 下面的着色器通过丢弃几乎水平的环形中的像素来对游戏对象“切片”。为实现此效果，它使用了基于像素世界位置的 Cg/HLSL 函数 clip()。我们将使用内置的表面着色器变量 worldPos。 ``` Shader \u0026ldquo;Example/Slices\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _BumpMap (\u0026ldquo;Bumpmap\u0026rdquo;, 2D) = \u0026ldquo;bump\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } Cull Off CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv_MainTex; float2 uv_BumpMap; float3 worldPos; }; sampler2D _MainTex; sampler2D _BumpMap; void surf (Input IN, inout SurfaceOutput o) { clip (frac((IN.worldPos.y+IN.worldPos.z*0.1) * 5) - 0.5); o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; o.Normal = UnpackNormal (tex2D (_BumpMap, IN.uv_BumpMap)); } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 使用顶点修改器进行法线挤出 可以使用“顶点修改器”函数来修改顶点着色器中的传入顶点数据。这可用于程序化动画和沿法线挤出等操作。表面着色器编译指令 vertex:functionName 将用于此目的，其中的一个函数采用 inout appdata_full 参数。 以下着色器沿着法线按照材质中指定的量移动顶点： ``` Shader \u0026ldquo;Example/Normal Extrusion\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _Amount (\u0026ldquo;Extrusion Amount\u0026rdquo;, Range(-1,1)) = 0.5 } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert vertex:vert struct Input { float2 uv_MainTex; }; float _Amount; void vert (inout appdata_full v) { v.vertex.xyz += v.normal * _Amount; } sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 沿着法线移动顶点会产生一个肥胖的士兵 每顶点计算的自定义数据 使用顶点修改器函数，还可以在顶点着色器中计算自定义数据，然后将数据按像素传递给表面着色器函数。此情况下使用相同的编译指令 vertex:functionName，但该函数应采用两个参数：inout appdata_full 和 out Input。您可以在其中填写除内置值以外的任何输入成员。 **注意：**以这种方式使用的自定义输入成员不得包含以“uv”开头的名称，否则它们将无法正常工作。 下面的示例定义了一个在顶点函数中计算的自定义 float3 customColor 成员： ``` Shader \u0026ldquo;Example/Custom Vertex Data\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert vertex:vert struct Input { float2 uv_MainTex; float3 customColor; }; void vert (inout appdata_full v, out Input o) { UNITY_INITIALIZE_OUTPUT(Input,o); o.customColor = abs(v.normal); } sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; o.Albedo *= IN.customColor; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 在此示例中，customColor 设置为法线的绝对值 更实际的用途可能是计算内置输入变量不提供的任何每顶点数据；或优化着色器计算。例如，可以在游戏对象的顶点处计算边缘光照，而不是在表面着色器中按照每个像素进行计算。 ## 最终颜色修改器 可以使用“最终颜色修改器”函数来修改着色器计算的最终颜色。表面着色器编译指令 finalcolor:functionName 将用于此目的，其中的一个函数采用 Input IN, SurfaceOutput o, inout fixed4 color 参数。 下面是一个简单的着色器，它将色调应用于最终颜色。这与仅对表面反照率颜色应用色调不同：此色调还会影响来自光照贴图、光照探针和类似额外来源的任何颜色。 ``` Shader \u0026ldquo;Example/Tint Final Color\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _ColorTint (\u0026ldquo;Tint\u0026rdquo;, Color) = (1.0, 0.6, 0.6, 1.0) } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert finalcolor:mycolor struct Input { float2 uv_MainTex; }; fixed4 _ColorTint; void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) { color *= _ColorTint; } sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ```\n使用最终颜色修改器自定义雾效 使用最终颜色修改器（见上文）的常见情况是在前向渲染中实现完全自定义的雾效。雾效需要影响最终计算的像素着色器颜色，这正是 finalcolor 修改器的功能。 下面是一个根据与屏幕中心的距离应用雾效色调的着色器。此着色器将顶点修改器与自定义顶点数据 (fog) 和最终颜色修改器组合在一起。用于前向渲染附加通道时，雾效需要淡化为黑色。此示例将解决这一问题并检查是否有 UNITY_PASS_FORWARDADD。 ``` Shader \u0026ldquo;Example/Fog via Final Color\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _FogColor (\u0026ldquo;Fog Color\u0026rdquo;, Color) = (0.3, 0.4, 0.7, 1.0) } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf Lambert finalcolor:mycolor vertex:myvert struct Input { float2 uv_MainTex; half fog; }; void myvert (inout appdata_full v, out Input data) { UNITY_INITIALIZE_OUTPUT(Input,data); float4 hpos = UnityObjectToClipPos(v.vertex); hpos.xy/=hpos.w; data.fog = min (1, dot (hpos.xy, hpos.xy)*0.5); } fixed4 _FogColor; void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) { fixed3 fogColor = _FogColor.rgb; #ifdef UNITY_PASS_FORWARDADD fogColor = 0; #endif color.rgb = lerp (color.rgb, fogColor, IN.fog); } sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 线性雾 ``` Shader \u0026ldquo;Example/Linear Fog\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Base (RGB)\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo;=\u0026ldquo;Opaque\u0026rdquo; } LOD 200 CGPROGRAM #pragma surface surf Lambert finalcolor:mycolor vertex:myvert #pragma multi_compile_fog sampler2D _MainTex; uniform half4 unity_FogStart; uniform half4 unity_FogEnd; struct Input { float2 uv_MainTex; half fog; }; void myvert (inout appdata_full v, out Input data) { UNITY_INITIALIZE_OUTPUT(Input,data); float pos = length(UnityObjectToViewPos(v.vertex).xyz); float diff = unity_FogEnd.x - unity_FogStart.x; float invDiff = 1.0f / diff; data.fog = clamp ((unity_FogEnd.x - pos) * invDiff, 0.0, 1.0); } void mycolor (Input IN, SurfaceOutput o, inout fixed4 color) { #ifdef UNITY_PASS_FORWARDADD UNITY_APPLY_FOG_COLOR(IN.fog, color, float4(0,0,0,0)); #else UNITY_APPLY_FOG_COLOR(IN.fog, color, unity_FogColor); #endif } void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D (_MainTex, IN.uv_MainTex); o.Albedo = c.rgb; o.Alpha = c.a; } ENDCG } FallBack \u0026ldquo;Diffuse\u0026rdquo; } ``` ## 贴花 贴花通常用于在运行时向材质添加细节（例如，子弹冲击力效果）。贴花在延迟渲染中特别有用，因为贴花在照亮之前会改变 G 缓冲区，因此可以节省开销。 在常规情况下，贴花应该在不透明对象之后渲染，并且不应该是阴影投射物，如以下示例中的 ShaderLab“Tags”中所示。 ``` Shader \u0026ldquo;Example/Decal\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Base (RGB)\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo;=\u0026ldquo;Opaque\u0026rdquo; \u0026ldquo;Queue\u0026rdquo;=\u0026ldquo;Geometry+1\u0026rdquo; \u0026ldquo;ForceNoShadowCasting\u0026rdquo;=\u0026ldquo;True\u0026rdquo; } LOD 200 Offset -1, -1 CGPROGRAM #pragma surface surf Lambert decal:blend sampler2D _MainTex; struct Input { float2 uv_MainTex; }; void surf (Input IN, inout SurfaceOutput o) { half4 c = tex2D (_MainTex, IN.uv_MainTex); o.Albedo = c.rgb; o.Alpha = c.a; } ENDCG } } ``` * \\*\\*\\*\\*表面着色器光照示例\\*\\*\\*\\* 因为延迟光照与一些自定义的每材质光照模型不兼容，所以下面的大多数示例都使着色器仅编译到前向渲染。\n## **渲染管线兼容性** 功能名称 内置渲染管线 通用渲染管线 (URP) 高清渲染管线 (HDRP) 自定义 SRP 表面着色器 是 否有关在 URP 中创建 Shader 对象的简化方法，请参阅 https://docs.unity3d.com/cn/current/Manual/shader-graph.html。 否有关在 HDRP 中创建 Shader 对象的简化方法，请参阅 https://docs.unity3d.com/cn/current/Manual/shader-graph.html。 否 \\## **Diffuse** 以下是使用内置兰伯特光照模型的着色器示例： \\`\\`\\` Shader \u0026quot;Example/Diffuse Texture\u0026quot; { Properties { \\_MainTex (\u0026quot;Texture\u0026quot;, 2D) = \u0026quot;white\u0026quot; {} } SubShader { Tags { \u0026quot;RenderType\u0026quot; = \u0026quot;Opaque\u0026quot; } CGPROGRAM #pragma surface surf Lambert struct Input { float2 uv\\_MainTex; }; sampler2D \\_MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (\\_MainTex, IN.uv\\_MainTex).rgb; } ENDCG } Fallback \u0026quot;Diffuse\u0026quot; } \\`\\`\\` 以下是有纹理和没有纹理的外观（在场景中使用一个方向光）： 以下示例显示了如何通过编写自定义光照模型（而不是使用内置兰伯特模型）来实现相同的结果。 为此，您需要使用许多表面着色器光照模型函数。下面是一个简单的兰伯特光照模型。请注意，只有CGPROGRAM 部分发生变化；周围的着色器代码完全相同： ``` Shader \u0026ldquo;Example/Diffuse Texture\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Texture\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo; = \u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf SimpleLambert half4 LightingSimpleLambert (SurfaceOutput s, half3 lightDir, half atten) { half NdotL = dot (s.Normal, lightDir); half4 c; c.rgb = s.Albedo * _LightColor0.rgb * (NdotL * atten); c.a = s.Alpha; return c; } struct Input { float2 uv_MainTex; }; sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG } Fallback \u0026ldquo;Diffuse\u0026rdquo; } ``` 这个简单的漫射光照模型使用了 LightingSimpleLambert 函数。它通过以下方式计算光照：计算表面法线和光线方向之间的点积，然后应用光衰减和颜色。 ## 漫射环绕 以下示例显示了环绕漫射，这是对漫射光照的修改，其中光照“环绕着”对象的边缘。它对于模拟次表面散射效果很有用。只有 CGPROGRAM 部分发生变化，这里同样省略了周围的着色器代码： ``` \u0026hellip;ShaderLab code\u0026hellip; CGPROGRAM #pragma surface surf WrapLambert half4 LightingWrapLambert (SurfaceOutput s, half3 lightDir, half atten) { half NdotL = dot (s.Normal, lightDir); half diff = NdotL * 0.5 + 0.5; half4 c; c.rgb = s.Albedo * _LightColor0.rgb * (diff * atten); c.a = s.Alpha; return c; } struct Input { float2 uv_MainTex; }; sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG \u0026hellip;ShaderLab code\u0026hellip; ``` 以下是有纹理和没有纹理的外观（在场景中使用一个方向光）：\n卡通渐变 (Toon Ramp) 以下示例显示了一个“渐变”光照模型，该模型使用纹理渐变来定义表面如何响应光源和法线之间的角度。这可以用于各种效果，并且在与卡通光照一起使用时尤其有效。 ``` \u0026hellip;ShaderLab code\u0026hellip; CGPROGRAM #pragma surface surf Ramp sampler2D _Ramp; half4 LightingRamp (SurfaceOutput s, half3 lightDir, half atten) { half NdotL = dot (s.Normal, lightDir); half diff = NdotL * 0.5 + 0.5; half3 ramp = tex2D (_Ramp, float2(diff)).rgb; half4 c; c.rgb = s.Albedo * _LightColor0.rgb * ramp * atten; c.a = s.Alpha; return c; } struct Input { float2 uv_MainTex; }; sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG \u0026hellip;ShaderLab code\u0026hellip; ``` 以下是有纹理和没有纹理的外观（在场景中使用一个方向光） 简单镜面反射 以下示例显示了一个简单的镜面反射光照模型，类似于内置的 BlinnPhong 光照模型。 ``` \u0026hellip;ShaderLab code\u0026hellip; CGPROGRAM #pragma surface surf SimpleSpecular half4 LightingSimpleSpecular (SurfaceOutput s, half3 lightDir, half3 viewDir, half atten) { half3 h = normalize (lightDir + viewDir); half diff = max (0, dot (s.Normal, lightDir)); float nh = max (0, dot (s.Normal, h)); float spec = pow (nh, 48.0); half4 c; c.rgb = (s.Albedo * _LightColor0.rgb * diff + _LightColor0.rgb * spec) * atten; c.a = s.Alpha; return c; } struct Input { float2 uv_MainTex; }; sampler2D _MainTex; void surf (Input IN, inout SurfaceOutput o) { o.Albedo = tex2D (_MainTex, IN.uv_MainTex).rgb; } ENDCG \u0026hellip;ShaderLab code\u0026hellip; ``` 以下是有纹理和没有纹理的外观（在场景中使用一个方向光） 自定义 GI 我们将从一个模仿 Unity 内置 GI 的着色器开始： ``` Shader \u0026ldquo;Example/CustomGI_ToneMapped\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Albedo (RGB)\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo;=\u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf StandardDefaultGI #include \u0026ldquo;UnityPBSLighting.cginc\u0026rdquo; sampler2D _MainTex; inline half4 LightingStandardDefaultGI(SurfaceOutputStandard s, half3 viewDir, UnityGI gi) { return LightingStandard(s, viewDir, gi); } inline void LightingStandardDefaultGI_GI( SurfaceOutputStandard s, UnityGIInput data, inout UnityGI gi) { LightingStandard_GI(s, data, gi); } struct Input { float2 uv_MainTex; }; void surf (Input IN, inout SurfaceOutputStandard o) { o.Albedo = tex2D(_MainTex, IN.uv_MainTex); } ENDCG } FallBack \u0026ldquo;Diffuse\u0026rdquo; } ``` 现在，让我们在 GI 上添加一些色调映射： ``` Shader \u0026ldquo;Example/CustomGI_ToneMapped\u0026rdquo; { Properties { _MainTex (\u0026ldquo;Albedo (RGB)\u0026rdquo;, 2D) = \u0026ldquo;white\u0026rdquo; {} _Gain(\u0026ldquo;Lightmap tone-mapping Gain\u0026rdquo;, Float) = 1 _Knee(\u0026ldquo;Lightmap tone-mapping Knee\u0026rdquo;, Float) = 0.5 _Compress(\u0026ldquo;Lightmap tone-mapping Compress\u0026rdquo;, Float) = 0.33 } SubShader { Tags { \u0026ldquo;RenderType\u0026rdquo;=\u0026ldquo;Opaque\u0026rdquo; } CGPROGRAM #pragma surface surf StandardToneMappedGI #include \u0026ldquo;UnityPBSLighting.cginc\u0026rdquo; half _Gain; half _Knee; half _Compress; sampler2D _MainTex; inline half3 TonemapLight(half3 i) { i = _Gain; return (i \u0026gt; _Knee) ?(((i - _Knee)_Compress) + _Knee) : i; } inline half4 LightingStandardToneMappedGI(SurfaceOutputStandard s, half3 viewDir, UnityGI gi) { return LightingStandard(s, viewDir, gi); } inline void LightingStandardToneMappedGI_GI( SurfaceOutputStandard s, UnityGIInput data, inout UnityGI gi) { LightingStandard_GI(s, data, gi); gi.light.color = TonemapLight(gi.light.color); #ifdef DIRLIGHTMAP_SEPARATE #ifdef LIGHTMAP_ON gi.light2.color = TonemapLight(gi.light2.color); #endif #ifdef DYNAMICLIGHTMAP_ON gi.light3.color = TonemapLight(gi.light3.color); #endif #endif gi.indirect.diffuse = TonemapLight(gi.indirect.diffuse); gi.indirect.specular = TonemapLight(gi.indirect.specular); } struct Input { float2 uv_MainTex; }; void surf (Input IN, inout SurfaceOutputStandard o) { o.Albedo = tex2D(_MainTex, IN.uv_MainTex); } ENDCG } FallBack \u0026ldquo;Diffuse\u0026rdquo; } ``` # Unity5.0以上的PBR基于物理着色的光照算法 💡 在CGIncludes文件夹当中的UnityStandardBRDF.cginc文件中 * UnityStandardBRDF.cginc完整代码 \\`\\`\\` #ifndef UNITY\\_STANDARD\\_BRDF\\_INCLUDED #define UNITY\\_STANDARD\\_BRDF\\_INCLUDED \u0026lt;/p\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;p\u0026gt;#include \u0026quot;UnityCG.cginc\u0026quot; #include \u0026quot;UnityStandardConfig.cginc\u0026quot; #include \u0026quot;UnityLightingCommon.cginc\u0026quot; //----------------------------------------------------------------------------- // Helper to convert smoothness to roughness //----------------------------------------------------------------------------- float PerceptualRoughnessToRoughness(float perceptualRoughness) { return perceptualRoughness \\* perceptualRoughness; } half RoughnessToPerceptualRoughness(half roughness) { return sqrt(roughness); } // Smoothness is the user facing name // it should be perceptualSmoothness but we don't want the user to have to deal with this name half SmoothnessToRoughness(half smoothness) { return (1 - smoothness) \\* (1 - smoothness); } float SmoothnessToPerceptualRoughness(float smoothness) { return (1 - smoothness); } //------------------------------------------------------------------------------------- inline half Pow4 (half x) { return x\u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;x\\*x; } inline float2 Pow4 (float2 x) { return x\u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;x\\*x; } inline half3 Pow4 (half3 x) { return x\u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;x\\*x; } inline half4 Pow4 (half4 x) { return x\u0026lt;em\u0026gt;x\u0026lt;/em\u0026gt;x\\*x; } // Pow5 uses the same amount of instructions as generic pow(), but has 2 advantages: // 1) better instruction pipelining // 2) no need to worry about NaNs inline half Pow5 (half x) { return x\u0026lt;em\u0026gt;x \\* x\u0026lt;/em\u0026gt;x \\* x; } inline half2 Pow5 (half2 x) { return x\u0026lt;em\u0026gt;x \\* x\u0026lt;/em\u0026gt;x \\* x; } inline half3 Pow5 (half3 x) { return x\u0026lt;em\u0026gt;x \\* x\u0026lt;/em\u0026gt;x \\* x; } inline half4 Pow5 (half4 x) { return x\u0026lt;em\u0026gt;x \\* x\u0026lt;/em\u0026gt;x \\* x; } inline half3 FresnelTerm (half3 F0, half cosA) { half t = Pow5 (1 - cosA); // ala Schlick interpoliation return F0 + (1-F0) \\* t; } inline half3 FresnelLerp (half3 F0, half3 F90, half cosA) { half t = Pow5 (1 - cosA); // ala Schlick interpoliation return lerp (F0, F90, t); } // approximage Schlick with ^4 instead of ^5 inline half3 FresnelLerpFast (half3 F0, half3 F90, half cosA) { half t = Pow4 (1 - cosA); return lerp (F0, F90, t); } // Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function. half DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness) { half fd90 = 0.5 + 2 \\* LdotH \\* LdotH \\* perceptualRoughness; // Two schlick fresnel term half lightScatter = (1 + (fd90 - 1) \\* Pow5(1 - NdotL)); half viewScatter = (1 + (fd90 - 1) \\* Pow5(1 - NdotV)); return lightScatter \\* viewScatter; } // NOTE: Visibility term here is the full form from Torrance-Sparrow model, it includes Geometric term: V = G / (N.L \\* N.V) // This way it is easier to swap Geometric terms and more room for optimizations (except maybe in case of CookTorrance geom term) // Generic Smith-Schlick visibility term inline half SmithVisibilityTerm (half NdotL, half NdotV, half k) { half gL = NdotL \\* (1-k) + k; half gV = NdotV \\* (1-k) + k; return 1.0 / (gL \\* gV + 1e-5f); // This function is not intended to be running on Mobile, // therefore epsilon is smaller than can be represented by half } // Smith-Schlick derived for Beckmann inline half SmithBeckmannVisibilityTerm (half NdotL, half NdotV, half roughness) { half c = 0.797884560802865h; // c = sqrt(2 / Pi) half k = roughness \\* c; return SmithVisibilityTerm (NdotL, NdotV, k) \\* 0.25f; // \\* 0.25 is the 1/4 of the visibility term } // Ref: http://jcgt.org/published/0003/02/03/paper.pdf inline float SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness) { #if 0 // Original formulation: // lambda\\_v = (-1 + sqrt(a2 \\* (1 - NdotL2) / NdotL2 + 1)) \\* 0.5f; // lambda\\_l = (-1 + sqrt(a2 \\* (1 - NdotV2) / NdotV2 + 1)) \\* 0.5f; // G = 1 / (1 + lambda\\_v + lambda\\_l); // Reorder code to be more optimal half a = roughness; half a2 = a \\* a; half lambdaV = NdotL \\* sqrt((-NdotV \\* a2 + NdotV) \\* NdotV + a2); half lambdaL = NdotV \\* sqrt((-NdotL \\* a2 + NdotL) \\* NdotL + a2); // Simplify visibility term: (2.0f \\* NdotL \\* NdotV) / ((4.0f \\* NdotL \\* NdotV) \\* (lambda\\_v + lambda\\_l + 1e-5f)); return 0.5f / (lambdaV + lambdaL + 1e-5f); // This function is not intended to be running on Mobile, // therefore epsilon is smaller than can be represented by half #else // Approximation of the above formulation (simplify the sqrt, not mathematically correct but close enough) float a = roughness; float lambdaV = NdotL \\* (NdotV \\* (1 - a) + a); float lambdaL = NdotV \\* (NdotL \\* (1 - a) + a); #if defined(SHADER\\_API\\_SWITCH) return 0.5f / (lambdaV + lambdaL + UNITY\\_HALF\\_MIN); #else return 0.5f / (lambdaV + lambdaL + 1e-5f); #endif #endif } inline float GGXTerm (float NdotH, float roughness) { float a2 = roughness \\* roughness; float d = (NdotH \\* a2 - NdotH) \\* NdotH + 1.0f; // 2 mad return UNITY\\_INV\\_PI \\* a2 / (d \\* d + 1e-7f); // This function is not intended to be running on Mobile, // therefore epsilon is smaller than what can be represented by half } inline half PerceptualRoughnessToSpecPower (half perceptualRoughness) { half m = PerceptualRoughnessToRoughness(perceptualRoughness); // m is the true academic roughness. half sq = max(1e-4f, m\\*m); half n = (2.0 / sq) - 2.0; // https://dl.dropboxusercontent.com/u/55891920/papers/mm\\_brdf.pdf n = max(n, 1e-4f); // prevent possible cases of pow(0,0), which could happen when roughness is 1.0 and NdotH is zero return n; } // BlinnPhong normalized as normal distribution function (NDF) // for use in micro-facet model: spec=D\u0026lt;em\u0026gt;G\u0026lt;/em\u0026gt;F // eq. 19 in https://dl.dropboxusercontent.com/u/55891920/papers/mm\\_brdf.pdf inline half NDFBlinnPhongNormalizedTerm (half NdotH, half n) { // norm = (n+2)/(2\\*pi) half normTerm = (n + 2.0) \\* (0.5/UNITY\\_PI); half specTerm = pow (NdotH, n); return specTerm \\* normTerm; } //------------------------------------------------------------------------------------- /\\* // https://s3.amazonaws.com/docs.knaldtech.com/knald/1.0.0/lys\\_power\\_drops.html const float k0 = 0.00098, k1 = 0.9921; // pass this as a constant for optimization const float fUserMaxSPow = 100000; // sqrt(12M) const float g\\_fMaxT = ( exp2(-10.0/fUserMaxSPow) - k0)/k1; float GetSpecPowToMip(float fSpecPow, int nMips) { // Default curve - Inverse of TB2 curve with adjusted constants float fSmulMaxT = ( exp2(-10.0/sqrt( fSpecPow )) - k0)/k1; return float(nMips-1)\\*(1.0 - clamp( fSmulMaxT/g\\_fMaxT, 0.0, 1.0 )); } //float specPower = PerceptualRoughnessToSpecPower(perceptualRoughness); //float mip = GetSpecPowToMip (specPower, 7); \\*/ inline float3 Unity\\_SafeNormalize(float3 inVec) { float dp3 = max(0.001f, dot(inVec, inVec)); return inVec \\* rsqrt(dp3); } //------------------------------------------------------------------------------------- // Note: BRDF entry points use smoothness and oneMinusReflectivity for optimization // purposes, mostly for DX9 SM2.0 level. Most of the math is being done on these (1-x) values, and that saves // a few precious ALU slots. // Main Physically Based BRDF // Derived from Disney work and based on Torrance-Sparrow micro-facet model // // BRDF = kD / pi + kS \\* (D \\* V \\* F) / 4 // I = BRDF \\* NdotL // // \\* NDF (depending on UNITY\\_BRDF\\_GGX): // a) Normalized BlinnPhong // b) GGX // \\* Smith for Visiblity term // \\* Schlick approximation for Fresnel half4 BRDF1\\_Unity\\_PBS (half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness, float3 normal, float3 viewDir, UnityLight light, UnityIndirect gi) { float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness); float3 halfDir = Unity\\_SafeNormalize (float3(light.dir) + viewDir); // NdotV should not be negative for visible pixels, but it can happen due to perspective projection and normal mapping // In this case normal should be modified to become valid (i.e facing camera) and not cause weird artifacts. // but this operation adds few ALU and users may not want it. Alternative is to simply take the abs of NdotV (less correct but works too). // Following define allow to control this. Set it to 0 if ALU is critical on your platform. // This correction is interesting for GGX with SmithJoint visibility function because artifacts are more visible in this case due to highlight edge of rough surface // Edit: Disable this code by default for now as it is not compatible with two sided lighting used in SpeedTree. #define UNITY\\_HANDLE\\_CORRECTLY\\_NEGATIVE\\_NDOTV 0 #if UNITY\\_HANDLE\\_CORRECTLY\\_NEGATIVE\\_NDOTV // The amount we shift the normal toward the view vector is defined by the dot product. half shiftAmount = dot(normal, viewDir); normal = shiftAmount \u0026lt; 0.0f ? normal + viewDir \\* (-shiftAmount + 1e-5f) : normal; // A re-normalization should be applied here but as the shift is small we don't do it to save ALU. //normal = normalize(normal); float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here #else half nv = abs(dot(normal, viewDir)); // This abs allow to limit artifact #endif float nl = saturate(dot(normal, light.dir)); float nh = saturate(dot(normal, halfDir)); half lv = saturate(dot(light.dir, viewDir)); half lh = saturate(dot(light.dir, halfDir)); // Diffuse term half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) \\* nl; // Specular term // HACK: theoretically we should divide diffuseTerm by Pi and not multiply specularTerm! // BUT 1) that will make shader look significantly darker than Legacy ones // and 2) on engine side \u0026quot;Non-important\u0026quot; lights have to be divided by Pi too in cases when they are injected into ambient SH float roughness = PerceptualRoughnessToRoughness(perceptualRoughness); #if UNITY\\_BRDF\\_GGX // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping. roughness = max(roughness, 0.002); float V = SmithJointGGXVisibilityTerm (nl, nv, roughness); float D = GGXTerm (nh, roughness); #else // Legacy half V = SmithBeckmannVisibilityTerm (nl, nv, roughness); half D = NDFBlinnPhongNormalizedTerm (nh, PerceptualRoughnessToSpecPower(perceptualRoughness)); #endif float specularTerm = V\\*D \\* UNITY\\_PI; // Torrance-Sparrow model, Fresnel is applied later \u0026lt;h1\u0026gt;ifdef UNITY\\_COLORSPACE\\_GAMMA\u0026lt;/h1\u0026gt; specularTerm = sqrt(max(1e-4h, specularTerm)); \u0026lt;h1\u0026gt;endif\u0026lt;/h1\u0026gt; // specularTerm \\* nl can be NaN on Metal in some cases, use max() to make sure it's a sane value specularTerm = max(0, specularTerm \\* nl); #if defined(\\_SPECULARHIGHLIGHTS\\_OFF) specularTerm = 0.0; #endif // surfaceReduction = Int D(NdotH) \\* NdotH \\* Id(NdotL\u0026gt;0) dH = 1/(roughness^2+1) half surfaceReduction; \u0026lt;h1\u0026gt;ifdef UNITY\\_COLORSPACE\\_GAMMA\u0026lt;/h1\u0026gt; surfaceReduction = 1.0-0.28\u0026lt;em\u0026gt;roughness\u0026lt;/em\u0026gt;perceptualRoughness; // 1-0.28\\*x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain \\[0;1\\] \u0026lt;h1\u0026gt;else\u0026lt;/h1\u0026gt; surfaceReduction = 1.0 / (roughness\\*roughness + 1.0); // fade in \\[0.5;1\\] \u0026lt;h1\u0026gt;endif\u0026lt;/h1\u0026gt; // To provide true Lambert lighting, we need to be able to kill specular completely. specularTerm \\*= any(specColor) ? 1.0 : 0.0; half grazingTerm = saturate(smoothness + (1-oneMinusReflectivity)); half3 color = diffColor \\* (gi.diffuse + light.color \\* diffuseTerm) + specularTerm \\* light.color \\* FresnelTerm (specColor, lh) + surfaceReduction \\* gi.specular \\* FresnelLerp (specColor, grazingTerm, nv); return half4(color, 1); } // Based on Minimalist CookTorrance BRDF // Implementation is slightly different from original derivation: http://www.thetenthplanet.de/archives/255 // // \\* NDF (depending on UNITY\\_BRDF\\_GGX): // a) BlinnPhong // b) \\[Modified\\] GGX // \\* Modified Kelemen and Szirmay-Kalos for Visibility term // \\* Fresnel approximated with 1/LdotH half4 BRDF2\\_Unity\\_PBS (half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness, float3 normal, float3 viewDir, UnityLight light, UnityIndirect gi) { float3 halfDir = Unity\\_SafeNormalize (float3(light.dir) + viewDir); half nl = saturate(dot(normal, light.dir)); float nh = saturate(dot(normal, halfDir)); half nv = saturate(dot(normal, viewDir)); float lh = saturate(dot(light.dir, halfDir)); // Specular term half perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness); half roughness = PerceptualRoughnessToRoughness(perceptualRoughness); #if UNITY\\_BRDF\\_GGX // GGX Distribution multiplied by combined approximation of Visibility and Fresnel // See \u0026quot;Optimizing PBR for Mobile\u0026quot; from Siggraph 2015 moving mobile graphics course // https://community.arm.com/events/1155 float a = roughness; float a2 = a\\*a; float d = nh \\* nh \\* (a2 - 1.f) + 1.00001f; #ifdef UNITY\\_COLORSPACE\\_GAMMA // Tighter approximation for Gamma only rendering mode! // DVF = sqrt(DVF); // DVF = (a \\* sqrt(.25)) / (max(sqrt(0.1), lh)\u0026lt;em\u0026gt;sqrt(roughness + .5) \\* d); float specularTerm = a / (max(0.32f, lh) \\* (1.5f + roughness) \\* d); #else float specularTerm = a2 / (max(0.1f, lh\u0026lt;/em\u0026gt;lh) \\* (roughness + 0.5f) \\* (d \\* d) \\* 4); #endif // on mobiles (where half actually means something) denominator have risk of overflow // clamp below was added specifically to \u0026quot;fix\u0026quot; that, but dx compiler (we convert bytecode to metal/gles) // sees that specularTerm have only non-negative terms, so it skips max(0,..) in clamp (leaving only min(100,...)) #if defined (SHADER\\_API\\_MOBILE) specularTerm = specularTerm - 1e-4f; #endif #else // Legacy half specularPower = PerceptualRoughnessToSpecPower(perceptualRoughness); // Modified with approximate Visibility function that takes roughness into account // Original ((n+1)\u0026lt;em\u0026gt;N.H^n) / (8\u0026lt;/em\u0026gt;Pi \\* L.H^3) didn't take into account roughness // and produced extremely bright specular at grazing angles half invV = lh \\* lh \\* smoothness + perceptualRoughness \\* perceptualRoughness; // approx ModifiedKelemenVisibilityTerm(lh, perceptualRoughness); half invF = lh; half specularTerm = ((specularPower + 1) \\* pow (nh, specularPower)) / (8 \\* invV \\* invF + 1e-4h); #ifdef UNITY\\_COLORSPACE\\_GAMMA specularTerm = sqrt(max(1e-4f, specularTerm)); #endif #endif #if defined (SHADER\\_API\\_MOBILE) specularTerm = clamp(specularTerm, 0.0, 100.0); // Prevent FP16 overflow on mobiles #endif #if defined(\\_SPECULARHIGHLIGHTS\\_OFF) specularTerm = 0.0; #endif // surfaceReduction = Int D(NdotH) \\* NdotH \\* Id(NdotL\u0026gt;0) dH = 1/(realRoughness^2+1) // 1-0.28\u0026lt;em\u0026gt;x^3 as approximation for (1/(x^4+1))^(1/2.2) on the domain \\[0;1\\] // 1-x^3\u0026lt;/em\u0026gt;(0.6-0.08\u0026lt;em\u0026gt;x) approximation for 1/(x^4+1) #ifdef UNITY\\_COLORSPACE\\_GAMMA half surfaceReduction = 0.28; #else half surfaceReduction = (0.6-0.08\u0026lt;/em\u0026gt;perceptualRoughness); #endif surfaceReduction = 1.0 - roughness\u0026lt;em\u0026gt;perceptualRoughness\u0026lt;/em\u0026gt;surfaceReduction; half grazingTerm = saturate(smoothness + (1-oneMinusReflectivity)); half3 color = (diffColor + specularTerm \\* specColor) \\* light.color \\* nl + gi.diffuse \\* diffColor + surfaceReduction \\* gi.specular \\* FresnelLerpFast (specColor, grazingTerm, nv); return half4(color, 1); } sampler2D\\_float unity\\_NHxRoughness; half3 BRDF3\\_Direct(half3 diffColor, half3 specColor, half rlPow4, half smoothness) { half LUT\\_RANGE = 16.0; // must match range in NHxRoughness() function in GeneratedTextures.cpp // Lookup texture to save instructions half specular = tex2D(unity\\_NHxRoughness, half2(rlPow4, SmoothnessToPerceptualRoughness(smoothness))).r \\* LUT\\_RANGE; #if defined(\\_SPECULARHIGHLIGHTS\\_OFF) specular = 0.0; #endif return diffColor + specular \\* specColor; } half3 BRDF3\\_Indirect(half3 diffColor, half3 specColor, UnityIndirect indirect, half grazingTerm, half fresnelTerm) { half3 c = indirect.diffuse \\* diffColor; c += indirect.specular \\* lerp (specColor, grazingTerm, fresnelTerm); return c; } // Old school, not microfacet based Modified Normalized Blinn-Phong BRDF // Implementation uses Lookup texture for performance // // \\* Normalized BlinnPhong in RDF form // \\* Implicit Visibility term // \\* No Fresnel term // // TODO: specular is too weak in Linear rendering mode half4 BRDF3\\_Unity\\_PBS (half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness, float3 normal, float3 viewDir, UnityLight light, UnityIndirect gi) { float3 reflDir = reflect (viewDir, normal); half nl = saturate(dot(normal, light.dir)); half nv = saturate(dot(normal, viewDir)); // Vectorize Pow4 to save instructions half2 rlPow4AndFresnelTerm = Pow4 (float2(dot(reflDir, light.dir), 1-nv)); // use R.L instead of N.H to save couple of instructions half rlPow4 = rlPow4AndFresnelTerm.x; // power exponent must match kHorizontalWarpExp in NHxRoughness() function in GeneratedTextures.cpp half fresnelTerm = rlPow4AndFresnelTerm.y; half grazingTerm = saturate(smoothness + (1-oneMinusReflectivity)); half3 color = BRDF3\\_Direct(diffColor, specColor, rlPow4, smoothness); color \\*= light.color \\* nl; color += BRDF3\\_Indirect(diffColor, specColor, gi, grazingTerm, fresnelTerm); return half4(color, 1); } // Include deprecated function #define INCLUDE\\_UNITY\\_STANDARD\\_BRDF\\_DEPRECATED #include \u0026quot;UnityDeprecated.cginc\u0026quot; #undef INCLUDE\\_UNITY\\_STANDARD\\_BRDF\\_DEPRECATED #endif // UNITY\\_STANDARD\\_BRDF\\_INCLUDED \\`\\`\\` ","permalink":"https://EitanWong.github.io/en/posts/shader/surfaceshader-%E8%A1%A8%E9%9D%A2%E7%9D%80%E8%89%B2%E5%99%A8/","summary":"完整案例代码 Shader \u0026#34;Learning/2.SurfaceShader/SurfaceShader1\u0026#34; { Properties { _Color (\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _MainTex (\u0026#34;Albedo (RGB)\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Glossiness (\u0026#34;Smoothness\u0026#34;, Range(0,1)) = 0.5 _Metallic (\u0026#34;Metallic\u0026#34;, Range(0,1)) = 0.0 } SubShader { Tags { \u0026#34;RenderType\u0026#34;=\u0026#34;Opaque\u0026#34; } LOD 200 CGPROGRAM // Physically based Standard lighting model, and enable shadows on all light types #pragma surface surf Standard fullforwardshadows // Use shader model 3.0 target, to get nicer looking lighting #pragma target 3.0 sampler2D _MainTex; struct Input { float2 uv_MainTex; }; half _Glossiness; half _Metallic; fixed4 _Color; // Add instancing support for this shader. You need to check \u0026#39;Enable Instancing\u0026#39; on materials that use the shader. // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing. // #pragma instancing_options assumeuniformscaling UNITY_INSTANCING_BUFFER_START(Props) // put more per-instance properties here UNITY_INSTANCING_BUFFER_END(Props) void surf (Input IN, inout SurfaceOutputStandard o) { // Albedo comes from","title":"SurfaceShader 表面着色器"},{"content":"Fixed function shader从字面意思理解，就是固定功能的渲染着色器 这种Shader功能有限，但速度却是最快的 但是能够在基本上所有的硬件平台上执行\n案例1：固定着色 Shader\u0026#34;Unlit/firstFixedShader\u0026#34; { SubShader { pass { color(1,1,1,1) } } } Properties 使用Properties，提供外部的Shader属性参数配置\n案例 Shader\u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) } SubShader { pass { //color(1,0,0,1) color[_Color] } } } () 小括号是固定的值 [ ]中括号是属性的值 所以填入color[_Color] 就可以把属性_Color给color 从而达到着色效果\nMaterial材质 案例1：漫反射光照Shader Shader \u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) } SubShader { pass { material { diffuse[_Color] } lighting on //off } } } material是一个功能块 diffuse是漫反射 diffuse[_Color]设置漫反射颜色 lighting on 开启光照，这样才能让Shader接受光照，从而实现漫反射效果\n案例2:加入环境光 Shader \u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] } lighting on //off } } } 红色部分就是环境光影响的部分 ambient 是环境光 在真实世界当中，一个物体会受到其环境光的影响 所以我们可以在Shader中加入环境光的效果，来模拟真实世界 创建一个属性**_Ambient** 为环境光传入属性ambient[_Ambient] 环境光Alpha通道，不会对环境光有任何影响\n案例3:高光 Shader \u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] specular[_Specular]//高光 } lighting on //off separatespecular on //高光计算 要使用specular功能，必须开启 } } } 如果不SeparateSpecular On，那么是不会计算高光的。 如果SeparateSpecular On，计算高光，但是高光是单独计算的。即计算漫反射环境光（但不包括高光）等相加起来得到的光照，跟纹理混合。混合之后的颜色再加上我们单独计算的高光，这样得到最终的颜色。要起作用，必须Lighting On\n真实世界中物体收到光照影响，会有高光部分 在固定渲染管线的Shader中 可以使用specular高光功能 来添加材质的高光着色 **specular[Color]**\n案例3:shininess调整高光集中度 Shader \u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] specular[_Specular]//高光 shininess[_Shiness]//高光集中度 } lighting on //off separatespecular on //要使用specular功能，必须开启 } } } shininess可以控制高光的集中度 shininess需要传入一个浮点值 所以外部定义属性的时候 可以将类型设置成float 或者是range\n案例4:Emission自发光 Shader \u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission]//自发光 } lighting on //off separatespecular on //要使用specular功能，必须开启 } } } Emission控制从表面发出的光的颜色和强度。当你在场景中使用Emission材质时，它以可见光源的形式出现。自发光。 Emission材质通常是用在GameObjects需要从内部亮了起来，如监视器上的屏幕，如汽车在夜间行驶时闪亮的仪表盘，或是再漆黑地方闪亮着怪物的眼睛。 在计算机中，会根据自发光颜色深度来处理自发光的效果 如果自发光颜色为纯白色，那渲染的材质就是非常亮\n可以减少颜色深度，提高真实感\n纯黑色的话就，看不到自发光效果\nLighting 在Pass中 lighting on//可以启用光照 启动的是定点光照\nSetTexture 在绘制材质过程中，有些时候，我们想要绘制指定的贴图纹理 在ShaderLab中，固定渲染着色器里可以使用settexture指令进行贴图绘制\n案例1：绘制纹理 Shader \u0026#34;Unlit/FixedTextureShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) _MainTex(\u0026#34;MainTex\u0026#34;,2D)=\u0026#34;\u0026#34; } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission] } lighting on separatespecular on settexture[_MainTex] } } } _MainTex(\u0026ldquo;MainTex\u0026rdquo;,2D)=\u0026quot;\u0026quot;//定义了一个2D纹理贴图的属性，默认值为字符串“”，默认值其实就是给纹理取一个名称，这里填写了空字符串 shaderlab不分大小写，所以属性类型写成2d或者2D都可以编译的 settexture[纹理属性] 传入纹理属性，来设置贴图\n案例2：使用combine混合纹理 Shader \u0026#34;Unlit/FixedTextureShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) _MainTex(\u0026#34;MainTex\u0026#34;,2D)=\u0026#34;\u0026#34; } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission] } lighting on separatespecular on settexture[_MainTex] { combine texture * primary double } } } } settexture[_Maintex] { //花阔号内可以设置绘制纹理时的功能命令 } combine就是一个混合纹理颜色的命令 texture就是当前设置的纹理颜色 primary是当前pass中material中设置的材质效果，和灯光还有高光反射颜色 texture*primary相当于对两个颜色进行正片叠底 也就是将两个颜色每个RGB通道的分量相乘 double 相当于将 混合的颜色再乘两倍，这样可以提高整体亮度，也可以乘4倍 quad\n案例3:多张纹理贴图混合 Shader \u0026#34;Unlit/FixedTextureShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) _MainTex(\u0026#34;MainTex\u0026#34;,2D)=\u0026#34;\u0026#34; _SecondTex(\u0026#34;SecondTex\u0026#34;,2D)=\u0026#34;\u0026#34; } SubShader { pass { material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission] } lighting on separatespecular on settexture[_MainTex] { combine texture * primary double } settexture[_SecondTex] { combine texture * previous double } } } } 这里要注意settexture并不是无限次的 不同的显卡支持的纹理混合次数是不同的\n在第二层settexture中 combine 命令混合时 是由当前纹理texture他颜色和previous颜色相乘 previous包含了上一次settexture混合的纹理颜色加上primary颜色 如果这里用primary的话 可以会导致无法获取到第一次settexture设置的纹理颜色 最终效果也就只有_SecondTex纹理的效果了\nShaderLab：Blending 确定 GPU 如何将片元着色器的输出与渲染目标进行合并。 此命令的功能取决于混合操作，您可以使用 BlendOp 命令进行设置。请注意，虽然所有图形 API 和硬件都支持混合功能，但对某些混合操作的支持较为有限。 启用混合会禁用 GPU 上的一些优化（主要是删除隐藏的表面/Early-Z），这些优化会增加 GPU 帧时间。 语法 Blend Off：关闭混合（这是默认设置） Blend SrcFactor DstFactor：配置并启用混合。生成的颜色乘以SrcFactor。屏幕上已有的颜色乘以DstFactor，然后将两者相加。 Blend SrcFactor DstFactor, SrcFactorA DstFactorA：与上面相同，但使用不同的因素来混合 Alpha 通道。 BlendOp Op：不是将混合颜色添加到一起，而是对它们执行不同的操作。 BlendOp OpColor, OpAlpha: 同上，但对颜色 (RGB) 和 alpha (A) 通道使用不同的混合操作。 此外，您可以设置上渲染目标混合模式。使用多渲染目标 (MRT) 时渲染，上面的常规语法为所有渲染目标设置了相同的混合模式。以下语法可以为各个渲染目标设置不同的混合模式，其中N是渲染目标索引 (0..7)。此功能适用于大多数现代 API/GPU（DX11/12、GLCore、Metal、PS4）：\nBlend N SrcFactor DstFactor Blend N SrcFactor DstFactor, SrcFactorA DstFactorA BlendOp N Op BlendOp N OpColor, OpAlpha AlphaToMask On：打开 alpha-to-coverage。当使用 MSAA 时，alpha-to-coverage 会根据像素着色器结果 alpha 值按比例修改多样本覆盖掩码。这通常用于比常规 alpha 测试更少锯齿的轮廓；对植被和其他经过 alpha 测试的着色器很有用。\n混合因子 以下所有属性对Blend命令中的 SrcFactor 和 DstFactor 均有效。Source是指计算出的颜色，Destination是屏幕上已有的颜色。如果BlendOp使用逻辑运算，则混合因子将被忽略。 混合操作 常见混合类型 (Blend Type) 以下是最常见的混合类型的语法：\nBlend SrcAlpha OneMinusSrcAlpha // 传统透明度 Blend One OneMinusSrcAlpha // 预乘透明度 Blend One One // 加法 Blend OneMinusDstColor One // 软加法 Blend DstColor Zero // 乘法 Blend DstColor SrcColor // 2x 乘法 案例4：实现材质的透明效果 当我们在渲染鼠标指的球体的时候的颜色，我们称之为源颜色 除了鼠标所指的球体以外的渲染的颜色（包括天空盒），我们称之为目标颜色 目标颜色，在我们渲染源颜色之前已经渲染过了\nShader \u0026#34;Unlit/FixedTextureShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) _MainTex(\u0026#34;MainTex\u0026#34;,2D)=\u0026#34;\u0026#34; _SecondTex(\u0026#34;SecondTex\u0026#34;,2D)=\u0026#34;\u0026#34; } SubShader { pass { Blend SrcAlpha OneMinusSrcAlpha material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission] } lighting on separatespecular on settexture[_MainTex] { combine texture * primary double } settexture[_SecondTex] { combine texture * previous double } } } } 可以看到 SrcAlpha OneMinusSrcAlpha 经过a*(1-a) 处理之后得到了传统的透明度的混合\n案例5：Tags与渲染队列 管理Tags的Unity文档⬇️ Shader \u0026#34;Unlit/FixedTextureShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) _MainTex(\u0026#34;MainTex\u0026#34;,2D)=\u0026#34;\u0026#34; _SecondTex(\u0026#34;SecondTex\u0026#34;,2D)=\u0026#34;\u0026#34; } SubShader { Tags{\u0026#34;Queue\u0026#34;=\u0026#34;Transparent\u0026#34;} pass { Blend SrcAlpha OneMinusSrcAlpha material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission] } lighting on separatespecular on settexture[_MainTex] { combine texture * primary double } settexture[_SecondTex] { combine texture * previous double } } } } 通过标签设置渲染队列为Transparent，透明物体，加上传统Alpha的混合，就可以实现透明物体的效果，透过物体可以看到背后渲染的物体\n案例6：使用纹理的Alpha通道，实现透明效果 Shader \u0026#34;Unlit/FixedTextureShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) _Ambient(\u0026#34;Ambient\u0026#34;,color)=(0.3,0.3,0.3,1) _Specular(\u0026#34;Specular\u0026#34;,color)=(1,1,1,1) _Shiness(\u0026#34;Shininess\u0026#34;,range(0,1))=1 _Emission(\u0026#34;Emission\u0026#34;,color)=(0.5,0.5,0.5,1) _MainTex(\u0026#34;MainTex\u0026#34;,2D)=\u0026#34;white\u0026#34;{} _SecondTex(\u0026#34;SecondTex\u0026#34;,2D)=\u0026#34;\u0026#34;{} _ConstantColor(\u0026#34;ConstantColor\u0026#34;,color)=(1,1,1,0.3) } SubShader { Tags{\u0026#34;Queue\u0026#34;=\u0026#34;Transparent\u0026#34;} pass { Blend SrcAlpha OneMinusSrcAlpha material { diffuse[_Color] ambient[_Ambient] specular[_Specular] shininess[_Shiness] emission[_Emission] } lighting on separatespecular on settexture[_MainTex] { combine texture * primary double } settexture[_SecondTex] { constantColor[_ConstantColor] combine texture * previous double,texture*constant//,逗号之后取颜色的Alpha通道 }//不同显卡有不同的最多支持混合次数 } } } constantColor命令指定一个颜色可以用于Combine指令。 combine逗号之后的参数 表示混合的Alpha颜色 让当前纹理texture颜色*constant指定的颜色 这样可以通过外部暴露的 _ConstantColor整体调整材质透明度，并且同时可以应用材质_SecondTex的透明度 注意： 除非后面都是2D纹理的属性否则定义2D纹理属性 初始化的值要写上{} 这里因为后面是颜色属性所以要写上{} 这样编译器才不会报错\n","permalink":"https://EitanWong.github.io/en/posts/shader/fixed-function-shader%E5%9B%BA%E5%AE%9A%E5%8A%9F%E8%83%BD%E7%9D%80%E8%89%B2%E5%99%A8/","summary":"Fixed function shader从字面意思理解，就是固定功能的渲染着色器 这种Shader功能有限，但速度却是最快的 但是能够在基本上所有的硬件平台上执行 案例1：固定着色 Shader\u0026#34;Unlit/firstFixedShader\u0026#34; { SubShader { pass { color(1,1,1,1) } } } Properties 使用Properties，提供外部的Shader属性参数配置 案例 Shader\u0026#34;Unlit/firstFixedShader\u0026#34; { Properties { _Color(\u0026#34;Main Color\u0026#34;,color)=(1,1,1,1) } SubShader { pass { //color(1,0,0,1) color[_Color] } } } () 小括号是固","title":"Fixed function shader固定功能着色器"},{"content":"Shader\u0026#34;ParentName/ShaderName\u0026#34; { Properties { } SubShader { Pass { } } } 格式 Propertyies参数列表 提供暴露的配置字段配置Shader 属性的格式 _属性名 (\u0026quot;外部名称\u0026quot;, 属性类型) = 初始化值\nSubShader 一个Shader中至少包含一个SubShader 一个ShaderLab中不能没有SubShader 一个Shader文件中可以包含多个SubShader 一个Shader文件运行的时候显卡会去检测是否存在一个当前运行环境可以运行的SubShader，如果有那就执行，所以多个SubShader，可以给不同的硬件以及平台运行，提高Shader的兼容性 如果没有找到可以运行的SubShader，就会执行FallBack，执行FallBack中保留的Shader 从上往下的SubShader要一个比一个简化 这样显卡可以根据当前的硬件软件环境，选择适合的SubShader\nFallBack回滚 当所有SubShader都无法执行，显卡会选择FallBack的Shader 可以填写自写的Shader 也可以填写Unity内建的Shader\nShaderLab: CustomEditor 定制ShaderLab外部属性配置的编辑器 语法格式：\nCustomEditor “MyCustomEditor” ","permalink":"https://EitanWong.github.io/en/posts/shader/shaderlab%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/","summary":"Shader\u0026#34;ParentName/ShaderName\u0026#34; { Properties { } SubShader { Pass { } } } 格式 Propertyies参数列表 提供暴露的配置字段配置Shader 属性的格式 _属性名 (\u0026quot;外部名称\u0026quot;, 属性类型) = 初始化值 SubShader 一个Shader中至少包含一个SubShader 一个ShaderLab中不能没有SubShader 一个Shade","title":"ShaderLab基本结构"},{"content":"UnityShader的形态 SurfaceShader 💡 这是一种在早期Unity版本中被鼓励使用的Shader，在Unity中创建Shader代码时，默认创建的就是SurfaceShader 💡 图形渲染管线能够识别的就只有两种Shader，VertexShader和FragmentShader SurfaceShader是在Vertex and Fragment Shader基础之上进行的一种包装 最终Unity引擎还是会把SurfaceShader编译成Vertex and Fragment Shader\nVertex and Fragment Shader 💡 顶点片元着色器 渲染管线最终可以执行并且处理的两种基本的Shader 可以使用Cg和GLSL语言去编写 它是镶嵌在ShaderLab中的代码片段\nFixed Function Shader 💡 固定功能Shader，在可编程渲染管线出现之前，很多光照都会在硬件级实现 对于这样的功能，一般都会用固定功能的Shader实现，这类Shader相对来说比较保守 功能也很固定，例如开关光照之类的，但是能够在绝大多数的设备上运行\nShaderLab基本结构 shader \u0026#34;name”{ [Properties] SubShaders [FallBack] } Properties 💡 在Unity的Material Inspector面板中，Shader可以定一个参数列表，以供美术或者开发人员进行调整Shader的参数\nProperties { _Color (\u0026#34;Color\u0026#34;, Color) = (1,1,1,1) _MainTex (\u0026#34;Albedo (RGB)\u0026#34;, 2D) = \u0026#34;white\u0026#34; {} _Glossiness (\u0026#34;Smoothness\u0026#34;, Range(0,1)) = 0.5 _Metallic (\u0026#34;Metallic\u0026#34;, Range(0,1)) = 0.0 } SubShaders 💡 专门为GPU渲染编写的具体算法片段\n一个Shader中，可以有多个SubShader，且至少要有一个SubShader 显卡去处理的时候，只能选择一个SubShader处理 作为Shader有可能存在某一种算法某一种指令在当前硬件不能得到支持 当一个Shader文件被执行运行时，会去检测当前硬件能不能够很好的完整支持 如果第一个SubShader能够很好的被完整支持，就会选择第一个SubShader执行 当不确定，或者不能很好的进行支持时，就选选择第二个SubShader进行执行\n💡 所以在设计SubShader时，越往下编写的，运算指令和算法就要越简化，为了支持更多不兼容的硬件\nSubShader { Tags { \u0026#34;ExampleSubShaderTagKey\u0026#34; = \u0026#34;ExampleSubShaderTagValue\u0026#34; } LOD 100 // ShaderLab commands that apply to the whole SubShader go here. Pass { Name \u0026#34;ExamplePassName\u0026#34; Tags { \u0026#34;ExamplePassTagKey\u0026#34; = \u0026#34;ExamplePassTagValue\u0026#34; } // ShaderLab commands that apply to this Pass go here. // HLSL code goes here. } } Fallback 💡 如果所有SubShader都不能被当前的硬件执行，那么就会自动进入Fallback回滚\nBuild-In Shader Unlit. This is just a texture, not affected by any lighting. 不发光。这只是一个纹理，不被任何光照果响 VertexLit. 顶点光照 Diffuse.漫反射 Normal mapped. This is a bit more expensive than Diffuse: it adds one more texture (normal map), and a couple of shader instructions. 法线贴图，比没反射更昂贵：增加了一个或更多纹理（法线见图）和几个著色器结构 Specular. This adds specular highlight calculation. 高光。这增加了特殊的高光计算 Normal Mapped Specular. Again, this is a bit more expensive than Specular. 高光法线贴图。这比高光更昂贵一点 Parallax Normal mapped. This adds parallax normal-mapping calculation. 视差法线贴图。这增加了视差法贴图计算 Parallax Normal Mapped Specular. This adds both parallax normal-mapping and specular highlight calculation. 视差高光法织圖。这增加了视差法线贴图和資面高光计算 CustomEditor 💡 自定义编辑器 可以使用CustomEditor “name” 自定义Shader属性展现的方式\nShader \u0026#34;example\u0026#34;{ // properties and subshaders here..• CuatomEditor \u0026#34;MyGustomEditoz\u0026#34; } ","permalink":"https://EitanWong.github.io/en/posts/shader/shader%E7%9A%84%E7%BB%84%E7%BB%87%E5%BD%A2%E5%BC%8F/","summary":"UnityShader的形态 SurfaceShader 💡 这是一种在早期Unity版本中被鼓励使用的Shader，在Unity中创建Shader代码时，默认创建的就是SurfaceShader 💡 图形渲染管线能够识别的就只有两种Shader，VertexShader和FragmentShader Surfac","title":"Shader的组织形式"},{"content":"GPU发展简史 GPU（Graphic Processing Unit），中文翻译为“图形处理器”，在现代计算机系统中的作用变得原来越重要。 20世纪六、七十年代，受硬件条件的限制，图形显示器只是计算机输出的一种工具。限于硬件发展水平，人们只是纯粹聪软件实现的角度来考虑图形用户界面的规范问题。此时还没有GPU的概念\nGPU概念在20世纪70年代末和80年代初被提出，使用单片集成电路（monolithic）作为图形芯片，此时的GPU被用于视频游戏和动画方面，它能够很快地进行几张图片的合成（仅限于此）。在20世纪80年代末到90年代初这段时间内，基于数字信号处理芯片（digital signal processor chip）的GPU被研发出来，与前代相比速度更快、功能更强，当然价格是非常昂贵。在1991年，S3 Graphics公司研制出第一个单芯片2D加速器，到了1995年，主流的PC图形芯片厂商都在自己的芯片商增加了对2D加速器的支持。\n1998年NVIDIA公司宣布modern GPU的研发成功 标志着GPU研发的历史性突破成为现实。通常将20世纪70年代末到1998年的这一段时间称之为pre-GPU时期，而自1998年往后的GPU称之为modern GPU。在pre-GPU时期，一些图形厂商，如SGI、Evans \u0026amp; Sutherland，都研发了各自的GPU，这些GPU在现在并没有被淘汰，依然在持续改进和被广泛的使用，当然价格也是非常的高昂。modern GPU 使用晶体管(transistors) 进行计算，在微芯片(microchip)中，GPU所使用的晶体管已经远远超过 CPU。例如，Intel在2.4GHz的Pentium IV上使用5千5百万 (55 million)个晶体管;而NVIDIA 在GeForce FX GPU上使用超过1亿2千5百万(125 million)个晶体管，在NVIDDIA 7800 GXT上的晶14体管达到3亿2百万(302 million)个。\n回顾GPU的发展历史 自1998年后可以分为4个阶段。NVIDIA于1998年宣布Modern GPU研发成功，这标志着第一代 Modern GPU的诞生，第一代GPU包括NVIDIA TNT2, ATI 的Rage和3Dfx的Voodoo。这些GPU可以独立于CPU进行像素缓存区的更新，并可以光栅化三角面片以及进行纹理操作，但是缺乏三维顶点的空间坐标变换能力，这意味着“必须依赖于CPU 执行顶点坐标变换的计算”。这一时期的GPU功能非常有限，只能用于纹理组合的数学计算或者像素颜色值的计算。 1999年，nvidia推出了一款可以用“惊变”来形容的显示核心代号NV10的geforce 256。nVidia率先将硬体T\u0026amp;L整合到显示核中。T\u0026amp;L原先由CPU负责，或者由另一个独立处理机处理。T\u0026amp;L是一大进步,原因是显视核心从CPU接管了大量工作。硬件T\u0026amp;L引擎带来的效果是，3D模型可以用更多的多边形来描绘，这样就拥有了更加细腻的效果。而对于Lighting来说，CPU不必再计算大量的光照数据，直接通过显卡就能获得更好的效能。同时，这一阶段的GPU对于纹理的操作也扩展到了立方体纹理(cube map)。NVIDIA的GeForce MAX, ATI的Radeon 7500等都是在这一阶段研发的。\n1999年，nvidia推出了一款可以用“惊变”来形容的显示核心代号NV10的geforce 256。 nVidia率先将硬体T\u0026amp;L整合到显示核中。T\u0026amp;L原先由CPU负责，或者由另一个独立处理机处理。T\u0026amp;L是一大进步,原因是显视核心从CPU接管了大量工作。硬件T\u0026amp;L引擎带来的效果是，3D模型可以用更多的多边形来描绘，这样就拥有了更加细腻的效果。而对于Lighting来说，CPU不必再计算大量的光照数据，直接通过显卡就能获得更好的效能。同时，这一阶段的GPU对于纹理的操作也扩展到了立方体纹理(cube map)。NVIDIA的GeForce MAX, ATI的Radeon 7500等都是在这一阶段研发的。\n2001年是第三代modern GPU的发展时期，这一时期研发的 GPU提供vertex programmability(顶点编程能力)，如GeForce 3,GeForce 4Ti, ATI 的8500等。 这些GPU 允许应用程序指定一个序列的指令进行顶点操作控制(GPU编程的本质!)，这同样是一个具有开创意义的时期，这一时期确立的GPU编程思想一直延续到今天，不但深入到工程领域帮助改善人类日常生活(医疗、地质勘探、游戏、电影等)，而易开创或延伸了计算机科学的诸多研究领域(体绘制、光照模拟、人群动画、通用计算等)。同时，Direct8 和OpenGl都本着与时俱进的精神，提供了支持vertex programmability的扩展。不过，这一时期的GPU还不支持像素级的编程能力，即fragment programmability (片段编程能力)\n所谓Vertex，就是我们熟悉的组成3D图形的顶点，由于设计3D模型是基于坐标空间内部设计的，所以Vertex信息包含了3D模型在空间内的坐标等信息。Vertex Shader则是对于Vertex信息哟运算编程器，可以通过赋予特定的算法而在工作中改变3D模型的外形， Vertex Shader顶点运算单元可以直接检索显存中的材质数据。现在的游戏场景越来越复杂了。所涉及到的材质和多边形数量都非常惊人。顶点材质技术可以极大的提高GPU在处理复杂的游戏场景时的效率。并且游戏开发人员还可以利用Vertex Shader的这一新的特性，充分发挥想象，实现很多非常漂亮的特效。例如在星际争霸2demo片中展示的神族母舰黑洞的技能效果。\n第四代GPU 的发展时期从2002年末到2003年。NVIDIA的GeForceFX 和ATI Radeon 9700同时在市场的舞台上闪亮登场，这GPUvertex programmability lfragment Programmability. miDirectx flOpenGL T#JAPI. Я #vertex programmability flfragment programmability。 í2003年起，可编程图形处理器正式诞生，并且由于DirectX 和 OpenGL锲而不舍的追赶潮流，导致基于图形硬件的编程技术， 简称GPU 编程，也宣告诞生。\nGPU的优越性 由于GPU具有高并行结构，所以GPU在处理图形数据和复杂 算法方面拥有比CPU更高的效率。CPU大部分面积为控制器和寄 存器，与之相比，GPU拥有更多的ALU（Arithmetic Logic Unit,逻 辑运算单元)用于数据处理，这样的结构适合对密集型数据进行 并行处理。\nGPU 采用流式并行计算模式，可对每个数据进行独立的并 行计算，所谓“对数据进行独立计算”，即，流内任意元素的计 算不依赖于其它同类型数据，例如，计算一个顶点的世界位置坐 标，不依赖于其他顶点的位置，所谓“并行计算”是指“多个数 据可以同时被使用，多个数据并行运算的时间和1个数据单独执 行的时间是一样的”。所以，在顶点处理程序中，可以同时处理 N个顶点数据。\nGPU的缺陷 由于“任意一个元素的计算不依赖于其它同类型数据”，导 致“需要知道数据之间相关性的”算法，在GPU 上难以得到实现， 一个典型的例子是射线与物体的求交运算。GPU 中的控制器少 于CPU，致使控制能力有限。另外，进行GPU编程必须掌握计算 机图形学相关知识，以及图形处理API，入门门槛较高，学习周 期较长，尤其国内关于GPU编程的资料较为匮之，这些都导致了 学习的难度。在早期，GPU编程只能使用汇编语言，开发难度高、 效率低，不过，随着高级Shader language 的兴起，在GPU 上编程 已经容易多了。\nGPU的更多应用 科学可视化计算：由于人体CT、地质勘探、气象数据、流体力学 等科学可视化计算处理的数据量极大，仅仅基于CPU 进行计算完 全不能满足实时性要求，而在GPU 上进行计算则可以在效率上达 到质的突破，许多在cPU 上非常耗时的算法，如体绘制中的光线 投射算法，都可以成功移植到GPU上，所以基于GPU的科学可视 化研究目前己经成为主流。 通用算法：基于GPU进行通用计算的研究逐渐成为热点，被称之 AIESEE\u0026amp; S SSPGESSREOTP器品兴装是片我头器 经在GPU上得到了实现，并有不谷的性能表现，目前，线性代数， 物理仿真和光线跟踪算法都已经成功的移植到GPU上。在国内， 中国科学院计算技术研究所进行了基于GPU的串匹配算法的实现\n","permalink":"https://EitanWong.github.io/en/posts/shader/%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%99%A8gpu%E7%AE%80%E5%8F%B2/","summary":"GPU发展简史 GPU（Graphic Processing Unit），中文翻译为“图形处理器”，在现代计算机系统中的作用变得原来越重要。 20世纪六、七十年代，受硬件条件的限制，图形显示器只是计算机输出的一种工具。限于硬件发展水平，人们只是纯粹聪软件实现的角度来考虑图形用户界面的规范问题。此时还没有G","title":"图形处理器（GPU）简史"},{"content":"什么是Shader Shader着色器，是一种较为短小的程序片段，用于告诉图形硬件如何计算和输出图像，过去由汇编语言来编写，现在也可以使用高级语言来编写。 💡 Shader是可编程图形管线的算法片段 它主要分为Vertex Shader和Fragment Shader\n什么是渲染管线 渲染管线也称为渲染流水线，是显示芯片内部处理图形信号相互独立的并行处理单元。一个流水线是一序列可以并行和按照固定的顺序进行的阶段。每个阶段都从它的前一阶段接收输入，然后把输出发给随后的配装线。就像一个在同一时间内，不同阶段不同汽车一起制造的装配线，传统的图形硬件流水线以流水的方式处理大量的顶点、几何图元和片段。\n💡 所谓GPU的渲染管线，听起来好像很高深的样子，其实我们可以把它理解为一个流程，就是我们告诉GPU一堆数据，最后得出来一副二维图像，而这些数据就包括了”视点、三维物体、光源、照明模型、纹理”等元素。 在各种图形学的书中，渲染管线主要分为三个阶段：应用程序阶段、几何阶段、光栅阶段。\n1、应用程序阶段 这个阶段相对比较好理解，就比如我们在Unity里开发了一个游戏，其实很多底层的东西Unity都帮我们实现好了，例如碰撞检测、视锥剪裁等等，这个阶段主要是和CPU、内存打交道，在把该计算的都计算完以后，在这个阶段的末端，这些计算好的数据（顶点坐标、法向量、纹理坐标、纹理）就会通过数据总线传给图形硬件，作为我们进一步处理的源数据。\n2、几何阶段 主要负责顶点坐标变换、光照、裁剪、投影以及屏幕映射，改阶段基于GPU进行运算，在该阶段的末端得到了经过变换和投影之后的顶点坐标、颜色、以及纹理坐标。简而言之，几何阶段的主要工作就是“变换三维顶点坐标”和“光照计算”。 问题随之而来，为什么要变换顶点坐标？我是这么理解的，比如你有一个三维游戏场景，场景中的每个模型都可以用一个向量来确定它的位置，但如何让计算机根据这些坐标把模型正确的、有层次的画在屏幕上？这就是我们需要变换三维顶点坐标的原因，最终目的就是让GPU可以将这些三维数据绘制到二维屏幕上。 根据顶点坐标变换的先后顺序，主要有如下几个坐标空间：Object space，模型坐标空间；World space，世界坐标空间；Eye space，观察坐标空间；Clip and Project space，屏幕坐标空间。下图就是GPU的整个处理流程，深色区域就是顶点坐标空间的变换流程，大家了解一下即可，我们需要关注的是每个坐标空间的具体含义和坐标空间之间转换的方法。\n2.1、从object space到world space object space有两层核心含义，第一，object space中的坐标值就是模型文件中的顶点值，这些值是在建立模型时得到的，例如一个.max文件，里面包含的数据就是object space的坐标。第二，object space的坐标与其他物体没有任何参照关系，这是object space和world space区分的关键。world space坐标的实际意义就有有一个坐标原点，物体跟坐标原点相比较才能知道自己的确切位置。例如在unity中，我们将一个模型导入到场景中以后，它的transform就是世界坐标。\n2.2、从world space到eye space 所谓eye space，就是以摄像机为原点，由视线方向、视角和远近平面，共同组成的一个梯形体，如下图，称之为视锥(viewing frustum)。近平面，是梯形体较小的矩形面，也是靠近摄像机的平面，远平面就是梯形体较大的矩形，作为投影平面。在这个梯形体的内的数据是可见的，超出的部分会被视点去除，也叫视锥剪裁。 例如在游戏中的漫游功能，屏幕的内容随摄像机的移动而变化，这是因为GPU将物体的顶点坐标从world space转换到了eye space。\n2.3、从eye space到project and clip space eye space坐标转换到project and clip space坐标的过程其实就是一个投影、剪裁、映射的过程。因为在不规则的视锥体内剪裁是一件非常困难的事，所以前人们将剪裁安排到一个单位立方体中进行，这个立方体被称为规范立方体（CCV），CVV的近平面（对应视锥体的近平面）的x、y坐标对应屏幕像素坐标（左下角0、0），z代表画面像素深度。所以这个转换过程事实上由三步组成： （1）、用透视变换矩阵把顶点从视锥体变换到CVV中； （2）、在CVV内进行剪裁； （3）、屏幕映射：将经过前两步得到的坐标映射到屏幕坐标系上。\n2.4、primitive assembly（图元装配）和triangle setup（三角形处理） 到目前为止我们得到了一堆顶点的数据，这一步就是根据这些顶点的原始连接关系还原出网格结构。网格由顶点和索引组成，这个阶段就是根据索引将顶点链接到一起，组成线、面单元，然后进行剪裁，如果一个三角形超出屏幕以外，例如两个顶点在屏幕内，一个顶点在屏幕外，这时我们在屏幕上看到的就是一个四边形，然后把这个四边形切成两个小的三角形。 现在我们得到了一堆在屏幕坐标上的三角形面片，这些面片是用于光栅化的。\n3、光栅化阶段 经过上面的步骤之后，我们得到了每个点的屏幕坐标值，和我们需要绘制的图元，但此时还有两个问题： （1）、屏幕坐标是浮点数，但像素是用整数来表示的，如何确定屏幕坐标值所对应的像素？ （2）、如何根据已确定位置的点，在屏幕上画出线段或者三角形？ 对于问题1，绘制的位置只能接近两指定端点间的实际线段位置，例如，一条线段的位置是（10.48， 20.51），转换为像素位置就是（10，21）。 问题2，涉及到具体的画线和填充算法，有兴趣的话可以研究。 这个过程结束后，顶点和图元已经对应到像素，之后的流程就是如何处理像素，即给像素赋予颜色值。 给像素赋予颜色的阶段称为Pixel Operation，是在更新帧缓存之前，执行最后一系列针对每个片段的操作，其目的是计算出每个像素的颜色值。在这个阶段，被遮挡的面通过一个被称为深度测试的过程消除。 pixel operation包含下面这些流程： （1）、消除遮挡面； （2）、Texture operation，纹理操作，根据像素的纹理坐标，查询对应的纹理值； （3）、Blending，通常称为alpha blending，根据目前已经画好的颜色，与正在计算的颜色的alpha值混合，形成新的颜色。 （4）、Filtering，将正在计算的颜色经过某种滤镜后输出。 该阶段之后，像素的颜色值被写入帧缓存中。\nShader和材质、贴图的关系 Shader(着色器)实际上就是一小段程序，它负责将输入的顶点数据以指定的方式和输入的贴图或者颜色等组合起来，然后输1.出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的Shader，以及对Shader的特定参数设置，将这些内容（Shader及输入参数）打包存储在一起得到的就是一个Material（材质）。 之后我们便可以将材质赋予三维物体来进行渲染输出 💡 材质好比是引擎最终使用的商品，Shader好比是生产这种商品的加工方法，而贴图就是原材料\nShader Language Shader Language的发展方向是设计出在便携性方面可以和C++\\Java相比的高级语言， 💡 “赋予程序员更灵活而方便的编程方式”，并“尽可能的控制渲染过程”同时“利用图形硬件的并行性，提高算法的效率”。 ShaderLanguage目前主要有3种语言\n基于OpenGL的\nOpenGLShadingLanguage (GLSL) 基于DirectX的\nHigh LevelShading Language（HLSL） NVIDIA公司的\nC for Graphic（Cg） ","permalink":"https://EitanWong.github.io/en/posts/shader/shader%E5%92%8C%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","summary":"什么是Shader Shader着色器，是一种较为短小的程序片段，用于告诉图形硬件如何计算和输出图像，过去由汇编语言来编写，现在也可以使用高级语言来编写。 💡 Shader是可编程图形管线的算法片段 它主要分为Vertex Shader和Fragment Shader 什么是渲染管线 渲染管线也称为渲染流","title":"Shader和渲染管线"},{"content":"About Me\nName: Eitan Wong Occupation: Programmer ","permalink":"https://EitanWong.github.io/en/about/","summary":"About Me Name: Eitan Wong Occupation: Programmer","title":"🙋🏻‍♂️About"},{"content":"Joshuto 图片预览 brew install ueberzug\n","permalink":"https://EitanWong.github.io/en/posts/other/%E6%88%91mac%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE/","summary":"Joshuto 图片预览 brew install ueberzug","title":""}]